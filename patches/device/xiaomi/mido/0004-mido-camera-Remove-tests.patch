From 99557c55db5a35e408f5e0ad6708c8eb33abb180 Mon Sep 17 00:00:00 2001
From: Michael Bestas <mkbestas@lineageos.org>
Date: Tue, 14 Nov 2017 17:19:35 +0200
Subject: [PATCH 04/12] mido: camera: Remove tests

Change-Id: I28c7acf0c8a33ff82d40d6019ed3e32de8f9593e
---
 camera/QCamera2/HAL/test/Android.mk                |   65 -
 camera/QCamera2/HAL/test/qcamera_test.cpp          | 3710 --------------------
 camera/QCamera2/HAL/test/qcamera_test.h            |  361 --
 camera/QCamera2/HAL3/test/Android.mk               |   48 -
 camera/QCamera2/HAL3/test/QCameraHAL3Base.cpp      |  447 ---
 camera/QCamera2/HAL3/test/QCameraHAL3Base.h        |  170 -
 .../HAL3/test/QCameraHAL3MainTestContext.cpp       |  276 --
 .../HAL3/test/QCameraHAL3MainTestContext.h         |   82 -
 .../QCamera2/HAL3/test/QCameraHAL3PreviewTest.cpp  |  206 --
 camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.h |   78 -
 .../HAL3/test/QCameraHAL3RawSnapshotTest.cpp       |  263 --
 .../HAL3/test/QCameraHAL3RawSnapshotTest.h         |   69 -
 .../QCamera2/HAL3/test/QCameraHAL3SnapshotTest.cpp |  260 --
 .../QCamera2/HAL3/test/QCameraHAL3SnapshotTest.h   |   69 -
 camera/QCamera2/HAL3/test/QCameraHAL3Test.cpp      |  216 --
 camera/QCamera2/HAL3/test/QCameraHAL3Test.h        |   63 -
 camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.cpp |  211 --
 camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.h   |   84 -
 camera/QCamera2/stack/Android.mk                   |    2 -
 camera/QCamera2/stack/mm-camera-test/Android.mk    |  195 -
 .../stack/mm-camera-test/inc/mm_qcamera_app.h      |  535 ---
 .../stack/mm-camera-test/inc/mm_qcamera_commands.h |   68 -
 .../stack/mm-camera-test/inc/mm_qcamera_dbg.h      |   38 -
 .../mm-camera-test/inc/mm_qcamera_main_menu.h      |  440 ---
 .../stack/mm-camera-test/inc/mm_qcamera_socket.h   |  113 -
 .../stack/mm-camera-test/src/mm_qcamera_app.c      | 2423 -------------
 .../stack/mm-camera-test/src/mm_qcamera_commands.c |  291 --
 .../mm-camera-test/src/mm_qcamera_dual_test.c      | 1933 ----------
 .../mm-camera-test/src/mm_qcamera_main_menu.c      | 2060 -----------
 .../stack/mm-camera-test/src/mm_qcamera_preview.c  | 1477 --------
 .../stack/mm-camera-test/src/mm_qcamera_queue.c    |  168 -
 .../stack/mm-camera-test/src/mm_qcamera_rdi.c      |  346 --
 .../mm-camera-test/src/mm_qcamera_reprocess.c      |  349 --
 .../stack/mm-camera-test/src/mm_qcamera_snapshot.c |  707 ----
 .../stack/mm-camera-test/src/mm_qcamera_socket.c   |  881 -----
 .../mm-camera-test/src/mm_qcamera_unit_test.c      |  695 ----
 .../stack/mm-camera-test/src/mm_qcamera_video.c    |  763 ----
 .../stack/mm-jpeg-interface/test/Android.mk        |   89 -
 .../stack/mm-jpeg-interface/test/mm_jpeg_test.c    |  776 ----
 .../stack/mm-jpeg-interface/test/mm_jpegdec_test.c |  479 ---
 .../stack/mm-lib2d-interface/test/Android.mk       |   38 -
 .../stack/mm-lib2d-interface/test/mm_lib2d_test.c  |  543 ---
 42 files changed, 22087 deletions(-)
 delete mode 100644 camera/QCamera2/HAL/test/Android.mk
 delete mode 100644 camera/QCamera2/HAL/test/qcamera_test.cpp
 delete mode 100644 camera/QCamera2/HAL/test/qcamera_test.h
 delete mode 100755 camera/QCamera2/HAL3/test/Android.mk
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3Base.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3Base.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3Test.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3Test.h
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.cpp
 delete mode 100755 camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/Android.mk
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_main_menu.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_dual_test.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_queue.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_rdi.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_reprocess.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_snapshot.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_unit_test.c
 delete mode 100644 camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
 delete mode 100644 camera/QCamera2/stack/mm-jpeg-interface/test/Android.mk
 delete mode 100644 camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpeg_test.c
 delete mode 100644 camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpegdec_test.c
 delete mode 100644 camera/QCamera2/stack/mm-lib2d-interface/test/Android.mk
 delete mode 100644 camera/QCamera2/stack/mm-lib2d-interface/test/mm_lib2d_test.c

diff --git a/camera/QCamera2/HAL/test/Android.mk b/camera/QCamera2/HAL/test/Android.mk
deleted file mode 100644
index 008f0f7..0000000
--- a/camera/QCamera2/HAL/test/Android.mk
+++ /dev/null
@@ -1,65 +0,0 @@
-LOCAL_PATH:= $(call my-dir)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    qcamera_test.cpp \
-
-LOCAL_SHARED_LIBRARIES:= \
-    libdl \
-    libui \
-    libutils \
-    libcutils \
-    libbinder \
-    libmedia \
-    libui \
-    libgui \
-    libcamera_client \
-    libskia \
-    libstagefright \
-    libstagefright_foundation \
-
-ifneq (1,$(filter 1,$(shell echo "$$(( $(PLATFORM_SDK_VERSION) >= 18 ))" )))
-
-LOCAL_SHARED_LIBRARIES += \
-    libmedia_native \
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-LOCAL_CFLAGS += -DUSE_JB_MR1
-
-endif
-
-LOCAL_C_INCLUDES += \
-    frameworks/base/include/ui \
-    frameworks/base/include/surfaceflinger \
-    frameworks/base/include/camera \
-    frameworks/base/include/media \
-    external/skia/include/core \
-    external/skia/include/images \
-    $(TARGET_OUT_HEADERS)/qcom/display \
-    $(LOCAL_PATH)/../stack/common \
-    $(LOCAL_PATH)/../stack/mm-camera-interface/inc \
-    frameworks/av/include/media/stagefright \
-    frameworks/native/include/media/openmax \
-    $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
-
-LOCAL_ADDITIONAL_DEPENDENCIES := $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
-
-LOCAL_MODULE:= camera_test
-LOCAL_MODULE_TAGS:= tests
-LOCAL_VENDOR_MODULE := true
-
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter
-LOCAL_CFLAGS += -O0
-
-ifeq (1,$(filter 1,$(shell echo "$$(( $(PLATFORM_SDK_VERSION) >= 20 ))" )))
-
-LOCAL_CFLAGS += -DUSE_SDK_20_OR_HIGHER
-
-ifeq ($(TARGET_USES_AOSP),true)
-LOCAL_CFLAGS += -DVANILLA_HAL
-endif
-
-endif
-
-#include $(BUILD_EXECUTABLE)
diff --git a/camera/QCamera2/HAL/test/qcamera_test.cpp b/camera/QCamera2/HAL/test/qcamera_test.cpp
deleted file mode 100644
index dd06c67..0000000
--- a/camera/QCamera2/HAL/test/qcamera_test.cpp
+++ /dev/null
@@ -1,3710 +0,0 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <time.h>
-#include <semaphore.h>
-#include <pthread.h>
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
-
-#include <ui/DisplayInfo.h>
-#include <gui/Surface.h>
-#include <gui/SurfaceComposerClient.h>
-#include <gui/ISurfaceComposer.h>
-
-#include <system/camera.h>
-
-#include <camera/Camera.h>
-#include <camera/ICamera.h>
-#include <camera/CameraParameters.h>
-#include <media/mediarecorder.h>
-
-#include <utils/RefBase.h>
-#include <utils/Mutex.h>
-#include <utils/Condition.h>
-#include <binder/IPCThreadState.h>
-#include <binder/ProcessState.h>
-#include <binder/IServiceManager.h>
-#include <cutils/properties.h>
-#include <cutils/memory.h>
-#include <SkImageDecoder.h>
-#include <SkImageEncoder.h>
-#include <MediaCodec.h>
-#include <OMX_IVCommon.h>
-#include <foundation/AMessage.h>
-#include <media/ICrypto.h>
-#include <MediaMuxer.h>
-#include <foundation/ABuffer.h>
-#include <MediaErrors.h>
-#include <gralloc_priv.h>
-#include <math.h>
-
-#include "qcamera_test.h"
-#include "cam_types.h"
-#include "mm_camera_dbg.h"
-
-#define VIDEO_BUF_ALLIGN(size, allign) \
-  (((size) + (allign-1)) & (typeof(size))(~(allign-1)))
-
-namespace qcamera {
-
-using namespace android;
-
-int CameraContext::JpegIdx = 0;
-int CameraContext::mPiPIdx = 0;
-const char CameraContext::KEY_ZSL[] = "zsl";
-
-/*===========================================================================
- * FUNCTION   : previewCallback
- *
- * DESCRIPTION: preview callback preview mesages are enabled
- *
- * PARAMETERS :
- *   @mem : preview buffer
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::previewCallback(const sp<IMemory>& mem)
-{
-    printf("PREVIEW Callback %p", mem->pointer());
-    uint8_t *ptr = (uint8_t*) mem->pointer();
-    if (NULL != ptr) {
-        printf("PRV_CB: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x",
-                ptr[0],
-                ptr[1],
-                ptr[2],
-                ptr[3],
-                ptr[4],
-                ptr[5],
-                ptr[6],
-                ptr[7],
-                ptr[8],
-                ptr[9]);
-    } else {
-        ALOGE(" no preview for NULL CB\n");
-    }
-}
-
-/*===========================================================================
- * FUNCTION   : useLock
- *
- * DESCRIPTION: Mutex lock for CameraContext
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void CameraContext::useLock()
-{
-    Mutex::Autolock l(mLock);
-    while (mInUse) {
-        mCond.wait(mLock);
-    }
-    mInUse = true;
-}
-
-/*===========================================================================
- * FUNCTION   : signalFinished
- *
- * DESCRIPTION: Mutex unlock CameraContext
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void CameraContext::signalFinished()
-{
-    Mutex::Autolock l(mLock);
-    mInUse = false;
-    mCond.signal();
-}
-
-/*===========================================================================
- * FUNCTION   : saveFile
- *
- * DESCRIPTION: helper function for saving buffers on filesystem
- *
- * PARAMETERS :
- *   @mem : buffer to save to filesystem
- *   @path: File path
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::saveFile(const sp<IMemory>& mem, String8 path)
-{
-    unsigned char *buff = NULL;
-    ssize_t size;
-    int fd = -1;
-
-    if (mem == NULL) {
-        return BAD_VALUE;
-    }
-
-    fd = open(path, O_CREAT | O_WRONLY | O_TRUNC, 0655);
-    if(fd < 0) {
-        printf("Unable to open file %s %s\n", path.string(), strerror(fd));
-        return -errno;
-    }
-
-    size = (ssize_t)mem->size();
-    if (size <= 0) {
-        printf("IMemory object is of zero size\n");
-        close(fd);
-        return BAD_VALUE;
-    }
-
-    buff = (unsigned char *)mem->pointer();
-    if (!buff) {
-        printf("Buffer pointer is invalid\n");
-        close(fd);
-        return BAD_VALUE;
-    }
-
-    if (size != write(fd, buff, (size_t)size)) {
-        printf("Bad Write error (%d)%s\n", errno, strerror(errno));
-        close(fd);
-        return INVALID_OPERATION;
-    }
-
-    printf("%s: buffer=%p, size=%lld stored at %s\n",
-            __FUNCTION__, buff, (long long int) size, path.string());
-
-    if (fd >= 0)
-        close(fd);
-
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : PiPCopyToOneFile
- *
- * DESCRIPTION: Copy the smaller picture to the bigger one
- *
- * PARAMETERS :
- *   @bitmap0 : Decoded image buffer 0
- *   @bitmap1 : Decoded image buffer 1
- *
- * RETURN     : decoded picture in picture in SkBitmap
- *==========================================================================*/
-SkBitmap * CameraContext::PiPCopyToOneFile(
-    SkBitmap *bitmap0, SkBitmap *bitmap1)
-{
-    size_t size0;
-    size_t size1;
-    SkBitmap *src;
-    SkBitmap *dst;
-    unsigned int dstOffset;
-    unsigned int srcOffset;
-
-    if (bitmap0 == NULL || bitmap1 == NULL) {
-        ALOGE(" bitmap0 : %p, bitmap1 : %p\n",  bitmap0, bitmap1);
-        return NULL;
-    }
-
-    size0 = bitmap0->getSize();
-    if (size0 <= 0) {
-        printf("Decoded image 0 is of zero size\n");
-        return NULL;
-    }
-
-    size1 = bitmap1->getSize();
-        if (size1 <= 0) {
-            printf("Decoded image 1 is of zero size\n");
-            return NULL;
-        }
-
-    if (size0 > size1) {
-        dst = bitmap0;
-        src = bitmap1;
-    } else if (size1 > size0){
-        dst = bitmap1;
-        src = bitmap0;
-    } else {
-        printf("Picture size should be with different size!\n");
-        return NULL;
-    }
-
-    for (unsigned int i = 0; i < (unsigned int)src->height(); i++) {
-        dstOffset = i * (unsigned int)dst->width() * mfmtMultiplier;
-        srcOffset = i * (unsigned int)src->width() * mfmtMultiplier;
-        memcpy(((unsigned char *)dst->getPixels()) + dstOffset,
-                ((unsigned char *)src->getPixels()) + srcOffset,
-                (unsigned int)src->width() * mfmtMultiplier);
-    }
-
-    return dst;
-}
-
-/*===========================================================================
- * FUNCTION   : decodeJPEG
- *
- * DESCRIPTION: decode jpeg input buffer.
- *
- * PARAMETERS :
- *   @mem     : buffer to decode
- *   @skBM    : decoded buffer
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
-
- *==========================================================================*/
-status_t CameraContext::decodeJPEG(const sp<IMemory>& mem, SkBitmap *skBM)
-{
-#ifndef USE_SDK_20_OR_HIGHER
-    SkBitmap::Config prefConfig = SkBitmap::kARGB_8888_Config;
-    const void *buff = NULL;
-    size_t size;
-
-    buff = (const void *)mem->pointer();
-    size= mem->size();
-
-    switch(prefConfig) {
-        case SkBitmap::kARGB_8888_Config:
-        {
-            mfmtMultiplier = 4;
-        }
-            break;
-
-        case SkBitmap::kARGB_4444_Config:
-        {
-            mfmtMultiplier = 2;
-        }
-        break;
-
-        case SkBitmap::kRGB_565_Config:
-        {
-            mfmtMultiplier = 2;
-        }
-        break;
-
-        case SkBitmap::kIndex8_Config:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        case SkBitmap::kA8_Config:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        default:
-        {
-            mfmtMultiplier = 0;
-            printf("Decode format is not correct!\n");
-        }
-        break;
-    }
-
-    if (SkImageDecoder::DecodeMemory(buff, size, skBM, prefConfig,
-            SkImageDecoder::kDecodePixels_Mode) == false) {
-        printf("%s():%d:: Failed during jpeg decode\n",__FUNCTION__,__LINE__);
-        return BAD_VALUE;
-    }
-#else
-    SkColorType prefConfig = kRGBA_8888_SkColorType;
-    const void *buff = NULL;
-    size_t size;
-
-    buff = (const void *)mem->pointer();
-    size= mem->size();
-
-    switch(prefConfig) {
-        case kRGBA_8888_SkColorType:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        case kBGRA_8888_SkColorType:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        case kARGB_4444_SkColorType:
-        {
-            mfmtMultiplier = 2;
-        }
-        break;
-
-        case kRGB_565_SkColorType:
-        {
-            mfmtMultiplier = 2;
-        }
-        break;
-
-        case kIndex_8_SkColorType:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        case kAlpha_8_SkColorType:
-        {
-            mfmtMultiplier = 4;
-        }
-        break;
-
-        default:
-        {
-            mfmtMultiplier = 0;
-            printf("Decode format is not correct!\n");
-        }
-        break;
-    }
-
-    if (SkImageDecoder::DecodeMemory(buff, size, skBM, prefConfig,
-            SkImageDecoder::kDecodePixels_Mode) == false) {
-        printf("%s():%d:: Failed during jpeg decode\n",__FUNCTION__,__LINE__);
-        return BAD_VALUE;
-    }
-
-#endif
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : encodeJPEG
- *
- * DESCRIPTION: encode the decoded input buffer.
- *
- * PARAMETERS :
- *   @stream  : SkWStream
- *   @bitmap  : SkBitmap decoded image to encode
- *   @path    : File path
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
-
- *==========================================================================*/
-status_t CameraContext::encodeJPEG(SkWStream * stream,
-    const SkBitmap *bitmap, String8 path)
-{
-    int qFactor = 100;
-
-    skJpegEnc = SkImageEncoder::Create(SkImageEncoder::kJPEG_Type);
-    if (!skJpegEnc) {
-        ALOGE(" skJpegEnc is NULL\n");
-        return BAD_VALUE;
-    }
-
-    if (skJpegEnc->encodeStream(stream, *bitmap, qFactor) == false) {
-        return BAD_VALUE;
-    }
-
-    FILE *fh = fopen(path.string(), "r+");
-    if ( !fh ) {
-        printf("Could not open file %s\n", path.string());
-        return BAD_VALUE;
-    }
-
-    fseek(fh, 0, SEEK_END);
-    size_t len = (size_t)ftell(fh);
-    rewind(fh);
-
-    if( !len ) {
-        printf("File %s is empty !\n", path.string());
-        fclose(fh);
-        return BAD_VALUE;
-    }
-
-    unsigned char *buff = (unsigned char*)malloc(len);
-    if (!buff) {
-        printf("Cannot allocate memory for buffer reading!\n");
-        return BAD_VALUE;
-    }
-
-    size_t readSize = fread(buff, 1, len, fh);
-    if (readSize != len) {
-        printf("Reading error\n");
-        return BAD_VALUE;
-    }
-
-    status_t ret = ReadSectionsFromBuffer(buff, len, READ_ALL);
-    if (ret != NO_ERROR) {
-        printf("Cannot read sections from buffer\n");
-        DiscardData();
-        DiscardSections();
-        return BAD_VALUE;
-    }
-    free(buff);
-    rewind(fh);
-
-    unsigned char temp = 0xff;
-    size_t writeSize = fwrite(&temp, sizeof(unsigned char), 1, fh);
-    if (1 != writeSize) {
-        printf("Writing error\n");
-    }
-    temp = 0xd8;
-    fwrite(&temp, sizeof(unsigned char), 1, fh);
-
-    for (size_t i = 0; i < mSectionsRead; i++) {
-        switch((mSections[i].Type)) {
-
-        case 0x123:
-            fwrite(mSections[i].Data, sizeof(unsigned char),
-                mSections[i].Size, fh);
-            break;
-
-        case 0xe0:
-            temp = 0xff;
-            fwrite(&temp, sizeof(unsigned char), 1, fh);
-            temp = 0xe1;
-            fwrite(&temp, sizeof(unsigned char), 1, fh);
-            fwrite(mJEXIFSection.Data, sizeof(unsigned char),
-                mJEXIFSection.Size, fh);
-            break;
-
-        default:
-            temp = 0xff;
-            fwrite(&temp, sizeof(unsigned char), 1, fh);
-            fwrite(&mSections[i].Type, sizeof(unsigned char), 1, fh);
-            fwrite(mSections[i].Data, sizeof(unsigned char),
-                mSections[i].Size, fh);
-            break;
-        }
-    }
-    fseek(fh, 0, SEEK_END);
-    len = (size_t)ftell(fh);
-    rewind(fh);
-    printf("%s: buffer=%p, size=%zu stored at %s\n",
-            __FUNCTION__, bitmap->getPixels(), len, path.string());
-
-    free(mJEXIFSection.Data);
-    DiscardData();
-    DiscardSections();
-    fclose(fh);
-    ret = NO_ERROR;
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : readSectionsFromBuffer
- *
- * DESCRIPTION: read all jpeg sections of input buffer.
- *
- * PARAMETERS :
- *   @mem : buffer to read from Metadata Sections
- *   @buffer_size: buffer size
- *   @ReadMode: Read mode - all, jpeg or exif
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::ReadSectionsFromBuffer (unsigned char *buffer,
-        size_t buffer_size, ReadMode_t ReadMode)
-{
-    int a;
-    size_t pos = 0;
-    int HaveCom = 0;
-    mSectionsAllocated = 10;
-
-    mSections = (Sections_t *)malloc(sizeof(Sections_t) * mSectionsAllocated);
-    if (!mSections) {
-        printf(" not enough memory\n");
-        return BAD_VALUE;
-    }
-
-    if (!buffer) {
-        printf("Input buffer is null\n");
-        return BAD_VALUE;
-    }
-
-    if (buffer_size < 1) {
-        printf("Input size is 0\n");
-        return BAD_VALUE;
-    }
-
-    a = (int) buffer[pos++];
-
-    if (a != 0xff || buffer[pos++] != M_SOI){
-        printf("No valid image\n");
-        return BAD_VALUE;
-    }
-
-    for(;;){
-        size_t itemlen;
-        int marker = 0;
-        size_t ll,lh;
-        unsigned char * Data;
-
-        CheckSectionsAllocated();
-
-        // The call to CheckSectionsAllocated() may reallocate mSections
-        // so need to check for NULL again.
-        if (mSections == NULL) {
-            printf(" not enough memory\n");
-            return BAD_VALUE;
-        }
-
-        for (a = 0; a <= 16; a++){
-            marker = buffer[pos++];
-            if (marker != 0xff) break;
-
-            if (a >= 16){
-                fprintf(stderr,"too many padding bytes\n");
-                return BAD_VALUE;
-            }
-        }
-
-        mSections[mSectionsRead].Type = marker;
-
-        // Read the length of the section.
-        lh = buffer[pos++];
-        ll = buffer[pos++];
-
-        itemlen = (lh << 8) | ll;
-
-        if (itemlen < 2) {
-            ALOGE("invalid marker");
-            return BAD_VALUE;
-        }
-
-        mSections[mSectionsRead].Size = itemlen;
-
-        Data = (unsigned char *)malloc(itemlen);
-        if (Data == NULL) {
-            ALOGE("Could not allocate memory");
-            return NO_MEMORY;
-        }
-        mSections[mSectionsRead].Data = Data;
-
-        // Store first two pre-read bytes.
-        Data[0] = (unsigned char)lh;
-        Data[1] = (unsigned char)ll;
-
-        if (pos+itemlen-2 > buffer_size) {
-            ALOGE("Premature end of file?");
-            return BAD_VALUE;
-        }
-
-        memcpy(Data+2, buffer+pos, itemlen-2); // Read the whole section.
-        pos += itemlen-2;
-
-        mSectionsRead += 1;
-
-        switch(marker){
-
-            case M_SOS:   // stop before hitting compressed data
-                // If reading entire image is requested, read the rest of the
-                // data.
-                if (ReadMode & READ_IMAGE){
-                    size_t size;
-                    // Determine how much file is left.
-                    size = buffer_size - pos;
-
-                    if (size < 1) {
-                        ALOGE("could not read the rest of the image");
-                        return BAD_VALUE;
-                    }
-                    Data = (unsigned char *)malloc(size);
-                    if (Data == NULL) {
-                        ALOGE("%d: could not allocate data for entire "
-                                "image size: %d", __LINE__, size);
-                        return BAD_VALUE;
-                    }
-
-                    memcpy(Data, buffer+pos, size);
-
-                    CheckSectionsAllocated();
-
-                    // The call to CheckSectionsAllocated()
-                    // may reallocate mSections
-                    // so need to check for NULL again.
-                    if (mSections == NULL) {
-                        printf(" not enough memory\n");
-                        return BAD_VALUE;
-                    }
-
-                    mSections[mSectionsRead].Data = Data;
-                    mSections[mSectionsRead].Size = size;
-                    mSections[mSectionsRead].Type = PSEUDO_IMAGE_MARKER;
-                    mSectionsRead ++;
-                    mHaveAll = 1;
-                }
-                return NO_ERROR;
-
-            case M_EOI:   // in case it's a tables-only JPEG stream
-                ALOGE("No image in jpeg!\n");
-                return BAD_VALUE;
-
-            case M_COM: // Comment section
-                if (HaveCom || ((ReadMode & READ_METADATA) == 0)){
-                    // Discard this section.
-                    free(mSections[--mSectionsRead].Data);
-                }
-                break;
-
-            case M_JFIF:
-                // Regular jpegs always have this tag, exif images have the
-                // exif marker instead, althogh ACDsee will write images
-                // with both markers.
-                // this program will re-create this marker on absence of exif
-                // marker.
-                // hence no need to keep the copy from the file.
-                if (ReadMode & READ_METADATA){
-                    if (memcmp(Data+2, "JFIF", 4) == 0) {
-                        break;
-                    }
-                    free(mSections[--mSectionsRead].Data);
-                }
-                break;
-
-            case M_EXIF:
-                // There can be different section using the same marker.
-                if (ReadMode & READ_METADATA){
-                    if (memcmp(Data+2, "Exif", 4) == 0){
-                        break;
-                    }else if (memcmp(Data+2, "http:", 5) == 0){
-                        // Change tag for internal purposes.
-                        mSections[mSectionsRead-1].Type = M_XMP;
-                        break;
-                    }
-                }
-                // Oterwise, discard this section.
-                free(mSections[--mSectionsRead].Data);
-                break;
-
-            case M_IPTC:
-                if (ReadMode & READ_METADATA){
-                    // Note: We just store the IPTC section.
-                    // Its relatively straightforward
-                    // and we don't act on any part of it,
-                    // so just display it at parse time.
-                }else{
-                    free(mSections[--mSectionsRead].Data);
-                }
-                break;
-
-            case M_SOF0:
-            case M_SOF1:
-            case M_SOF2:
-            case M_SOF3:
-            case M_SOF5:
-            case M_SOF6:
-            case M_SOF7:
-            case M_SOF9:
-            case M_SOF10:
-            case M_SOF11:
-            case M_SOF13:
-            case M_SOF14:
-            case M_SOF15:
-                break;
-            default:
-                // Skip any other sections.
-                break;
-        }
-    }
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : CheckSectionsAllocated
- *
- * DESCRIPTION: Check allocated jpeg sections.
- *
- * PARAMETERS : none
- *
- * RETURN     : none
-
- *==========================================================================*/
-void CameraContext::CheckSectionsAllocated(void)
-{
-    if (mSectionsRead > mSectionsAllocated){
-        ALOGE("allocation screw up");
-    }
-    if (mSectionsRead >= mSectionsAllocated){
-        mSectionsAllocated += mSectionsAllocated +1;
-        mSections = (Sections_t *)realloc(mSections,
-            sizeof(Sections_t) * mSectionsAllocated);
-        if (mSections == NULL){
-            ALOGE("could not allocate data for entire image");
-        }
-    }
-}
-
-/*===========================================================================
- * FUNCTION   : findSection
- *
- * DESCRIPTION: find the desired Section of the JPEG buffer.
- *
- * PARAMETERS :
- *  @SectionType: Section type
- *
- * RETURN     : return the found section
-
- *==========================================================================*/
-CameraContext::Sections_t *CameraContext::FindSection(int SectionType)
-{
-    for (unsigned int a = 0; a < mSectionsRead; a++) {
-        if (mSections[a].Type == SectionType){
-            return &mSections[a];
-        }
-    }
-    // Could not be found.
-    return NULL;
-}
-
-
-/*===========================================================================
- * FUNCTION   : DiscardData
- *
- * DESCRIPTION: DiscardData
- *
- * PARAMETERS : none
- *
- * RETURN     : none
-
- *==========================================================================*/
-void CameraContext::DiscardData()
-{
-    for (unsigned int a = 0; a < mSectionsRead; a++) {
-        free(mSections[a].Data);
-    }
-
-    mSectionsRead = 0;
-    mHaveAll = 0;
-}
-
-/*===========================================================================
- * FUNCTION   : DiscardSections
- *
- * DESCRIPTION: Discard allocated sections
- *
- * PARAMETERS : none
- *
- * RETURN     : none
-
- *==========================================================================*/
-void CameraContext::DiscardSections()
-{
-    free(mSections);
-    mSectionsAllocated = 0;
-    mHaveAll = 0;
-}
-
-/*===========================================================================
- * FUNCTION   : notify
- *
- * DESCRIPTION: notify callback
- *
- * PARAMETERS :
- *   @msgType : type of callback
- *   @ext1: extended parameters
- *   @ext2: extended parameters
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::notify(int32_t msgType, int32_t ext1, int32_t ext2)
-{
-    printf("Notify cb: %d %d %d\n", msgType, ext1, ext2);
-
-    if (( msgType & CAMERA_MSG_PREVIEW_FRAME)
-#ifndef VANILLA_HAL
-            && (ext1 == CAMERA_FRAME_DATA_FD)
-#endif
-       )
-    {
-        int fd = dup(ext2);
-        printf("notify Preview Frame fd: %d dup fd: %d\n", ext2, fd);
-        close(fd);
-    }
-
-    if ( msgType & CAMERA_MSG_FOCUS ) {
-        printf("AutoFocus %s \n",
-               (ext1) ? "OK" : "FAIL");
-    }
-
-    if ( msgType & CAMERA_MSG_SHUTTER ) {
-        printf("Shutter done \n");
-    }
-
-    if ( msgType & CAMERA_MSG_ERROR) {
-        printf("Camera Test CAMERA_MSG_ERROR\n");
-        stopPreview();
-        closeCamera();
-    }
-}
-
-/*===========================================================================
- * FUNCTION   : postData
- *
- * DESCRIPTION: handles data callbacks
- *
- * PARAMETERS :
- *   @msgType : type of callback
- *   @dataPtr: buffer data
- *   @metadata: additional metadata where available
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::postData(int32_t msgType,
-                             const sp<IMemory>& dataPtr,
-                             camera_frame_metadata_t *metadata)
-{
-    mInterpr->PiPLock();
-    Size currentPictureSize = mSupportedPictureSizes.itemAt(
-        mCurrentPictureSizeIdx);
-    unsigned char *buff = NULL;
-    size_t size;
-    status_t ret = 0;
-
-    memset(&mJEXIFSection, 0, sizeof(mJEXIFSection)),
-
-    printf("Data cb: %d\n", msgType);
-
-    if ( msgType & CAMERA_MSG_PREVIEW_FRAME ) {
-        previewCallback(dataPtr);
-    }
-
-    if ( msgType & CAMERA_MSG_RAW_IMAGE ) {
-        printf("RAW done \n");
-    }
-
-    if (msgType & CAMERA_MSG_POSTVIEW_FRAME) {
-        printf("Postview frame \n");
-    }
-
-    if (msgType & CAMERA_MSG_COMPRESSED_IMAGE ) {
-        String8 jpegPath;
-        jpegPath = jpegPath.format(QCAMERA_DUMP_FRM_LOCATION"img_%d.jpg",
-                JpegIdx);
-        if (!mPiPCapture) {
-            // Normal capture case
-            printf("JPEG done\n");
-            saveFile(dataPtr, jpegPath);
-            JpegIdx++;
-        } else {
-            // PiP capture case
-            SkFILEWStream *wStream;
-            ret = decodeJPEG(dataPtr, &skBMtmp);
-            if (NO_ERROR != ret) {
-                printf("Error in decoding JPEG!\n");
-                mInterpr->PiPUnlock();
-                return;
-            }
-
-            mWidthTmp = currentPictureSize.width;
-            mHeightTmp = currentPictureSize.height;
-            PiPPtrTmp = dataPtr;
-            // If there are two jpeg buffers
-            if (mPiPIdx == 1) {
-                printf("PiP done\n");
-
-                // Find the the capture with higher width and height and read
-                // its jpeg sections
-                if ((mInterpr->camera[0]->mWidthTmp * mInterpr->camera[0]->mHeightTmp) >
-                        (mInterpr->camera[1]->mWidthTmp * mInterpr->camera[1]->mHeightTmp)) {
-                    buff = (unsigned char *)PiPPtrTmp->pointer();
-                    size= PiPPtrTmp->size();
-                } else if ((mInterpr->camera[0]->mWidthTmp * mInterpr->camera[0]->mHeightTmp) <
-                        (mInterpr->camera[1]->mWidthTmp * mInterpr->camera[1]->mHeightTmp)) {
-                    buff = (unsigned char *)PiPPtrTmp->pointer();
-                    size= PiPPtrTmp->size();
-                } else {
-                    printf("Cannot take PiP. Images are with the same width"
-                            " and height size!!!\n");
-                    mInterpr->PiPUnlock();
-                    return;
-                }
-
-                if (buff != NULL && size != 0) {
-                    ret = ReadSectionsFromBuffer(buff, size, READ_ALL);
-                    if (ret != NO_ERROR) {
-                        printf("Cannot read sections from buffer\n");
-                        DiscardData();
-                        DiscardSections();
-                        mInterpr->PiPUnlock();
-                        return;
-                    }
-
-                    mJEXIFTmp = FindSection(M_EXIF);
-                    if (!mJEXIFTmp) {
-                        ALOGE("skBMDec is null\n");
-                        DiscardData();
-                        DiscardSections();
-                        return;
-                    }
-                    mJEXIFSection = *mJEXIFTmp;
-                    mJEXIFSection.Data = (unsigned char*)malloc(mJEXIFTmp->Size);
-                    if (!mJEXIFSection.Data) {
-                        ALOGE(" Not enough memory\n");
-                        DiscardData();
-                        DiscardSections();
-                        return;
-                    }
-                    memcpy(mJEXIFSection.Data,
-                        mJEXIFTmp->Data, mJEXIFTmp->Size);
-                    DiscardData();
-                    DiscardSections();
-
-                    wStream = new SkFILEWStream(jpegPath.string());
-                    skBMDec = PiPCopyToOneFile(&mInterpr->camera[0]->skBMtmp,
-                            &mInterpr->camera[1]->skBMtmp);
-                    if (!skBMDec) {
-                        ALOGE("skBMDec is null\n");
-                        delete wStream;
-                        return;
-                    }
-
-                    if (encodeJPEG(wStream, skBMDec, jpegPath) != false) {
-                        printf("%s():%d:: Failed during jpeg encode\n",
-                                __FUNCTION__,__LINE__);
-                        mInterpr->PiPUnlock();
-                        return;
-                    }
-                    mPiPIdx = 0;
-                    JpegIdx++;
-                    delete wStream;
-                }
-            } else {
-                mPiPIdx++;
-            }
-            disablePiPCapture();
-        }
-    }
-
-    if ((msgType & CAMERA_MSG_PREVIEW_METADATA) && (NULL != metadata)) {
-        printf("Face detected %d \n", metadata->number_of_faces);
-    }
-    mInterpr->PiPUnlock();
-
-}
-
-/*===========================================================================
- * FUNCTION   : postDataTimestamp
- *
- * DESCRIPTION: handles recording callbacks
- *
- * PARAMETERS :
- *   @timestamp : timestamp of buffer
- *   @msgType : type of buffer
- *   @dataPtr : buffer data
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::postDataTimestamp(nsecs_t timestamp,
-                                      int32_t msgType,
-                                      const sp<IMemory>& dataPtr)
-{
-    printf("Recording cb: %d %lld %p\n",
-            msgType, (long long int)timestamp, dataPtr.get());
-}
-
-/*===========================================================================
- * FUNCTION   : dataCallbackTimestamp
- *
- * DESCRIPTION: handles recording callbacks. Used for ViV recording
- *
- * PARAMETERS :
- *   @timestamp : timestamp of buffer
- *   @msgType : type of buffer
- *   @dataPtr : buffer data
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::dataCallbackTimestamp(nsecs_t timestamp,
-        int32_t msgType,
-        const sp<IMemory>& dataPtr)
-{
-    mInterpr->ViVLock();
-    // Not needed check. Just avoiding warnings of not used variables.
-    if (timestamp > 0)
-        timestamp = 0;
-    // Not needed check. Just avoiding warnings of not used variables.
-    if (msgType > 0)
-        msgType = 0;
-    size_t i = 0;
-    void * srcBuff = NULL;
-    void * dstBuff = NULL;
-
-    size_t srcYStride = 0, dstYStride = 0;
-    size_t srcUVStride = 0, dstUVStride = 0;
-    size_t srcYScanLines = 0, dstYScanLines = 0;
-    size_t srcUVScanLines = 0, dstUVScanLines = 0;
-    size_t srcOffset = 0, dstOffset = 0;
-    size_t srcBaseOffset = 0;
-    size_t dstBaseOffset = 0;
-    Size currentVideoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
-    status_t err = NO_ERROR;
-    ANativeWindowBuffer* anb = NULL;
-
-    dstBuff = (void *) dataPtr->pointer();
-    if (NULL == dstBuff) {
-        printf("Cannot access destination buffer!!!\n");
-        mInterpr->ViVUnlock();
-        return;
-    }
-
-    if (mCameraIndex == mInterpr->mViVVid.sourceCameraID) {
-        srcYStride = calcStride(currentVideoSize.width);
-        srcUVStride = calcStride(currentVideoSize.width);
-        srcYScanLines = calcYScanLines(currentVideoSize.height);
-        srcUVScanLines = calcUVScanLines(currentVideoSize.height);
-        mInterpr->mViVBuff.srcWidth = (size_t)currentVideoSize.width;
-        mInterpr->mViVBuff.srcHeight = (size_t)currentVideoSize.height;
-
-
-        mInterpr->mViVBuff.YStride = srcYStride;
-        mInterpr->mViVBuff.UVStride = srcUVStride;
-        mInterpr->mViVBuff.YScanLines = srcYScanLines;
-        mInterpr->mViVBuff.UVScanLines = srcUVScanLines;
-
-        memcpy( mInterpr->mViVBuff.buff, dstBuff,
-            mInterpr->mViVBuff.buffSize);
-
-        mInterpr->mViVVid.isBuffValid = true;
-    } else if (mCameraIndex == mInterpr->mViVVid.destinationCameraID) {
-        if(mInterpr->mViVVid.isBuffValid == true) {
-            dstYStride = calcStride(currentVideoSize.width);
-            dstUVStride = calcStride(currentVideoSize.width);
-            dstYScanLines = calcYScanLines(currentVideoSize.height);
-            dstUVScanLines = calcUVScanLines(currentVideoSize.height);
-
-            srcYStride = mInterpr->mViVBuff.YStride;
-            srcUVStride = mInterpr->mViVBuff.UVStride;
-            srcYScanLines = mInterpr->mViVBuff.YScanLines;
-            srcUVScanLines = mInterpr->mViVBuff.UVScanLines;
-
-
-            for (i = 0; i < mInterpr->mViVBuff.srcHeight; i++) {
-                srcOffset = i*srcYStride;
-                dstOffset = i*dstYStride;
-                memcpy((unsigned char *) dstBuff + dstOffset,
-                    (unsigned char *) mInterpr->mViVBuff.buff +
-                    srcOffset, mInterpr->mViVBuff.srcWidth);
-            }
-            srcBaseOffset = srcYStride * srcYScanLines;
-            dstBaseOffset = dstYStride * dstYScanLines;
-            for (i = 0; i < mInterpr->mViVBuff.srcHeight / 2; i++) {
-                srcOffset = i*srcUVStride + srcBaseOffset;
-                dstOffset = i*dstUVStride + dstBaseOffset;
-                memcpy((unsigned char *) dstBuff + dstOffset,
-                    (unsigned char *) mInterpr->mViVBuff.buff +
-                    srcOffset, mInterpr->mViVBuff.srcWidth);
-            }
-
-            err = native_window_dequeue_buffer_and_wait(
-                mInterpr->mViVVid.ANW.get(),&anb);
-            if (err != NO_ERROR) {
-                printf("Cannot dequeue anb for sensor %d!!!\n", mCameraIndex);
-                mInterpr->ViVUnlock();
-                return;
-            }
-            mInterpr->mViVVid.graphBuf = new GraphicBuffer(anb, false);
-            if(NULL == mInterpr->mViVVid.graphBuf.get()) {
-                printf("Invalid Graphic buffer\n");
-                mInterpr->ViVUnlock();
-                return;
-            }
-            err = mInterpr->mViVVid.graphBuf->lock(
-                GRALLOC_USAGE_SW_WRITE_OFTEN,
-                (void**)(&mInterpr->mViVVid.mappedBuff));
-            if (err != NO_ERROR) {
-                printf("Graphic buffer could not be locked %d!!!\n", err);
-                mInterpr->ViVUnlock();
-                return;
-            }
-
-            srcYStride = dstYStride;
-            srcUVStride = dstUVStride;
-            srcYScanLines = dstYScanLines;
-            srcUVScanLines = dstUVScanLines;
-            srcBuff = dstBuff;
-
-            for (i = 0; i < (size_t)currentVideoSize.height; i++) {
-                srcOffset = i*srcYStride;
-                dstOffset = i*dstYStride;
-                memcpy((unsigned char *) mInterpr->mViVVid.mappedBuff +
-                    dstOffset, (unsigned char *) srcBuff +
-                    srcOffset, (size_t)currentVideoSize.width);
-            }
-
-            srcBaseOffset = srcYStride * srcYScanLines;
-            dstBaseOffset = dstUVStride * (size_t)currentVideoSize.height;
-
-            for (i = 0; i < (size_t)currentVideoSize.height / 2; i++) {
-                srcOffset = i*srcUVStride + srcBaseOffset;
-                dstOffset = i*dstUVStride + dstBaseOffset;
-                memcpy((unsigned char *) mInterpr->mViVVid.mappedBuff +
-                    dstOffset, (unsigned char *) srcBuff +
-                    srcOffset, (size_t)currentVideoSize.width);
-            }
-
-
-            mInterpr->mViVVid.graphBuf->unlock();
-
-            err = mInterpr->mViVVid.ANW->queueBuffer(
-                mInterpr->mViVVid.ANW.get(), anb, -1);
-            if(err)
-                printf("Failed to enqueue buffer to recorder!!!\n");
-        }
-    }
-    mCamera->releaseRecordingFrame(dataPtr);
-
-    mInterpr->ViVUnlock();
-}
-
-/*===========================================================================
- * FUNCTION   : ViVEncoderThread
- *
- * DESCRIPTION: Creates a separate thread for ViV recording
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-status_t Interpreter::ViVEncoderThread()
-{
-    int ret = NO_ERROR;
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-
-    ret = pthread_create(&mViVEncThread, &attr, ThreadWrapper, this);
-    ret = pthread_attr_destroy(&attr);
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : ThreadWrapper
- *
- * DESCRIPTION: Helper function for for ViV recording thread
- *
- * PARAMETERS : Interpreter context
- *
- * RETURN     : None
- *==========================================================================*/
-void *Interpreter::ThreadWrapper(void *context) {
-    Interpreter *writer = static_cast<Interpreter *>(context);
-    writer->ViVEncode();
-    return NULL;
-}
-
-/*===========================================================================
- * FUNCTION   : ViVEncode
- *
- * DESCRIPTION: Thread for ViV encode. Buffers from video codec are sent to
- *              muxer and saved in a file.
- *
- * PARAMETERS : Interpreter context
- *
- * RETURN     : None
- *==========================================================================*/
-void Interpreter::ViVEncode()
-{
-    status_t err = NO_ERROR;
-    ssize_t trackIdx = -1;
-    uint32_t debugNumFrames = 0;
-
-    size_t bufIndex, offset, size;
-    int64_t ptsUsec;
-    uint32_t flags;
-    bool DoRecording = true;
-
-
-    err = mTestContext->mViVVid.codec->getOutputBuffers(
-        &mTestContext->mViVVid.buffers);
-    if (err != NO_ERROR) {
-        printf("Unable to get output buffers (err=%d)\n", err);
-    }
-
-    while (DoRecording) {
-        err = mTestContext->mViVVid.codec->dequeueOutputBuffer(
-            &bufIndex,
-            &offset,
-            &size,
-            &ptsUsec,
-            &flags, -1);
-
-        switch (err) {
-
-        case NO_ERROR:
-            // got a buffer
-            if ((flags & MediaCodec::BUFFER_FLAG_CODECCONFIG) != 0) {
-                // ignore this -- we passed the CSD into MediaMuxer when
-                // we got the format change notification
-                size = 0;
-            }
-            if (size != 0) {
-                // If the virtual display isn't providing us with timestamps,
-                // use the current time.
-                if (ptsUsec == 0) {
-                    ptsUsec = systemTime(SYSTEM_TIME_MONOTONIC) / 1000;
-                }
-
-                // The MediaMuxer docs are unclear, but it appears that we
-                // need to pass either the full set of BufferInfo flags, or
-                // (flags & BUFFER_FLAG_SYNCFRAME).
-                err = mTestContext->mViVVid.muxer->writeSampleData(
-                    mTestContext->mViVVid.buffers[bufIndex],
-                    (size_t)trackIdx,
-                    ptsUsec,
-                    flags);
-                if (err != NO_ERROR) {
-                    fprintf(stderr, "Failed writing data to muxer (err=%d)\n",
-                            err);
-                }
-                debugNumFrames++;
-            }
-            err = mTestContext->mViVVid.codec->releaseOutputBuffer(bufIndex);
-            if (err != NO_ERROR) {
-                fprintf(stderr, "Unable to release output buffer (err=%d)\n",
-                        err);
-            }
-            if ((flags & MediaCodec::BUFFER_FLAG_EOS) != 0) {
-                // Not expecting EOS from SurfaceFlinger.  Go with it.
-                printf("Received end-of-stream\n");
-                //DoRecording = false;
-            }
-            break;
-        case -EAGAIN:                       // INFO_TRY_AGAIN_LATER
-            ALOGV("Got -EAGAIN, looping");
-            break;
-        case INFO_FORMAT_CHANGED:           // INFO_OUTPUT_FORMAT_CHANGED
-        {
-            // format includes CSD, which we must provide to muxer
-            sp<AMessage> newFormat;
-            mTestContext->mViVVid.codec->getOutputFormat(&newFormat);
-            trackIdx = mTestContext->mViVVid.muxer->addTrack(newFormat);
-            err = mTestContext->mViVVid.muxer->start();
-            if (err != NO_ERROR) {
-                printf("Unable to start muxer (err=%d)\n", err);
-            }
-        }
-        break;
-        case INFO_OUTPUT_BUFFERS_CHANGED:   // INFO_OUTPUT_BUFFERS_CHANGED
-            // not expected for an encoder; handle it anyway
-            ALOGV("Encoder buffers changed");
-            err = mTestContext->mViVVid.codec->getOutputBuffers(
-                &mTestContext->mViVVid.buffers);
-            if (err != NO_ERROR) {
-                printf("Unable to get new output buffers (err=%d)\n", err);
-            }
-        break;
-        case INVALID_OPERATION:
-            DoRecording = false;
-        break;
-        default:
-            printf("Got weird result %d from dequeueOutputBuffer\n", err);
-        break;
-        }
-    }
-
-    return;
-}
-
-/*===========================================================================
- * FUNCTION   : calcBufferSize
- *
- * DESCRIPTION: Temp buffer size calculation. Temp buffer is used to store
- *              the buffer from the camera with smaller resolution. It is
- *              copied to the buffer from camera with higher resolution.
- *
- * PARAMETERS :
- *   @width   : video size width
- *   @height  : video size height
- *
- * RETURN     : size_t
- *==========================================================================*/
-size_t CameraContext::calcBufferSize(int width, int height)
-{
-    size_t size = 0;
-    size_t UVAlignment;
-    size_t YPlane, UVPlane, YStride, UVStride, YScanlines, UVScanlines;
-    if (!width || !height) {
-        return size;
-    }
-    UVAlignment = 4096;
-    YStride = calcStride(width);
-    UVStride = calcStride(width);
-    YScanlines = calcYScanLines(height);
-    UVScanlines = calcUVScanLines(height);
-    YPlane = YStride * YScanlines;
-    UVPlane = UVStride * UVScanlines + UVAlignment;
-    size = YPlane + UVPlane;
-    size = VIDEO_BUF_ALLIGN(size, 4096);
-
-    return size;
-}
-
-/*===========================================================================
- * FUNCTION   : calcStride
- *
- * DESCRIPTION: Temp buffer stride calculation.
- *
- * PARAMETERS :
- *   @width   : video size width
- *
- * RETURN     : size_t
- *==========================================================================*/
-size_t CameraContext::calcStride(int width)
-{
-    size_t alignment, stride = 0;
-    if (!width) {
-        return stride;
-    }
-    alignment = 128;
-    stride = VIDEO_BUF_ALLIGN((size_t)width, alignment);
-
-    return stride;
-}
-
-/*===========================================================================
- * FUNCTION   : calcYScanLines
- *
- * DESCRIPTION: Temp buffer scanlines calculation for Y plane.
- *
- * PARAMETERS :
- *   @width   : video size height
- *
- * RETURN     : size_t
- *==========================================================================*/
-size_t CameraContext::calcYScanLines(int height)
-{
-    size_t alignment, scanlines = 0;
-        if (!height) {
-            return scanlines;
-        }
-    alignment = 32;
-    scanlines = VIDEO_BUF_ALLIGN((size_t)height, alignment);
-
-    return scanlines;
-}
-
-/*===========================================================================
- * FUNCTION   : calcUVScanLines
- *
- * DESCRIPTION: Temp buffer scanlines calculation for UV plane.
- *
- * PARAMETERS :
- *   @width   : video size height
- *
- * RETURN     : size_t
- *==========================================================================*/
-size_t CameraContext::calcUVScanLines(int height)
-{
-    size_t alignment, scanlines = 0;
-    if (!height) {
-        return scanlines;
-    }
-    alignment = 16;
-    scanlines = VIDEO_BUF_ALLIGN((size_t)((height + 1) >> 1), alignment);
-
-    return scanlines;
-}
-
-/*===========================================================================
- * FUNCTION   : printSupportedParams
- *
- * DESCRIPTION: dump common supported parameters
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::printSupportedParams()
-{
-    const char *camera_ids = mParams.get("camera-indexes");
-    const char *pic_sizes = mParams.get(CameraParameters::KEY_SUPPORTED_PICTURE_SIZES);
-    const char *pic_formats = mParams.get(CameraParameters::KEY_SUPPORTED_PICTURE_FORMATS);
-    const char *preview_sizes = mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_SIZES);
-    const char *video_sizes = mParams.get(CameraParameters::KEY_SUPPORTED_VIDEO_SIZES);
-    const char *preview_formats = mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FORMATS);
-    const char *frame_rates = mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FRAME_RATES);
-    const char *thumb_sizes = mParams.get(CameraParameters::KEY_SUPPORTED_JPEG_THUMBNAIL_SIZES);
-    const char *wb_modes = mParams.get(CameraParameters::KEY_SUPPORTED_WHITE_BALANCE);
-    const char *effects = mParams.get(CameraParameters::KEY_SUPPORTED_EFFECTS);
-    const char *scene_modes = mParams.get(CameraParameters::KEY_SUPPORTED_SCENE_MODES);
-    const char *focus_modes = mParams.get(CameraParameters::KEY_SUPPORTED_FOCUS_MODES);
-    const char *antibanding_modes = mParams.get(CameraParameters::KEY_SUPPORTED_ANTIBANDING);
-    const char *flash_modes = mParams.get(CameraParameters::KEY_SUPPORTED_FLASH_MODES);
-    int focus_areas = mParams.getInt(CameraParameters::KEY_MAX_NUM_FOCUS_AREAS);
-    const char *fps_ranges = mParams.get(CameraParameters::KEY_SUPPORTED_PREVIEW_FPS_RANGE);
-    const char *focus_distances = mParams.get(CameraParameters::KEY_FOCUS_DISTANCES);
-
-    printf("\n\r\tSupported Cameras: %s",
-           (camera_ids != NULL)? camera_ids : "NULL");
-    printf("\n\r\tSupported Picture Sizes: %s",
-           (pic_sizes != NULL)? pic_sizes : "NULL");
-    printf("\n\r\tSupported Picture Formats: %s",
-           (pic_formats != NULL)? pic_formats : "NULL");
-    printf("\n\r\tSupported Preview Sizes: %s",
-           (preview_sizes != NULL)? preview_sizes : "NULL");
-    printf("\n\r\tSupported Video Sizes: %s",
-            (video_sizes != NULL)? video_sizes : "NULL");
-    printf("\n\r\tSupported Preview Formats: %s",
-           (preview_formats != NULL)? preview_formats : "NULL");
-    printf("\n\r\tSupported Preview Frame Rates: %s",
-           (frame_rates != NULL)? frame_rates : "NULL");
-    printf("\n\r\tSupported Thumbnail Sizes: %s",
-           (thumb_sizes != NULL)? thumb_sizes : "NULL");
-    printf("\n\r\tSupported Whitebalance Modes: %s",
-           (wb_modes != NULL)? wb_modes : "NULL");
-    printf("\n\r\tSupported Effects: %s",
-           (effects != NULL)? effects : "NULL");
-    printf("\n\r\tSupported Scene Modes: %s",
-           (scene_modes != NULL)? scene_modes : "NULL");
-    printf("\n\r\tSupported Focus Modes: %s",
-           (focus_modes != NULL)? focus_modes : "NULL");
-    printf("\n\r\tSupported Antibanding Options: %s",
-           (antibanding_modes != NULL)? antibanding_modes : "NULL");
-    printf("\n\r\tSupported Flash Modes: %s",
-           (flash_modes != NULL)? flash_modes : "NULL");
-    printf("\n\r\tSupported Focus Areas: %d", focus_areas);
-    printf("\n\r\tSupported FPS ranges : %s",
-           (fps_ranges != NULL)? fps_ranges : "NULL");
-    printf("\n\r\tFocus Distances: %s \n",
-           (focus_distances != NULL)? focus_distances : "NULL");
-}
-
-/*===========================================================================
- * FUNCTION   : createPreviewSurface
- *
- * DESCRIPTION: helper function for creating preview surfaces
- *
- * PARAMETERS :
- *   @width : preview width
- *   @height: preview height
- *   @pixFormat : surface pixelformat
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::createPreviewSurface(int width, int height, int32_t pixFormat)
-{
-    int ret = NO_ERROR;
-    DisplayInfo dinfo;
-    sp<IBinder> display(SurfaceComposerClient::getBuiltInDisplay(
-                        ISurfaceComposer::eDisplayIdMain));
-    SurfaceComposerClient::getDisplayInfo(display, &dinfo);
-    uint32_t previewWidth, previewHeight;
-
-    if ((0 >= width) || (0 >= height)) {
-        printf("Bad preview surface size %dx%d\n", width, height);
-        return BAD_VALUE;
-    }
-
-    if ((int)dinfo.w < width) {
-        previewWidth = dinfo.w;
-    } else {
-        previewWidth = (unsigned int)width;
-    }
-
-    if ((int)dinfo.h < height) {
-        previewHeight = dinfo.h;
-    } else {
-        previewHeight = (unsigned int)height;
-    }
-
-    mClient = new SurfaceComposerClient();
-
-    if ( NULL == mClient.get() ) {
-        printf("Unable to establish connection to Surface Composer \n");
-        return NO_INIT;
-    }
-
-    mSurfaceControl = mClient->createSurface(String8("QCamera_Test"),
-                                             previewWidth,
-                                             previewHeight,
-                                             pixFormat,
-                                             0);
-    if ( NULL == mSurfaceControl.get() ) {
-        printf("Unable to create preview surface \n");
-        return NO_INIT;
-    }
-
-    mPreviewSurface = mSurfaceControl->getSurface();
-    if ( NULL != mPreviewSurface.get() ) {
-        mClient->openGlobalTransaction();
-        ret |= mSurfaceControl->setLayer(0x7fffffff);
-        if ( mCameraIndex == 0 )
-            ret |= mSurfaceControl->setPosition(0, 0);
-        else
-            ret |= mSurfaceControl->setPosition((float)(dinfo.w - previewWidth),
-                    (float)(dinfo.h - previewHeight));
-
-        ret |= mSurfaceControl->setSize(previewWidth, previewHeight);
-        ret |= mSurfaceControl->show();
-        mClient->closeGlobalTransaction();
-
-        if ( NO_ERROR != ret ) {
-            printf("Preview surface configuration failed! \n");
-        }
-    } else {
-        ret = NO_INIT;
-    }
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : destroyPreviewSurface
- *
- * DESCRIPTION: closes previously open preview surface
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::destroyPreviewSurface()
-{
-    if ( NULL != mPreviewSurface.get() ) {
-        mPreviewSurface.clear();
-    }
-
-    if ( NULL != mSurfaceControl.get() ) {
-        mSurfaceControl->clear();
-        mSurfaceControl.clear();
-    }
-
-    if ( NULL != mClient.get() ) {
-        mClient->dispose();
-        mClient.clear();
-    }
-
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : CameraContext
- *
- * DESCRIPTION: camera context constructor
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-CameraContext::CameraContext(int cameraIndex) :
-    mCameraIndex(cameraIndex),
-    mResizePreview(true),
-    mHardwareActive(false),
-    mPreviewRunning(false),
-    mRecordRunning(false),
-    mVideoFd(-1),
-    mVideoIdx(0),
-    mRecordingHint(false),
-    mDoPrintMenu(true),
-    mPiPCapture(false),
-    mfmtMultiplier(1),
-    mSectionsRead(false),
-    mSectionsAllocated(0),
-    mSections(NULL),
-    mJEXIFTmp(NULL),
-    mHaveAll(false),
-    mCamera(NULL),
-    mClient(NULL),
-    mSurfaceControl(NULL),
-    mPreviewSurface(NULL),
-    mInUse(false)
-{
-    mRecorder = new MediaRecorder(String16("camera"));
-}
-
-/*===========================================================================
- * FUNCTION     : setTestCtxInstance
- *
- * DESCRIPTION  : Sends TestContext instance to CameraContext
- *
- * PARAMETERS   :
- *    @instance : TestContext instance
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::setTestCtxInstance(TestContext  *instance)
-{
-    mInterpr = instance;
-}
-
-/*===========================================================================
- * FUNCTION     : setTestCtxInst
- *
- * DESCRIPTION  : Sends TestContext instance to Interpreter
- *
- * PARAMETERS   :
- *    @instance : TestContext instance
- *
- * RETURN     : None
- *==========================================================================*/
-void Interpreter::setTestCtxInst(TestContext  *instance)
-{
-    mTestContext = instance;
-}
-
-/*===========================================================================
- * FUNCTION   : ~CameraContext
- *
- * DESCRIPTION: camera context destructor
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-CameraContext::~CameraContext()
-{
-    stopPreview();
-    closeCamera();
-}
-
-/*===========================================================================
- * FUNCTION   : openCamera
- *
- * DESCRIPTION: connects to and initializes camera
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t  CameraContext::openCamera()
-{
-    useLock();
-    const char *ZSLStr = NULL;
-    size_t ZSLStrSize = 0;
-
-    if ( NULL != mCamera.get() ) {
-        printf("Camera already open! \n");
-        signalFinished();
-        return NO_ERROR;
-    }
-
-    printf("openCamera(camera_index=%d)\n", mCameraIndex);
-
-#ifndef USE_JB_MR1
-
-    String16 packageName("CameraTest");
-
-    mCamera = Camera::connect(mCameraIndex,
-                              packageName,
-                              Camera::USE_CALLING_UID);
-
-#else
-
-    mCamera = Camera::connect(mCameraIndex);
-
-#endif
-
-    if ( NULL == mCamera.get() ) {
-        printf("Unable to connect to CameraService\n");
-        signalFinished();
-        return NO_INIT;
-    }
-
-    mParams = mCamera->getParameters();
-    mParams.getSupportedPreviewSizes(mSupportedPreviewSizes);
-    mParams.getSupportedPictureSizes(mSupportedPictureSizes);
-    mParams.getSupportedVideoSizes(mSupportedVideoSizes);
-
-    mCurrentPictureSizeIdx = mSupportedPictureSizes.size() / 2;
-    mCurrentPreviewSizeIdx = mSupportedPreviewSizes.size() / 2;
-    mCurrentVideoSizeIdx   = mSupportedVideoSizes.size() / 2;
-
-    mCamera->setListener(this);
-    mHardwareActive = true;
-
-    mInterpr->setViVSize((Size) mSupportedVideoSizes.itemAt(
-        mCurrentVideoSizeIdx),
-        mCameraIndex);
-
-    ZSLStr = mParams.get(CameraContext::KEY_ZSL);
-    if (NULL != ZSLStr) {
-        ZSLStrSize = strlen(ZSLStr);
-        if (!strncmp(ZSLStr, "on", ZSLStrSize)) {
-            mInterpr->mIsZSLOn = true;
-        } else if (!strncmp(ZSLStr, "off", ZSLStrSize)) {
-            mInterpr->mIsZSLOn = false;
-        } else {
-            printf("zsl value is not valid!\n");
-        }
-    } else {
-        printf("zsl is NULL\n");
-    }
-
-    signalFinished();
-
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : onAsBinder
- *
- * DESCRIPTION: onAsBinder
- *
- * PARAMETERS : None
- *
- * RETURN     : Pointer to IBinder
- *==========================================================================*/
-IBinder* CameraContext::onAsBinder() {
-    return NULL;
-}
-
-/*===========================================================================
- * FUNCTION   : getNumberOfCameras
- *
- * DESCRIPTION: returns the number of supported camera by the system
- *
- * PARAMETERS : None
- *
- * RETURN     : supported camera count
- *==========================================================================*/
-int CameraContext::getNumberOfCameras()
-{
-    int ret = -1;
-
-    if ( NULL != mCamera.get() ) {
-        ret = mCamera->getNumberOfCameras();
-    }
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : closeCamera
- *
- * DESCRIPTION: closes a previously the initialized camera reference
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::closeCamera()
-{
-    useLock();
-    if ( NULL == mCamera.get() ) {
-        return NO_INIT;
-    }
-
-    mCamera->disconnect();
-    mCamera.clear();
-
-    mRecorder->init();
-    mRecorder->close();
-    mRecorder->release();
-    mRecorder.clear();
-
-    mHardwareActive = false;
-    mPreviewRunning = false;
-    mRecordRunning = false;
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : startPreview
- *
- * DESCRIPTION: starts camera preview
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::startPreview()
-{
-    useLock();
-
-    int ret = NO_ERROR;
-    int previewWidth, previewHeight;
-    Size calculatedPreviewSize;
-    Size currentPreviewSize = mSupportedPreviewSizes.itemAt(
-        mCurrentPreviewSizeIdx);
-    Size currentPictureSize = mSupportedPictureSizes.itemAt(
-        mCurrentPictureSizeIdx);
-    Size currentVideoSize   = mSupportedVideoSizes.itemAt(
-        mCurrentVideoSizeIdx);
-
-#ifndef USE_JB_MR1
-
-    sp<IGraphicBufferProducer> gbp;
-
-#endif
-
-    if (!mHardwareActive ) {
-        printf("Camera not active! \n");
-        return NO_INIT;
-    }
-
-    if (mPreviewRunning) {
-        printf("Preview is already running! \n");
-        signalFinished();
-        return NO_ERROR;
-    }
-
-    if (mResizePreview) {
-        mPreviewRunning = false;
-
-        if ( mRecordingHint ) {
-            calculatedPreviewSize =
-                getPreviewSizeFromVideoSizes(currentVideoSize);
-            previewWidth = calculatedPreviewSize.width;
-            previewHeight = calculatedPreviewSize.height;
-        } else {
-            previewWidth = currentPreviewSize.width;
-            previewHeight = currentPreviewSize.height;
-        }
-
-        ret = createPreviewSurface(previewWidth,
-                                   previewHeight,
-                                   HAL_PIXEL_FORMAT_YCrCb_420_SP);
-        if (  NO_ERROR != ret ) {
-            printf("Error while creating preview surface\n");
-            return ret;
-        }
-
-        // set rdi mode if system prop is set for front camera
-        if (mCameraIndex == 1) {
-            char value[32];
-            property_get("persist.camera.rdimode", value, "0");
-            int rdimode = atoi(value);
-            printf("rdi mode = %d\n", rdimode);
-            if (rdimode == 1) {
-                mParams.set("rdi-mode", "enable");
-            } else {
-                mParams.set("rdi-mode", "disable");
-            }
-        } else {
-            mParams.set("rdi-mode", "disable");
-        }
-
-        //mParams.set("rdi-mode", "enable");
-        mParams.set("recording-hint", "true");
-        mParams.setPreviewSize(previewWidth, previewHeight);
-        mParams.setPictureSize(currentPictureSize.width,
-            currentPictureSize.height);
-        mParams.setVideoSize(
-            currentVideoSize.width, currentVideoSize.height);
-
-        ret |= mCamera->setParameters(mParams.flatten());
-
-#ifndef USE_JB_MR1
-
-        gbp = mPreviewSurface->getIGraphicBufferProducer();
-        ret |= mCamera->setPreviewTarget(gbp);
-
-#else
-
-        ret |= mCamera->setPreviewDisplay(mPreviewSurface);
-
-#endif
-        mResizePreview = false;
-    }
-
-    if ( !mPreviewRunning ) {
-        ret |= mCamera->startPreview();
-        if ( NO_ERROR != ret ) {
-            printf("Preview start failed! \n");
-            return ret;
-        }
-
-        mPreviewRunning = true;
-    }
-
-    signalFinished();
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : getPreviewSizeFromVideoSizes
- *
- * DESCRIPTION: Get the preview size from video size. Find all resolutions with
- *              the same aspect ratio and choose the same or the closest
- *              from them.
- *
- * PARAMETERS :
- *   @currentVideoSize: current video size
-
- *
- * RETURN     : PreviewSize
- *==========================================================================*/
-Size CameraContext::getPreviewSizeFromVideoSizes(Size currentVideoSize)
-{
-
-    Size tmpPreviewSize;
-    Size PreviewSize;
-    Size PreviewSizes[mSupportedPreviewSizes.size()];
-    double tolerance = 0.00001;
-    double videoRatio;
-    double previewRatio;
-    size_t i = 0;
-    size_t j = 0;
-    int delta;
-
-    // Find all the resolutions with the same aspect ratio and choose the
-    // same or the closest resolution from them. Choose the closest resolution
-    // in case same aspect ratio is not found
-    if (currentVideoSize.width * currentVideoSize.height > 0 &&
-            mSupportedPreviewSizes.size() > 0) {
-        videoRatio = (float)currentVideoSize.width /
-            (float)currentVideoSize.height;
-        for (i=0; i<mSupportedPreviewSizes.size(); i++) {
-            tmpPreviewSize = mSupportedPreviewSizes.itemAt(i);
-            previewRatio = (float)tmpPreviewSize.width /
-                (float)tmpPreviewSize.height;
-            if (fabs(videoRatio - previewRatio) < tolerance) {
-                PreviewSizes[j] = tmpPreviewSize;
-                j++;
-            }
-        }
-
-        if ( j > 0 ) {
-            delta = abs((currentVideoSize.width *currentVideoSize.height)-
-                (PreviewSizes[0].width * PreviewSizes[0].height));
-            PreviewSize = PreviewSizes[0];
-            for (i=0; i<j; i++) {
-                if(abs(currentVideoSize.width * currentVideoSize.height) -
-                    (PreviewSizes[i].width * PreviewSizes[i].height) <
-                    delta) {
-                    PreviewSize = PreviewSizes[i];
-                    delta = abs((currentVideoSize.width *
-                        currentVideoSize.height) -
-                        (PreviewSizes[i].width * PreviewSizes[i].height));
-                }
-            }
-        } else {
-            // Choose the closest resolution in case same aspect ratio is
-            // not found
-            tmpPreviewSize = mSupportedPreviewSizes.itemAt(j);
-            PreviewSize = tmpPreviewSize;
-            delta = abs(
-                    (currentVideoSize.width * currentVideoSize.height)-
-                    (tmpPreviewSize.width * tmpPreviewSize.height));
-            for (i=0; i<mSupportedPreviewSizes.size(); i++) {
-                tmpPreviewSize = mSupportedPreviewSizes.itemAt(i);
-                if(abs(
-                        (currentVideoSize.width * currentVideoSize.height)-
-                        (tmpPreviewSize.width * tmpPreviewSize.height)) <
-                        delta) {
-                    PreviewSize = tmpPreviewSize;
-                    delta = abs(
-                            (currentVideoSize.width * currentVideoSize.height)-
-                            (tmpPreviewSize.width * tmpPreviewSize.height));
-                }
-            }
-        }
-    } else {
-        memset(&PreviewSize, 0, sizeof(PreviewSize));
-    }
-    return PreviewSize;
-}
-
-/*===========================================================================
- * FUNCTION   : autoFocus
- *
- * DESCRIPTION: Triggers autofocus
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::autoFocus()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    if ( mPreviewRunning ) {
-        ret = mCamera->autoFocus();
-    }
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : enablePreviewCallbacks
- *
- * DESCRIPTION: Enables preview callback messages
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::enablePreviewCallbacks()
-{
-    useLock();
-    if ( mHardwareActive ) {
-        mCamera->setPreviewCallbackFlags(
-            CAMERA_FRAME_CALLBACK_FLAG_ENABLE_MASK);
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : takePicture
- *
- * DESCRIPTION: triggers image capture
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::takePicture()
-{
-    status_t ret = NO_ERROR;
-    useLock();
-    if ( mPreviewRunning ) {
-        ret = mCamera->takePicture(
-            CAMERA_MSG_COMPRESSED_IMAGE|
-            CAMERA_MSG_RAW_IMAGE);
-        if (!mRecordingHint && !mInterpr->mIsZSLOn) {
-            mPreviewRunning = false;
-        }
-    } else {
-        printf("Please resume/start the preview before taking a picture!\n");
-    }
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : configureRecorder
- *
- * DESCRIPTION: Configure video recorder
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::configureRecorder()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    mResizePreview = true;
-    mParams.set("recording-hint", "true");
-    mRecordingHint = true;
-    mCamera->setParameters(mParams.flatten());
-
-    Size videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
-    ret = mRecorder->setParameters(
-        String8("video-param-encoding-bitrate=64000"));
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not configure recorder (%d)", ret);
-        return ret;
-    }
-
-    ret = mRecorder->setCamera(
-        mCamera->remote(), mCamera->getRecordingProxy());
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set camera (%d)", ret);
-        return ret;
-    }
-    ret = mRecorder->setVideoSource(VIDEO_SOURCE_CAMERA);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set video soruce (%d)", ret);
-        return ret;
-    }
-    ret = mRecorder->setAudioSource(AUDIO_SOURCE_DEFAULT);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set audio source (%d)", ret);
-        return ret;
-    }
-    ret = mRecorder->setOutputFormat(OUTPUT_FORMAT_DEFAULT);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set output format (%d)", ret);
-        return ret;
-    }
-
-    ret = mRecorder->setVideoEncoder(VIDEO_ENCODER_DEFAULT);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set video encoder (%d)", ret);
-        return ret;
-    }
-
-    char fileName[100];
-
-    snprintf(fileName, sizeof(fileName) / sizeof(char),
-            "/sdcard/vid_cam%d_%dx%d_%d.mpeg", mCameraIndex,
-            videoSize.width, videoSize.height, mVideoIdx++);
-
-    if ( mVideoFd < 0 ) {
-        mVideoFd = open(fileName, O_CREAT | O_RDWR );
-    }
-
-    if ( mVideoFd < 0 ) {
-        LOGE("Could not open video file for writing %s!", fileName);
-        return UNKNOWN_ERROR;
-    }
-
-    ret = mRecorder->setOutputFile(mVideoFd, 0, 0);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set output file (%d)", ret);
-        return ret;
-    }
-
-    ret = mRecorder->setVideoSize(videoSize.width, videoSize.height);
-    if ( ret  != NO_ERROR ) {
-        LOGE("Could not set video size %dx%d", videoSize.width,
-            videoSize.height);
-        return ret;
-    }
-
-    ret = mRecorder->setVideoFrameRate(30);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set video frame rate (%d)", ret);
-        return ret;
-    }
-
-    ret = mRecorder->setAudioEncoder(AUDIO_ENCODER_DEFAULT);
-    if ( ret != NO_ERROR ) {
-        LOGE("Could not set audio encoder (%d)", ret);
-        return ret;
-    }
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : unconfigureViVRecording
- *
- * DESCRIPTION: Unconfigures video in video recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::unconfigureRecorder()
-{
-    useLock();
-
-    if ( !mRecordRunning ) {
-        mResizePreview = true;
-        mParams.set("recording-hint", "false");
-        mRecordingHint = false;
-        mCamera->setParameters(mParams.flatten());
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : configureViVRecording
- *
- * DESCRIPTION: Configures video in video recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::configureViVRecording()
-{
-    status_t ret = NO_ERROR;
-
-    mResizePreview = true;
-    mParams.set("recording-hint", "true");
-    mRecordingHint = true;
-    mCamera->setParameters(mParams.flatten());
-    mCamera->setRecordingProxyListener(this);
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : startRecording
- *
- * DESCRIPTION: triggers start recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::startRecording()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-
-    if ( mPreviewRunning ) {
-
-        mCamera->unlock();
-
-        ret = mRecorder->prepare();
-        if ( ret != NO_ERROR ) {
-            LOGE("Could not prepare recorder");
-            return ret;
-        }
-
-        ret = mRecorder->start();
-        if ( ret != NO_ERROR ) {
-            LOGE("Could not start recorder");
-            return ret;
-        }
-
-        mRecordRunning = true;
-    }
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : stopRecording
- *
- * DESCRIPTION: triggers start recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::stopRecording()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    if ( mRecordRunning ) {
-            mRecorder->stop();
-            close(mVideoFd);
-            mVideoFd = -1;
-
-        mRecordRunning = false;
-    }
-
-    signalFinished();
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : startViVRecording
- *
- * DESCRIPTION: Starts video in video recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::startViVRecording()
-{
-    useLock();
-    status_t ret;
-
-    if (mInterpr->mViVVid.VideoSizes[0].width *
-            mInterpr->mViVVid.VideoSizes[0].height >=
-            mInterpr->mViVVid.VideoSizes[1].width *
-            mInterpr->mViVVid.VideoSizes[1].height) {
-        mInterpr->mViVBuff.buffSize = calcBufferSize(
-            mInterpr->mViVVid.VideoSizes[1].width,
-            mInterpr->mViVVid.VideoSizes[1].height);
-        if (mInterpr->mViVBuff.buff == NULL) {
-            mInterpr->mViVBuff.buff =
-                (void *)malloc(mInterpr->mViVBuff.buffSize);
-        }
-        mInterpr->mViVVid.sourceCameraID = 1;
-        mInterpr->mViVVid.destinationCameraID = 0;
-
-    } else {
-        mInterpr->mViVBuff.buffSize = calcBufferSize(
-            mInterpr->mViVVid.VideoSizes[0].width,
-            mInterpr->mViVVid.VideoSizes[0].height);
-        if (mInterpr->mViVBuff.buff == NULL) {
-            mInterpr->mViVBuff.buff =
-                (void *)malloc(mInterpr->mViVBuff.buffSize);
-        }
-        mInterpr->mViVVid.sourceCameraID = 0;
-        mInterpr->mViVVid.destinationCameraID = 1;
-    }
-
-    ret = mCamera->startRecording();
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : stopViVRecording
- *
- * DESCRIPTION: Stops video in video recording
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::stopViVRecording()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    mCamera->stopRecording();
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : stopPreview
- *
- * DESCRIPTION: stops camera preview
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::stopPreview()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    if ( mHardwareActive ) {
-        mCamera->stopPreview();
-        ret = destroyPreviewSurface();
-    }
-
-    mPreviewRunning  = false;
-    mResizePreview = true;
-
-    signalFinished();
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : resumePreview
- *
- * DESCRIPTION: resumes camera preview after image capture
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::resumePreview()
-{
-    useLock();
-    status_t ret = NO_ERROR;
-
-    if ( mHardwareActive ) {
-        ret = mCamera->startPreview();
-        mPreviewRunning = true;
-    } else {
-        ret = NO_INIT;
-    }
-
-    signalFinished();
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : nextPreviewSize
- *
- * DESCRIPTION: Iterates through all supported preview sizes.
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::nextPreviewSize()
-{
-    useLock();
-    if ( mHardwareActive ) {
-        mCurrentPreviewSizeIdx += 1;
-        mCurrentPreviewSizeIdx %= mSupportedPreviewSizes.size();
-        Size previewSize = mSupportedPreviewSizes.itemAt(
-            mCurrentPreviewSizeIdx);
-        mParams.setPreviewSize(previewSize.width,
-                               previewSize.height);
-        mResizePreview = true;
-
-        if ( mPreviewRunning ) {
-            mCamera->stopPreview();
-            mCamera->setParameters(mParams.flatten());
-            mCamera->startPreview();
-        } else {
-            mCamera->setParameters(mParams.flatten());
-        }
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-
-/*===========================================================================
- * FUNCTION   : setPreviewSize
- *
- * DESCRIPTION: Sets exact preview size if supported
- *
- * PARAMETERS : format size in the form of WIDTHxHEIGHT
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::setPreviewSize(const char *format)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        int newHeight;
-        int newWidth;
-        sscanf(format, "%dx%d", &newWidth, &newHeight);
-
-        unsigned int i;
-        for (i = 0; i < mSupportedPreviewSizes.size(); ++i) {
-            Size previewSize = mSupportedPreviewSizes.itemAt(i);
-            if ( newWidth == previewSize.width &&
-                 newHeight == previewSize.height )
-            {
-                break;
-            }
-
-        }
-        if ( i == mSupportedPreviewSizes.size())
-        {
-            printf("Preview size %dx%d not supported !\n",
-                newWidth, newHeight);
-            return INVALID_OPERATION;
-        }
-
-        mParams.setPreviewSize(newWidth,
-                               newHeight);
-        mResizePreview = true;
-
-        if ( mPreviewRunning ) {
-            mCamera->stopPreview();
-            mCamera->setParameters(mParams.flatten());
-            mCamera->startPreview();
-        } else {
-            mCamera->setParameters(mParams.flatten());
-        }
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : getCurrentPreviewSize
- *
- * DESCRIPTION: queries the currently configured preview size
- *
- * PARAMETERS :
- *  @previewSize : preview size currently configured
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::getCurrentPreviewSize(Size &previewSize)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        previewSize = mSupportedPreviewSizes.itemAt(mCurrentPreviewSizeIdx);
-    }
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : nextPictureSize
- *
- * DESCRIPTION: Iterates through all supported picture sizes.
- *
- * PARAMETERS : None
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::nextPictureSize()
-{
-    useLock();
-    if ( mHardwareActive ) {
-        mCurrentPictureSizeIdx += 1;
-        mCurrentPictureSizeIdx %= mSupportedPictureSizes.size();
-        Size pictureSize = mSupportedPictureSizes.itemAt(
-            mCurrentPictureSizeIdx);
-        mParams.setPictureSize(pictureSize.width,
-            pictureSize.height);
-        mCamera->setParameters(mParams.flatten());
-    }
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : setPictureSize
- *
- * DESCRIPTION: Sets exact preview size if supported
- *
- * PARAMETERS : format size in the form of WIDTHxHEIGHT
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::setPictureSize(const char *format)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        int newHeight;
-        int newWidth;
-        sscanf(format, "%dx%d", &newWidth, &newHeight);
-
-        unsigned int i;
-        for (i = 0; i < mSupportedPictureSizes.size(); ++i) {
-            Size PictureSize = mSupportedPictureSizes.itemAt(i);
-            if ( newWidth == PictureSize.width &&
-                 newHeight == PictureSize.height )
-            {
-                break;
-            }
-
-        }
-        if ( i == mSupportedPictureSizes.size())
-        {
-            printf("Preview size %dx%d not supported !\n",
-                newWidth, newHeight);
-            return INVALID_OPERATION;
-        }
-
-        mParams.setPictureSize(newWidth,
-                               newHeight);
-        mCamera->setParameters(mParams.flatten());
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : nextVideoSize
- *
- * DESCRIPTION: Select the next available video size
- *
- * PARAMETERS : none
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::nextVideoSize()
-{
-    useLock();
-    if ( mHardwareActive ) {
-        mCurrentVideoSizeIdx += 1;
-        mCurrentVideoSizeIdx %= mSupportedVideoSizes.size();
-        Size videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
-        mParams.setVideoSize(videoSize.width,
-                             videoSize.height);
-        mCamera->setParameters(mParams.flatten());
-        mInterpr->setViVSize((Size) mSupportedVideoSizes.itemAt(
-            mCurrentVideoSizeIdx), mCameraIndex);
-    }
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : setVideoSize
- *
- * DESCRIPTION: Set video size
- *
- * PARAMETERS :
- *   @format  : format
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::setVideoSize(const char *format)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        int newHeight;
-        int newWidth;
-        sscanf(format, "%dx%d", &newWidth, &newHeight);
-
-        unsigned int i;
-        for (i = 0; i < mSupportedVideoSizes.size(); ++i) {
-            Size PictureSize = mSupportedVideoSizes.itemAt(i);
-            if ( newWidth == PictureSize.width &&
-                 newHeight == PictureSize.height )
-            {
-                break;
-            }
-
-        }
-        if ( i == mSupportedVideoSizes.size())
-        {
-            printf("Preview size %dx%d not supported !\n",
-                newWidth, newHeight);
-            return INVALID_OPERATION;
-        }
-
-        mParams.setVideoSize(newWidth,
-                             newHeight);
-        mCamera->setParameters(mParams.flatten());
-    }
-
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION    : getCurrentVideoSize
- *
- * DESCRIPTION : Get current video size
- *
- * PARAMETERS  :
- *   @videoSize: video Size
- *
- * RETURN      : status_t type of status
- *               NO_ERROR  -- success
- *               none-zero failure code
- *==========================================================================*/
-status_t CameraContext::getCurrentVideoSize(Size &videoSize)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        videoSize = mSupportedVideoSizes.itemAt(mCurrentVideoSizeIdx);
-    }
-    signalFinished();
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : getCurrentPictureSize
- *
- * DESCRIPTION: queries the currently configured picture size
- *
- * PARAMETERS :
- *  @pictureSize : picture size currently configured
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t CameraContext::getCurrentPictureSize(Size &pictureSize)
-{
-    useLock();
-    if ( mHardwareActive ) {
-        pictureSize = mSupportedPictureSizes.itemAt(mCurrentPictureSizeIdx);
-    }
-    signalFinished();
-    return NO_ERROR;
-}
-
-}; //namespace qcamera ends here
-
-using namespace qcamera;
-
-/*===========================================================================
- * FUNCTION   : printMenu
- *
- * DESCRIPTION: prints the available camera options
- *
- * PARAMETERS :
- *  @currentCamera : camera context currently being used
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::printMenu(sp<CameraContext> currentCamera)
-{
-    if ( !mDoPrintMenu ) return;
-    Size currentPictureSize, currentPreviewSize, currentVideoSize;
-    const char *zsl_mode = mParams.get(CameraContext::KEY_ZSL);
-
-    assert(currentCamera.get());
-
-    currentCamera->getCurrentPictureSize(currentPictureSize);
-    currentCamera->getCurrentPreviewSize(currentPreviewSize);
-    currentCamera->getCurrentVideoSize(currentVideoSize);
-
-    printf("\n\n=========== FUNCTIONAL TEST MENU ===================\n\n");
-
-    printf(" \n\nSTART / STOP / GENERAL SERVICES \n");
-    printf(" -----------------------------\n");
-    printf("   %c. Switch camera - Current Index: %d\n",
-            Interpreter::SWITCH_CAMERA_CMD,
-            currentCamera->getCameraIndex());
-    printf("   %c. Resume Preview after capture \n",
-            Interpreter::RESUME_PREVIEW_CMD);
-    printf("   %c. Quit \n",
-            Interpreter::EXIT_CMD);
-    printf("   %c. Camera Capability Dump",
-            Interpreter::DUMP_CAPS_CMD);
-
-    printf(" \n\n PREVIEW SUB MENU \n");
-    printf(" -----------------------------\n");
-    printf("   %c. Start Preview\n",
-            Interpreter::START_PREVIEW_CMD);
-    printf("   %c. Stop Preview\n",
-            Interpreter::STOP_PREVIEW_CMD);
-    printf("   %c. Preview size:  %dx%d\n",
-            Interpreter::CHANGE_PREVIEW_SIZE_CMD,
-            currentPreviewSize.width,
-            currentPreviewSize.height);
-    printf("   %c. Video size:  %dx%d\n",
-            Interpreter::CHANGE_VIDEO_SIZE_CMD,
-            currentVideoSize.width,
-            currentVideoSize.height);
-    printf("   %c. Start Recording\n",
-            Interpreter::START_RECORD_CMD);
-    printf("   %c. Stop Recording\n",
-            Interpreter::STOP_RECORD_CMD);
-    printf("   %c. Start ViV Recording\n",
-            Interpreter::START_VIV_RECORD_CMD);
-    printf("   %c. Stop ViV Recording\n",
-            Interpreter::STOP_VIV_RECORD_CMD);
-    printf("   %c. Enable preview frames\n",
-            Interpreter::ENABLE_PRV_CALLBACKS_CMD);
-    printf("   %c. Trigger autofocus \n",
-            Interpreter::AUTOFOCUS_CMD);
-
-    printf(" \n\n IMAGE CAPTURE SUB MENU \n");
-    printf(" -----------------------------\n");
-    printf("   %c. Take picture/Full Press\n",
-            Interpreter::TAKEPICTURE_CMD);
-    printf("   %c. Take picture in picture\n",
-            Interpreter::TAKEPICTURE_IN_PICTURE_CMD);
-    printf("   %c. Picture size:  %dx%d\n",
-            Interpreter::CHANGE_PICTURE_SIZE_CMD,
-            currentPictureSize.width,
-            currentPictureSize.height);
-    printf("   %c. zsl:  %s\n", Interpreter::ZSL_CMD,
-        (zsl_mode != NULL) ? zsl_mode : "NULL");
-
-    printf("\n   Choice: ");
-}
-
-/*===========================================================================
- * FUNCTION   : enablePrintPreview
- *
- * DESCRIPTION: Enables printing the preview
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::enablePrintPreview()
-{
-    mDoPrintMenu = true;
-}
-
-/*===========================================================================
- * FUNCTION   : disablePrintPreview
- *
- * DESCRIPTION: Disables printing the preview
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::disablePrintPreview()
-{
-    mDoPrintMenu = false;
-}
-
-/*===========================================================================
- * FUNCTION   : enablePiPCapture
- *
- * DESCRIPTION: Enables picture in picture capture
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::enablePiPCapture()
-{
-    mPiPCapture = true;
-}
-
-/*===========================================================================
- * FUNCTION   : disablePiPCapture
- *
- * DESCRIPTION: Disables picture in picture capture
- *
- * PARAMETERS : None
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::disablePiPCapture()
-{
-    mPiPCapture = false;
-}
-
-/*===========================================================================
- * FUNCTION   : getZSL
- *
- * DESCRIPTION: get ZSL value of current camera
- *
- * PARAMETERS : None
- *
- * RETURN     : current zsl value
- *==========================================================================*/
-const char *CameraContext::getZSL()
-{
-    return mParams.get(CameraContext::KEY_ZSL);
-}
-
-/*===========================================================================
- * FUNCTION   : setZSL
- *
- * DESCRIPTION: set ZSL value of current camera
- *
- * PARAMETERS : zsl value to be set
- *
- * RETURN     : None
- *==========================================================================*/
-void CameraContext::setZSL(const char *value)
-{
-    mParams.set(CameraContext::KEY_ZSL, value);
-    mCamera->setParameters(mParams.flatten());
-}
-
-/*===========================================================================
- * FUNCTION   : configureViVCodec
- *
- * DESCRIPTION: Configures video in video codec
- *
- * PARAMETERS : none
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t Interpreter::configureViVCodec()
-{
-    status_t ret = NO_ERROR;
-    char fileName[100];
-    sp<AMessage> format = new AMessage;
-    sp<ALooper> looper = new ALooper;
-
-    if (mTestContext->mViVVid.VideoSizes[0].width *
-            mTestContext->mViVVid.VideoSizes[0].height >=
-            mTestContext->mViVVid.VideoSizes[1].width *
-            mTestContext->mViVVid.VideoSizes[1].height) {
-        snprintf(fileName, sizeof(fileName) / sizeof(char), "/sdcard/ViV_vid_%dx%d_%d.mp4",
-            mTestContext->mViVVid.VideoSizes[0].width,
-            mTestContext->mViVVid.VideoSizes[0].height,
-            mTestContext->mViVVid.ViVIdx++);
-        format->setInt32("width", mTestContext->mViVVid.VideoSizes[0].width);
-        format->setInt32("height", mTestContext->mViVVid.VideoSizes[0].height);
-    } else {
-        snprintf(fileName, sizeof(fileName) / sizeof(char), "/sdcard/ViV_vid_%dx%d_%d.mp4",
-            mTestContext->mViVVid.VideoSizes[1].width,
-            mTestContext->mViVVid.VideoSizes[1].height,
-            mTestContext->mViVVid.ViVIdx++);
-        format->setInt32("width", mTestContext->mViVVid.VideoSizes[1].width);
-        format->setInt32("height", mTestContext->mViVVid.VideoSizes[1].height);
-    }
-    int fd = open(fileName, O_CREAT | O_RDWR );
-    if (fd < 0) {
-        LOGE("Error opening file");
-        return UNKNOWN_ERROR;
-    }
-    mTestContext->mViVVid.muxer = new MediaMuxer(
-        fd, MediaMuxer::OUTPUT_FORMAT_MPEG_4);
-
-    format->setString("mime", "video/avc");
-    format->setInt32("color-format", OMX_COLOR_FormatAndroidOpaque);
-
-    format->setInt32("bitrate", 1000000);
-    format->setFloat("frame-rate", 30);
-    format->setInt32("i-frame-interval", 10);
-
-    looper->setName("ViV_recording_looper");
-    looper->start();
-    ALOGV("Creating codec");
-    mTestContext->mViVVid.codec = MediaCodec::CreateByType(
-        looper, "video/avc", true);
-    if (mTestContext->mViVVid.codec == NULL) {
-        fprintf(stderr, "ERROR: unable to create video/avc codec instance\n");
-        return UNKNOWN_ERROR;
-    }
-    ret = mTestContext->mViVVid.codec->configure(format, NULL, NULL,
-            MediaCodec::CONFIGURE_FLAG_ENCODE);
-    if (ret != NO_ERROR) {
-        mTestContext->mViVVid.codec->release();
-        mTestContext->mViVVid.codec.clear();
-
-        fprintf(stderr, "ERROR: unable to configure codec (err=%d)\n", ret);
-        return ret;
-    }
-
-    ALOGV("Creating buffer producer");
-    ret = mTestContext->mViVVid.codec->createInputSurface(
-        &mTestContext->mViVVid.bufferProducer);
-    if (ret != NO_ERROR) {
-        mTestContext->mViVVid.codec->release();
-        mTestContext->mViVVid.codec.clear();
-
-        fprintf(stderr,
-            "ERROR: unable to create encoder input surface (err=%d)\n", ret);
-        return ret;
-    }
-
-    ret = mTestContext->mViVVid.codec->start();
-    if (ret != NO_ERROR) {
-        mTestContext->mViVVid.codec->release();
-        mTestContext->mViVVid.codec.clear();
-
-        fprintf(stderr, "ERROR: unable to start codec (err=%d)\n", ret);
-        return ret;
-    }
-    ALOGV("Codec prepared");
-
-    mTestContext->mViVVid.surface = new Surface(
-        mTestContext->mViVVid.bufferProducer);
-    mTestContext->mViVVid.ANW = mTestContext->mViVVid.surface;
-    ret = native_window_api_connect(mTestContext->mViVVid.ANW.get(),
-        NATIVE_WINDOW_API_CPU);
-    if (mTestContext->mViVVid.VideoSizes[0].width *
-        mTestContext->mViVVid.VideoSizes[0].height >=
-        mTestContext->mViVVid.VideoSizes[1].width *
-        mTestContext->mViVVid.VideoSizes[1].height) {
-        native_window_set_buffers_format(mTestContext->mViVVid.ANW.get(),
-                HAL_PIXEL_FORMAT_NV12_ENCODEABLE);
-        native_window_set_buffers_dimensions(mTestContext->mViVVid.ANW.get(),
-                mTestContext->mViVVid.VideoSizes[0].width,
-                mTestContext->mViVVid.VideoSizes[0].height);
-    } else {
-        native_window_set_buffers_format(mTestContext->mViVVid.ANW.get(),
-                HAL_PIXEL_FORMAT_NV12_ENCODEABLE);
-        native_window_set_buffers_dimensions(mTestContext->mViVVid.ANW.get(),
-                mTestContext->mViVVid.VideoSizes[1].width,
-                mTestContext->mViVVid.VideoSizes[1].height);
-    }
-    native_window_set_usage(mTestContext->mViVVid.ANW.get(),
-        GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
-    native_window_set_buffer_count(mTestContext->mViVVid.ANW.get(),
-        mTestContext->mViVVid.buff_cnt);
-
-    ViVEncoderThread();
-
-    return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : unconfigureViVCodec
- *
- * DESCRIPTION: Unconfigures video in video codec
- *
- * PARAMETERS : none
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- success
- *              none-zero failure code
- *==========================================================================*/
-status_t Interpreter::unconfigureViVCodec()
-{
-    status_t ret = NO_ERROR;
-
-    ret = native_window_api_disconnect(mTestContext->mViVVid.ANW.get(),
-        NATIVE_WINDOW_API_CPU);
-    mTestContext->mViVVid.bufferProducer = NULL;
-    mTestContext->mViVVid.codec->stop();
-    pthread_join(mViVEncThread, NULL);
-    mTestContext->mViVVid.muxer->stop();
-    mTestContext->mViVVid.codec->release();
-    mTestContext->mViVVid.codec.clear();
-    mTestContext->mViVVid.muxer.clear();
-    mTestContext->mViVVid.surface.clear();
-  return ret;
-}
-
-/*===========================================================================
- * FUNCTION   : Interpreter
- *
- * DESCRIPTION: Interpreter constructor
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-Interpreter::Interpreter(const char *file)
-    : mCmdIndex(0)
-    , mScript(NULL)
-{
-    if (!file){
-        printf("no File Given\n");
-        mUseScript = false;
-        return;
-    }
-
-    FILE *fh = fopen(file, "r");
-    if ( !fh ) {
-        printf("Could not open file %s\n", file);
-        mUseScript = false;
-        return;
-    }
-
-    fseek(fh, 0, SEEK_END);
-    size_t len = (size_t)ftell(fh);
-    rewind(fh);
-
-    if( !len ) {
-        printf("Script file %s is empty !\n", file);
-        fclose(fh);
-        return;
-    }
-
-    mScript = new char[len + 1];
-    if ( !mScript ) {
-        fclose(fh);
-        return;
-    }
-
-    fread(mScript, sizeof(char), len, fh);
-    mScript[len] = '\0'; // ensure null terminated;
-    fclose(fh);
-
-
-    char *p1;
-    char *p2;
-    p1 = p2 = mScript;
-
-    do {
-        switch (*p1) {
-        case '\0':
-        case '|':
-            p1++;
-            break;
-        case SWITCH_CAMERA_CMD:
-        case RESUME_PREVIEW_CMD:
-        case START_PREVIEW_CMD:
-        case STOP_PREVIEW_CMD:
-        case CHANGE_PREVIEW_SIZE_CMD:
-        case CHANGE_PICTURE_SIZE_CMD:
-        case START_RECORD_CMD:
-        case STOP_RECORD_CMD:
-        case START_VIV_RECORD_CMD:
-        case STOP_VIV_RECORD_CMD:
-        case DUMP_CAPS_CMD:
-        case AUTOFOCUS_CMD:
-        case TAKEPICTURE_CMD:
-        case TAKEPICTURE_IN_PICTURE_CMD:
-        case ENABLE_PRV_CALLBACKS_CMD:
-        case EXIT_CMD:
-        case ZSL_CMD:
-        case DELAY:
-            p2 = p1;
-            while( (p2 != (mScript + len)) && (*p2 != '|')) {
-                p2++;
-            }
-            *p2 = '\0';
-            if (p2 == (p1 + 1))
-                mCommands.push_back(Command(
-                    static_cast<Interpreter::Commands_e>(*p1)));
-            else
-                mCommands.push_back(Command(
-                    static_cast<Interpreter::Commands_e>(*p1), (p1 + 1)));
-            p1 = p2;
-            break;
-        default:
-            printf("Invalid cmd %c \n", *p1);
-            do {
-                p1++;
-
-            } while(*p1 != '|' && p1 != (mScript + len));
-
-        }
-    } while(p1 != (mScript + len));
-    mUseScript = true;
-}
-
-/*===========================================================================
- * FUNCTION   : ~Interpreter
- *
- * DESCRIPTION: Interpreter destructor
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-Interpreter::~Interpreter()
-{
-    if ( mScript )
-        delete[] mScript;
-
-    mCommands.clear();
-}
-
-/*===========================================================================
- * FUNCTION        : getCommand
- *
- * DESCRIPTION     : Get a command from interpreter
- *
- * PARAMETERS      :
- *   @currentCamera: Current camera context
- *
- * RETURN          : command
- *==========================================================================*/
-Interpreter::Command Interpreter::getCommand(
-    sp<CameraContext> currentCamera)
-{
-    if( mUseScript ) {
-        return mCommands[mCmdIndex++];
-    } else {
-        currentCamera->printMenu(currentCamera);
-        return Interpreter::Command(
-            static_cast<Interpreter::Commands_e>(getchar()));
-    }
-}
-
-/*===========================================================================
- * FUNCTION        : TestContext
- *
- * DESCRIPTION     : TestContext constructor
- *
- * PARAMETERS      : None
- *
- * RETURN          : None
- *==========================================================================*/
-TestContext::TestContext()
-{
-    int i = 0;
-    mTestRunning = false;
-    mInterpreter = NULL;
-    mViVVid.ViVIdx = 0;
-    mViVVid.buff_cnt = 9;
-    mViVVid.graphBuf = 0;
-    mViVVid.mappedBuff = NULL;
-    mViVVid.isBuffValid = false;
-    mViVVid.sourceCameraID = -1;
-    mViVVid.destinationCameraID = -1;
-    mPiPinUse = false;
-    mViVinUse = false;
-    mIsZSLOn = false;
-    memset(&mViVBuff, 0, sizeof(ViVBuff_t));
-
-    ProcessState::self()->startThreadPool();
-
-    do {
-        camera[i] = new CameraContext(i);
-        if ( NULL == camera[i].get() ) {
-            break;
-        }
-        camera[i]->setTestCtxInstance(this);
-
-        //by default open only back camera
-        if (i==0) {
-            status_t stat = camera[i]->openCamera();
-            if ( NO_ERROR != stat ) {
-                printf("Error encountered Openging camera id : %d\n", i);
-                break;
-            }
-        }
-        mAvailableCameras.add(camera[i]);
-        i++;
-    } while ( i < camera[0]->getNumberOfCameras() ) ;
-
-    if (i < camera[0]->getNumberOfCameras() ) {
-        for (size_t j = 0; j < mAvailableCameras.size(); j++) {
-            camera[j] = mAvailableCameras.itemAt(j);
-            camera[j]->closeCamera();
-            camera[j].clear();
-        }
-
-        mAvailableCameras.clear();
-    }
-}
-
-/*===========================================================================
- * FUNCTION        : ~TestContext
- *
- * DESCRIPTION     : TestContext destructor
- *
- * PARAMETERS      : None
- *
- * RETURN          : None
- *==========================================================================*/
-TestContext::~TestContext()
-{
-    delete mInterpreter;
-
-    for (size_t j = 0; j < mAvailableCameras.size(); j++) {
-        camera[j] = mAvailableCameras.itemAt(j);
-        camera[j]->closeCamera();
-        camera[j].clear();
-    }
-
-    mAvailableCameras.clear();
-}
-
-/*===========================================================================
- * FUNCTION        : GetCamerasNum
- *
- * DESCRIPTION     : Get the number of available cameras
- *
- * PARAMETERS      : None
- *
- * RETURN          : Number of cameras
- *==========================================================================*/
-size_t TestContext::GetCamerasNum()
-{
-    return mAvailableCameras.size();
-}
-
-/*===========================================================================
- * FUNCTION        : AddScriptFromFile
- *
- * DESCRIPTION     : Add script from file
- *
- * PARAMETERS      :
- *   @scriptFile   : Script file
- *
- * RETURN          : status_t type of status
- *                   NO_ERROR  -- success
- *                   none-zero failure code
- *==========================================================================*/
-status_t TestContext::AddScriptFromFile(const char *scriptFile)
-{
-    mInterpreter = new Interpreter(scriptFile);
-    mInterpreter->setTestCtxInst(this);
-
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION        : releasePiPBuff
- *
- * DESCRIPTION     : Release video in video temp buffer
- *
- * PARAMETERS      : None
- *
- * RETURN          : None
- *==========================================================================*/
-void Interpreter::releasePiPBuff() {
-    free(mTestContext->mViVBuff.buff);
-    mTestContext->mViVBuff.buff = NULL;
-}
-
-/*===========================================================================
- * FUNCTION   : functionalTest
- *
- * DESCRIPTION: queries and executes client supplied commands for testing a
- *              particular camera.
- *
- * PARAMETERS :
- *  @availableCameras : List with all cameras supported
- *
- * RETURN     : status_t type of status
- *              NO_ERROR  -- continue testing
- *              none-zero -- quit test
- *==========================================================================*/
-status_t TestContext::FunctionalTest()
-{
-    status_t stat = NO_ERROR;
-    const char *ZSLStr = NULL;
-    size_t ZSLStrSize = 0;
-
-    assert(mAvailableCameras.size());
-
-    if ( !mInterpreter ) {
-        mInterpreter = new Interpreter();
-        mInterpreter->setTestCtxInst(this);
-    }
-
-    if (mAvailableCameras.size() == 0) {
-        printf("no cameras supported... exiting test app\n");
-    } else {
-        mTestRunning = true;
-    }
-
-    while (mTestRunning) {
-        sp<CameraContext> currentCamera =
-            mAvailableCameras.itemAt(mCurrentCameraIndex);
-        Interpreter::Command command =
-            mInterpreter->getCommand(currentCamera);
-        currentCamera->enablePrintPreview();
-
-        switch (command.cmd) {
-        case Interpreter::SWITCH_CAMERA_CMD:
-        {
-            mCurrentCameraIndex++;
-            mCurrentCameraIndex %= mAvailableCameras.size();
-            currentCamera = mAvailableCameras.itemAt(mCurrentCameraIndex);
-            stat = currentCamera->openCamera();
-        }
-            break;
-
-        case Interpreter::RESUME_PREVIEW_CMD:
-        {
-            stat = currentCamera->resumePreview();
-        }
-            break;
-
-        case Interpreter::START_PREVIEW_CMD:
-        {
-            stat = currentCamera->startPreview();
-        }
-            break;
-
-        case Interpreter::STOP_PREVIEW_CMD:
-        {
-            stat = currentCamera->stopPreview();
-        }
-            break;
-
-        case Interpreter::CHANGE_VIDEO_SIZE_CMD:
-        {
-            if ( command.arg )
-                stat = currentCamera->setVideoSize(command.arg);
-            else
-                stat = currentCamera->nextVideoSize();
-        }
-        break;
-
-        case Interpreter::CHANGE_PREVIEW_SIZE_CMD:
-        {
-            if ( command.arg )
-                stat = currentCamera->setPreviewSize(command.arg);
-            else
-                stat = currentCamera->nextPreviewSize();
-        }
-            break;
-
-        case Interpreter::CHANGE_PICTURE_SIZE_CMD:
-        {
-            if ( command.arg )
-                stat = currentCamera->setPictureSize(command.arg);
-            else
-                stat = currentCamera->nextPictureSize();
-        }
-            break;
-
-        case Interpreter::DUMP_CAPS_CMD:
-        {
-            currentCamera->printSupportedParams();
-        }
-            break;
-
-        case Interpreter::AUTOFOCUS_CMD:
-        {
-            stat = currentCamera->autoFocus();
-        }
-            break;
-
-        case Interpreter::TAKEPICTURE_CMD:
-        {
-            stat = currentCamera->takePicture();
-        }
-            break;
-
-        case Interpreter::TAKEPICTURE_IN_PICTURE_CMD:
-        {
-            if (mAvailableCameras.size() == 2) {
-                mSaveCurrentCameraIndex = mCurrentCameraIndex;
-                for (size_t i = 0; i < mAvailableCameras.size(); i++) {
-                    mCurrentCameraIndex = i;
-                    currentCamera = mAvailableCameras.itemAt(mCurrentCameraIndex);
-                    currentCamera->enablePiPCapture();
-                    stat = currentCamera->takePicture();
-                }
-                mCurrentCameraIndex = mSaveCurrentCameraIndex;
-            } else {
-                printf("Number of available sensors should be 2\n");
-            }
-        }
-        break;
-
-        case Interpreter::ENABLE_PRV_CALLBACKS_CMD:
-        {
-            stat = currentCamera->enablePreviewCallbacks();
-        }
-            break;
-
-        case Interpreter::START_RECORD_CMD:
-        {
-            stat = currentCamera->stopPreview();
-            stat = currentCamera->configureRecorder();
-            stat = currentCamera->startPreview();
-            stat = currentCamera->startRecording();
-        }
-            break;
-
-        case Interpreter::STOP_RECORD_CMD:
-        {
-            stat = currentCamera->stopRecording();
-
-            stat = currentCamera->stopPreview();
-            stat = currentCamera->unconfigureRecorder();
-            stat = currentCamera->startPreview();
-        }
-            break;
-
-        case Interpreter::START_VIV_RECORD_CMD:
-        {
-
-            if (mAvailableCameras.size() == 2) {
-                mSaveCurrentCameraIndex = mCurrentCameraIndex;
-                stat = mInterpreter->configureViVCodec();
-                for ( size_t i = 0; i < mAvailableCameras.size(); i++ ) {
-                    mCurrentCameraIndex = i;
-                    currentCamera = mAvailableCameras.itemAt(
-                        mCurrentCameraIndex);
-                    stat = currentCamera->stopPreview();
-                    stat = currentCamera->configureViVRecording();
-                    stat = currentCamera->startPreview();
-                    stat = currentCamera->startViVRecording();
-                }
-                mCurrentCameraIndex = mSaveCurrentCameraIndex;
-            } else {
-                printf("Number of available sensors should be 2\n");
-            }
-
-        }
-            break;
-
-        case Interpreter::STOP_VIV_RECORD_CMD:
-        {
-            if (mAvailableCameras.size() == 2) {
-                mSaveCurrentCameraIndex = mCurrentCameraIndex;
-                for ( size_t i = 0; i < mAvailableCameras.size(); i++ ) {
-                    mCurrentCameraIndex = i;
-                    currentCamera = mAvailableCameras.itemAt(
-                        mCurrentCameraIndex);
-                    stat = currentCamera->stopViVRecording();
-                    stat = currentCamera->stopPreview();
-                    stat = currentCamera->unconfigureRecorder();
-                    stat = currentCamera->startPreview();
-                }
-                stat = mInterpreter->unconfigureViVCodec();
-                mCurrentCameraIndex = mSaveCurrentCameraIndex;
-
-                mInterpreter->releasePiPBuff();
-            } else {
-                printf("Number of available sensors should be 2\n");
-            }
-        }
-        break;
-
-        case Interpreter::EXIT_CMD:
-        {
-            currentCamera->stopPreview();
-            mTestRunning = false;
-        }
-            break;
-
-        case Interpreter::DELAY:
-        {
-            if ( command.arg ) {
-                int delay = atoi(command.arg);
-                if (0 < delay) {
-                    usleep(1000U * (unsigned int)delay);
-                }
-            }
-        }
-            break;
-
-        case Interpreter::ZSL_CMD:
-        {
-            currentCamera = mAvailableCameras.itemAt(
-                    mCurrentCameraIndex);
-            ZSLStr = currentCamera->getZSL();
-
-            if (NULL != ZSLStr) {
-                ZSLStrSize = strlen(ZSLStr);
-                if (!strncmp(ZSLStr, "off", ZSLStrSize)) {
-                    currentCamera->setZSL("on");
-                    mIsZSLOn = true;
-                } else if (!strncmp(ZSLStr, "on", ZSLStrSize)) {
-                    currentCamera->setZSL("off");
-                    mIsZSLOn = false;
-                } else {
-                    printf("Set zsl failed!\n");
-                }
-            } else {
-                printf("zsl is NULL\n");
-            }
-        }
-            break;
-
-        default:
-        {
-            currentCamera->disablePrintPreview();
-        }
-            break;
-        }
-        printf("Command status 0x%x \n", stat);
-    }
-
-    return NO_ERROR;
-}
-
-/*===========================================================================
- * FUNCTION   : PiPLock
- *
- * DESCRIPTION: Mutex lock for PiP capture
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void TestContext::PiPLock()
-{
-    Mutex::Autolock l(mPiPLock);
-    while (mPiPinUse) {
-        mPiPCond.wait(mPiPLock);
-    }
-    mPiPinUse = true;
-}
-
-/*===========================================================================
- * FUNCTION   : PiPUnLock
- *
- * DESCRIPTION: Mutex unlock for PiP capture
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void TestContext::PiPUnlock()
-{
-    Mutex::Autolock l(mPiPLock);
-    mPiPinUse = false;
-    mPiPCond.signal();
-}
-
-/*===========================================================================
- * FUNCTION   : ViVLock
- *
- * DESCRIPTION: Mutex lock for ViV Video
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void TestContext::ViVLock()
-{
-    Mutex::Autolock l(mViVLock);
-    while (mViVinUse) {
-        mViVCond.wait(mViVLock);
-    }
-    mViVinUse = true;
-}
-
-/*===========================================================================
- * FUNCTION   : ViVUnlock
- *
- * DESCRIPTION: Mutex unlock for ViV Video
- *
- * PARAMETERS : none
- *
- * RETURN     : none
- *==========================================================================*/
-void TestContext::ViVUnlock()
-{
-    Mutex::Autolock l(mViVLock);
-    mViVinUse = false;
-    mViVCond.signal();
-}
-
-/*===========================================================================
- * FUNCTION     : setViVSize
- *
- * DESCRIPTION  : Set video in video size
- *
- * PARAMETERS   :
- *   @VideoSize : video size
- *   @camIndex  : camera index
- *
- * RETURN       : none
- *==========================================================================*/
-void TestContext::setViVSize(Size VideoSize, int camIndex)
-{
-    mViVVid.VideoSizes[camIndex] = VideoSize;
-}
-
-/*===========================================================================
- * FUNCTION     : main
- *
- * DESCRIPTION  : main function
- *
- * PARAMETERS   :
- *   @argc      : argc
- *   @argv      : argv
- *
- * RETURN       : int status
- *==========================================================================*/
-int main(int argc, char *argv[])
-{
-    TestContext ctx;
-
-    if (argc > 1) {
-        if ( ctx.AddScriptFromFile((const char *)argv[1]) ) {
-            printf("Could not add script file... "
-                "continuing in normal menu mode! \n");
-        }
-    }
-
-    ctx.FunctionalTest();
-
-    return 0;
-}
diff --git a/camera/QCamera2/HAL/test/qcamera_test.h b/camera/QCamera2/HAL/test/qcamera_test.h
deleted file mode 100644
index b8c5998..0000000
--- a/camera/QCamera2/HAL/test/qcamera_test.h
+++ /dev/null
@@ -1,361 +0,0 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef QCAMERA_TEST_H
-#define QCAMERA_TEST_H
-
-#include <SkData.h>
-#include <SkBitmap.h>
-#include <SkStream.h>
-
-namespace qcamera {
-
-using namespace android;
-
-#define MAX_CAM_INSTANCES 3
-
-class TestContext;
-
-class CameraContext : public CameraListener,
-    public ICameraRecordingProxyListener{
-public:
-    typedef enum {
-        READ_METADATA = 1,
-        READ_IMAGE = 2,
-        READ_ALL = 3
-    } ReadMode_t;
-
-    // This structure is used to store jpeg file sections in memory.
-    typedef struct {
-        unsigned char *  Data;
-        int      Type;
-        size_t   Size;
-    } Sections_t;
-
-public:
-    static const char KEY_ZSL[];
-
-    CameraContext(int cameraIndex);
-    virtual ~CameraContext();
-
-
-
-    status_t openCamera();
-    status_t closeCamera();
-
-    status_t startPreview();
-    status_t stopPreview();
-    status_t resumePreview();
-    status_t autoFocus();
-    status_t enablePreviewCallbacks();
-    status_t takePicture();
-    status_t startRecording();
-    status_t stopRecording();
-    status_t startViVRecording();
-    status_t stopViVRecording();
-    status_t configureViVRecording();
-
-    status_t nextPreviewSize();
-    status_t setPreviewSize(const char *format);
-    status_t getCurrentPreviewSize(Size &previewSize);
-
-    status_t nextPictureSize();
-    status_t getCurrentPictureSize(Size &pictureSize);
-    status_t setPictureSize(const char *format);
-
-    status_t nextVideoSize();
-    status_t setVideoSize(const char *format);
-    status_t getCurrentVideoSize(Size &videoSize);
-    status_t configureRecorder();
-    status_t unconfigureRecorder();
-    Sections_t *FindSection(int SectionType);
-    status_t ReadSectionsFromBuffer (unsigned char *buffer,
-            size_t buffer_size, ReadMode_t ReadMode);
-    virtual IBinder* onAsBinder();
-    void setTestCtxInstance(TestContext *instance);
-
-    void printMenu(sp<CameraContext> currentCamera);
-    void printSupportedParams();
-    const char *getZSL();
-    void setZSL(const char *value);
-
-
-    int getCameraIndex() { return mCameraIndex; }
-    int getNumberOfCameras();
-    void enablePrintPreview();
-    void disablePrintPreview();
-    void enablePiPCapture();
-    void disablePiPCapture();
-    void CheckSectionsAllocated();
-    void DiscardData();
-    void DiscardSections();
-    size_t calcBufferSize(int width, int height);
-    size_t calcStride(int width);
-    size_t calcYScanLines(int height);
-    size_t calcUVScanLines(int height);
-
-    virtual void notify(int32_t msgType, int32_t ext1, int32_t ext2);
-    virtual void postData(int32_t msgType,
-            const sp<IMemory>& dataPtr,
-            camera_frame_metadata_t *metadata);
-
-    virtual void postDataTimestamp(nsecs_t timestamp,
-            int32_t msgType,
-            const sp<IMemory>& dataPtr);
-    virtual void dataCallbackTimestamp(nsecs_t timestamp,
-            int32_t msgType,
-            const sp<IMemory>& dataPtr);
-
-private:
-
-    status_t createPreviewSurface(int width, int height, int32_t pixFormat);
-    status_t destroyPreviewSurface();
-
-    status_t saveFile(const sp<IMemory>& mem, String8 path);
-    SkBitmap * PiPCopyToOneFile(SkBitmap *bitmap0, SkBitmap *bitmap1);
-    status_t decodeJPEG(const sp<IMemory>& mem, SkBitmap *skBM);
-    status_t encodeJPEG(SkWStream * stream, const SkBitmap *bitmap,
-        String8 path);
-    void previewCallback(const sp<IMemory>& mem);
-
-    static int JpegIdx;
-    int mCameraIndex;
-    bool mResizePreview;
-    bool mHardwareActive;
-    bool mPreviewRunning;
-    bool mRecordRunning;
-    int  mVideoFd;
-    int  mVideoIdx;
-    bool mRecordingHint;
-    bool mDoPrintMenu;
-    bool mPiPCapture;
-    static int mPiPIdx;
-    unsigned int mfmtMultiplier;
-    int mWidthTmp;
-    int mHeightTmp;
-    size_t mSectionsRead;
-    size_t mSectionsAllocated;
-    Sections_t * mSections;
-    Sections_t * mJEXIFTmp;
-    Sections_t mJEXIFSection;
-    int mHaveAll;
-    TestContext *mInterpr;
-
-    sp<Camera> mCamera;
-    sp<SurfaceComposerClient> mClient;
-    sp<SurfaceControl> mSurfaceControl;
-    sp<Surface> mPreviewSurface;
-    sp<MediaRecorder> mRecorder;
-    CameraParameters mParams;
-    SkBitmap *skBMDec;
-    SkImageEncoder* skJpegEnc;
-    SkBitmap skBMtmp;
-    sp<IMemory> PiPPtrTmp;
-
-    size_t mCurrentPreviewSizeIdx;
-    Size getPreviewSizeFromVideoSizes(Size currentVideoSize);
-    size_t mCurrentPictureSizeIdx;
-    size_t mCurrentVideoSizeIdx;
-    Vector<Size> mSupportedPreviewSizes;
-    Vector<Size> mSupportedPictureSizes;
-    Vector<Size> mSupportedVideoSizes;
-
-    bool mInUse;
-    Mutex mLock;
-    Condition mCond;
-
-    void useLock();
-    void signalFinished();
-
-    //------------------------------------------------------------------------
-    // JPEG markers consist of one or more 0xFF bytes, followed by a marker
-    // code byte (which is not an FF).  Here are the marker codes of interest
-    // in this program.  (See jdmarker.c for a more complete list.)
-    //------------------------------------------------------------------------
-    #define M_SOF0  0xC0          // Start Of Frame N
-    #define M_SOF1  0xC1          // N indicates which compression process
-    #define M_SOF2  0xC2          // Only SOF0-SOF2 are now in common use
-    #define M_SOF3  0xC3
-    #define M_SOF5  0xC5          // NB: codes C4 and CC are NOT SOF markers
-    #define M_SOF6  0xC6
-    #define M_SOF7  0xC7
-    #define M_SOF9  0xC9
-    #define M_SOF10 0xCA
-    #define M_SOF11 0xCB
-    #define M_SOF13 0xCD
-    #define M_SOF14 0xCE
-    #define M_SOF15 0xCF
-    #define M_SOI   0xD8          // Start Of Image (beginning of datastream)
-    #define M_EOI   0xD9          // End Of Image (end of datastream)
-    #define M_SOS   0xDA          // Start Of Scan (begins compressed data)
-    #define M_JFIF  0xE0          // Jfif marker
-    #define M_EXIF  0xE1          // Exif marker.  Also used for XMP data!
-    #define M_XMP   0x10E1        // Not a real tag same value as Exif!
-    #define M_COM   0xFE          // COMment
-    #define M_DQT   0xDB
-    #define M_DHT   0xC4
-    #define M_DRI   0xDD
-    #define M_IPTC  0xED          // IPTC marker
-    #define PSEUDO_IMAGE_MARKER 0x123; // Extra value.
-};
-
-class Interpreter
-{
-public:
-    enum Commands_e {
-        SWITCH_CAMERA_CMD = 'A',
-        RESUME_PREVIEW_CMD = '[',
-        START_PREVIEW_CMD = '1',
-        STOP_PREVIEW_CMD = '2',
-        CHANGE_VIDEO_SIZE_CMD = '3',
-        CHANGE_PREVIEW_SIZE_CMD = '4',
-        CHANGE_PICTURE_SIZE_CMD = '5',
-        START_RECORD_CMD = '6',
-        STOP_RECORD_CMD = '7',
-        START_VIV_RECORD_CMD = '8',
-        STOP_VIV_RECORD_CMD = '9',
-        DUMP_CAPS_CMD = 'E',
-        AUTOFOCUS_CMD = 'f',
-        TAKEPICTURE_CMD = 'p',
-        TAKEPICTURE_IN_PICTURE_CMD = 'P',
-        ENABLE_PRV_CALLBACKS_CMD = '&',
-        EXIT_CMD = 'q',
-        DELAY = 'd',
-        ZSL_CMD = 'z',
-        INVALID_CMD = '0'
-    };
-
-    struct Command {
-        Command( Commands_e cmd_, char *arg_ = NULL)
-        : cmd(cmd_)
-        , arg(arg_) {}
-        Command()
-        : cmd(INVALID_CMD)
-        , arg(NULL) {}
-        Commands_e cmd;
-        char *arg;
-    };
-
-    /* API */
-    Interpreter()
-    : mUseScript(false)
-    , mScript(NULL) {}
-
-    Interpreter(const char *file);
-    ~Interpreter();
-
-    Command getCommand(sp<CameraContext> currentCamera);
-    void releasePiPBuff();
-    status_t configureViVCodec();
-    void setViVSize(Size VideoSize, int camIndex);
-    void setTestCtxInst(TestContext *instance);
-    status_t unconfigureViVCodec();
-    status_t ViVEncoderThread();
-    void ViVEncode();
-    static void *ThreadWrapper(void *context);
-
-private:
-    static const int numberOfCommands;
-
-    bool mUseScript;
-    size_t mCmdIndex;
-    char *mScript;
-    Vector<Command> mCommands;
-    TestContext *mTestContext;
-    pthread_t mViVEncThread;
-};
-
-class TestContext
-{
-    friend class CameraContext;
-    friend class Interpreter;
-public:
-    TestContext();
-    ~TestContext();
-
-    size_t GetCamerasNum();
-    status_t FunctionalTest();
-    status_t AddScriptFromFile(const char *scriptFile);
-    void setViVSize(Size VideoSize, int camIndex);
-    void PiPLock();
-    void PiPUnlock();
-    void ViVLock();
-    void ViVUnlock();
-
-private:
-    sp<CameraContext> camera[MAX_CAM_INSTANCES];
-    char GetNextCmd(sp<qcamera::CameraContext> currentCamera);
-    size_t mCurrentCameraIndex;
-    size_t mSaveCurrentCameraIndex;
-    Vector< sp<qcamera::CameraContext> > mAvailableCameras;
-    bool mTestRunning;
-    Interpreter *mInterpreter;
-    Mutex mPiPLock;
-    Condition mPiPCond;
-    bool mPiPinUse;
-    Mutex mViVLock;
-    Condition mViVCond;
-    bool mViVinUse;
-    bool mIsZSLOn;
-
-    typedef struct ViVBuff_t{
-        void *buff;
-        size_t buffSize;
-        size_t YStride;
-        size_t UVStride;
-        size_t YScanLines;
-        size_t UVScanLines;
-        size_t srcWidth;
-        size_t srcHeight;
-    } ViVBuff_t;
-
-    typedef struct ViVVid_t{
-        sp<IGraphicBufferProducer> bufferProducer;
-        sp<Surface> surface;
-        sp<MediaCodec> codec;
-        sp<MediaMuxer> muxer;
-        sp<ANativeWindow> ANW;
-        Vector<sp<ABuffer> > buffers;
-        Size VideoSizes[2];
-        int ViVIdx;
-        size_t buff_cnt;
-        sp<GraphicBuffer> graphBuf;
-        void * mappedBuff;
-        bool isBuffValid;
-        int sourceCameraID;
-        int destinationCameraID;
-    } vidPiP_t;
-
-    ViVVid_t mViVVid;
-    ViVBuff_t mViVBuff;
-};
-
-}; //namespace qcamera
-
-#endif
diff --git a/camera/QCamera2/HAL3/test/Android.mk b/camera/QCamera2/HAL3/test/Android.mk
deleted file mode 100755
index a735f3a..0000000
--- a/camera/QCamera2/HAL3/test/Android.mk
+++ /dev/null
@@ -1,48 +0,0 @@
-LOCAL_PATH:=$(call my-dir)
-
-# Build command line test app: mm-hal3-app
-include $(CLEAR_VARS)
-
-ifeq ($(TARGET_SUPPORT_HAL1),false)
-LOCAL_CFLAGS += -DQCAMERA_HAL3_SUPPORT
-endif
-
-ifeq ($(TARGET_BOARD_PLATFORM),msm8953)
-    LOCAL_CFLAGS += -DCAMERA_CHIPSET_8953
-else
-    LOCAL_CFLAGS += -DCAMERA_CHIPSET_8937
-endif
-
-LOCAL_C_INCLUDES += $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
-LOCAL_C_INCLUDES+= $(kernel_includes)
-
-LOCAL_C_INCLUDES += \
-    hardware/libhardware/include/hardware \
-    system/media/camera/include \
-    system/media/private/camera/include \
-    $(LOCAL_PATH)/../ \
-    $(LOCAL_PATH)/../../stack/mm-camera-interface/inc \
-
-
-LOCAL_SRC_FILES := \
-    QCameraHAL3Base.cpp \
-    QCameraHAL3MainTestContext.cpp \
-    QCameraHAL3VideoTest.cpp \
-    QCameraHAL3PreviewTest.cpp \
-    QCameraHAL3SnapshotTest.cpp \
-    QCameraHAL3RawSnapshotTest.cpp \
-    QCameraHAL3Test.cpp
-
-
-LOCAL_SHARED_LIBRARIES:= libutils libcamera_client liblog libcamera_metadata libcutils
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-
-LOCAL_MODULE:= hal3-test-app
-LOCAL_VENDOR_MODULE := true
-
-LOCAL_CFLAGS += -Wall -Wextra
-
-LOCAL_CFLAGS += -std=c++11 -std=gnu++0x
-
-include $(BUILD_EXECUTABLE)
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3Base.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3Base.cpp
deleted file mode 100755
index b9fa5e1..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3Base.cpp
+++ /dev/null
@@ -1,447 +0,0 @@
-/*Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#include "QCameraHAL3MainTestContext.h"
-#include "QCameraHAL3SnapshotTest.h"
-#include "QCameraHAL3RawSnapshotTest.h"
-#include "QCameraHAL3PreviewTest.h"
-
-#ifdef QCAMERA_HAL3_SUPPORT
-#define LIB_PATH /usr/lib/hw/camera.msm8953.so
-#else
-#define LIB_PATH /system/lib/hw/camera.msm8953.so
-#endif
-
-extern "C" {
-extern int set_camera_metadata_vendor_ops(const vendor_tag_ops_t *query_ops);
-}
-
-/*#ifdef CAMERA_CHIPSET_8953
-#define CHIPSET_LIB lib/hw/camera.msm8953.so
-#else
-#define CHIPSET_LIB lib/hw/camera.msm8937.so
-#endif*/
-
-#define CAM_LIB(s) STR_LIB_PATH(s)
-#define STR_LIB_PATH(s) #s
-
-namespace qcamera {
-
-QCameraHAL3PreviewTest *mPreviewtestCase = NULL;
-QCameraHAL3VideoTest *mVideotestCase = NULL;
-QCameraHAL3SnapshotTest *mSnapshottestCase = NULL;
-QCameraHAL3RawSnapshotTest *mRawSnapshottestCase = NULL;
-
-struct timeval start_time;
-int capture_received;
-int pfd[2];
-extern int test_case_end;
-extern int snapshot_buffer;
-
-pthread_cond_t mRequestAppCond;
-std::list<uint32_t> PreviewQueue;
-std::list<uint32_t> VideoQueue;
-
-pthread_mutex_t TestAppLock = PTHREAD_MUTEX_INITIALIZER;
-pthread_mutex_t mCaptureRequestLock = PTHREAD_MUTEX_INITIALIZER;
-
-
-
-static void camera_device_status_change(
-        const struct camera_module_callbacks* callbacks,
-        int camera_id, int new_status)
-{
-    /* Stub function */
-}
-
-static void torch_mode_status_change(
-        const struct camera_module_callbacks* callbacks,
-        const char* camera_id, int new_status)
-{
-    /* Stub function */
-}
-
-static void Notify(
-        const camera3_callback_ops *cb,
-        const camera3_notify_msg *msg)
-{
-    /* Stub function */
-}
-
-static void ProcessCaptureResult(
-        const camera3_callback_ops *cb,
-        const camera3_capture_result *result)
-{
-    buffer_thread_msg_t msg;
-    extern CameraHAL3Base *mCamHal3Base;
-    int frame_num;
-    extern int req_sent;
-    extern int preview_buffer_allocated;
-    extern int video_buffer_allocated;
-    double elapsedTime;
-    int num;
-    struct timeval end_time;
-    LOGD("Cam Capture Result Callback %d and %d",
-            result->num_output_buffers, mCamHal3Base->mFrameCount);
-    if (mCamHal3Base->mTestCaseSelected == MENU_START_PREVIEW ||
-            mCamHal3Base->mTestCaseSelected == MENU_START_VIDEO) {
-        if (result->num_output_buffers == 1) {
-            frame_num = result->frame_number;
-            LOGD("Frame width:%d and height:%d and format:%d",
-                    result->output_buffers->stream->width,
-                    result->output_buffers->stream->height,
-                    result->output_buffers->stream->format);
-            (mCamHal3Base->mFrameCount)++;
-            LOGD("Preview/Video Capture Result %d and fcount: %d and req_Sent:%d and %d ",
-            result->num_output_buffers, mCamHal3Base->mFrameCount, req_sent, result->frame_number);
-            if (test_case_end == 0) {
-                if (mCamHal3Base->mTestCaseSelected == MENU_START_PREVIEW) {
-                    num = (result->frame_number)%preview_buffer_allocated;
-                    PreviewQueue.push_back(num);
-                }
-                else {
-                    num = (result->frame_number)%video_buffer_allocated;
-                           VideoQueue.push_back(num);
-                }
-                pthread_cond_signal(&mRequestAppCond);
-                memset(&msg, 0, sizeof(buffer_thread_msg_t));
-            }
-        }
-    }
-    else {
-        extern int fcount_captured;
-        if (result->num_output_buffers == 1) {
-            LOGD("snapshot/Raw Capture1 Result Callback %d and %d",
-                    result->num_output_buffers, fcount_captured);
-            (mCamHal3Base->mFrameCount)++;
-            fcount_captured++;
-            LOGD("\n Capture %d done preparing for capture ", fcount_captured);
-            memset(&msg, 0, sizeof(buffer_thread_msg_t));
-            write(pfd[1], &msg, sizeof(buffer_thread_msg_t));
-        }
-    }
-}
-
-CameraHAL3Base::CameraHAL3Base(int cameraIndex) :
-    mCameraIndex(cameraIndex),
-    mLibHandle(NULL),
-    mFrameCount(0),
-    mSecElapsed(1),
-    mTestCaseSelected(0),
-    mPreviewRunning(0),
-    mVideoRunning(0),
-    mSnapShotRunning(0)
-{
-
-}
-
-
-int CameraHAL3Base::hal3appCameraTestLoad()
-{
-    int rc = HAL3_CAM_OK;
-    int numCam;
-    int32_t res = 0;
-    hal3_camera_test_obj_t *my_test_obj;
-    mLibHandle = new hal3_camera_lib_test;
-    memset(mLibHandle, 0, sizeof(hal3_camera_lib_handle));
-    rc = hal3appTestLoad(&mLibHandle->app_obj);
-    camera_module_t *my_if_handle = mLibHandle->app_obj.hal3_lib.halModule_t;
-    if (HAL3_CAM_OK != rc) {
-        LOGE("hal3 err\n");
-        goto EXIT;
-    }
-
-    numCam = my_if_handle->get_number_of_cameras();
-    printf("\n Number of Cameras are : %d ", numCam);
-    if (my_if_handle->get_vendor_tag_ops) {
-        mLibHandle->app_obj.mVendorTagOps = vendor_tag_ops_t();
-        my_if_handle->get_vendor_tag_ops(&(mLibHandle->app_obj.mVendorTagOps));
-
-        res = set_camera_metadata_vendor_ops(&(mLibHandle->app_obj.mVendorTagOps));
-        if (0 != res) {
-            printf("%s: Could not set vendor tag descriptor, "
-                    "received error %s (%d). \n", __func__,
-                    strerror(-res), res);
-            goto EXIT;
-        }
-    }
-    my_test_obj = &(mLibHandle->test_obj);
-    my_test_obj->module_cb.torch_mode_status_change = &torch_mode_status_change;
-    my_test_obj->module_cb.camera_device_status_change = &camera_device_status_change;
-    my_if_handle->set_callbacks(&(my_test_obj->module_cb));
-    my_if_handle->get_camera_info(0, &(mLibHandle->test_obj.cam_info));
-    return numCam;
-    EXIT:
-    return rc;
-
-}
-
-int CameraHAL3Base::hal3appCameraLibOpen(int camid)
-{
-    int rc;
-    rc = hal3appCamOpen(&mLibHandle->app_obj, (int)camid, &(mLibHandle->test_obj));
-    if (rc != HAL3_CAM_OK) {
-        LOGE("hal3appCamOpen() camidx=%d, err=%d\n",
-                camid, rc);
-        goto EXIT;
-    }
-    rc = hal3appCamInitialize((int)camid, &mLibHandle->test_obj);
-    EXIT:
-    return rc;
-}
-
-int CameraHAL3Base::hal3appTestLoad(hal3_camera_app_t *my_hal3_app)
-{
-    memset(&my_hal3_app->hal3_lib, 0, sizeof(hal3_interface_lib_t));
-    printf("\nLibrary path is :%s", CAM_LIB(LIB_PATH));
-    my_hal3_app->hal3_lib.ptr = dlopen(CAM_LIB(LIB_PATH), RTLD_NOW);
-
-    if (!my_hal3_app->hal3_lib.ptr) {
-        LOGE("Error opening HAL libraries %s\n",
-                dlerror());
-        return -HAL3_CAM_E_GENERAL;
-    }
-    my_hal3_app->hal3_lib.halModule_t =
-        (camera_module_t*)dlsym(my_hal3_app->hal3_lib.ptr, HAL_MODULE_INFO_SYM_AS_STR);
-    if (my_hal3_app->hal3_lib.halModule_t == NULL) {
-        LOGE("Error opening HAL library %s\n",
-                dlerror());
-        return -HAL3_CAM_E_GENERAL;
-    }
-    return HAL3_CAM_OK;
-}
-
-int CameraHAL3Base::hal3appCamOpen(
-        hal3_camera_app_t *my_hal3_app,
-        int camid,
-        hal3_camera_test_obj_t *my_test_obj)
-{
-    int rc = 0;
-    int numCam;
-    camera_module_t *my_if_handle = my_hal3_app->hal3_lib.halModule_t;
-    my_if_handle->common.methods->open(&(my_if_handle->common), "0",
-            reinterpret_cast<hw_device_t**>(&(my_test_obj->device)));
-    printf("\n Camera ID %d Opened \n", camid);
-    return HAL3_CAM_OK;
-}
-
-int CameraHAL3Base::hal3appCamInitialize(int camid, hal3_camera_test_obj_t *my_test_obj)
-{
-    int rc = 0;
-    camera3_device_t *device_handle = my_test_obj->device;
-    my_test_obj->callback_ops.notify = &Notify;
-    my_test_obj->callback_ops.process_capture_result = &ProcessCaptureResult;
-    rc = device_handle->ops->initialize(my_test_obj->device, &(my_test_obj->callback_ops));
-    if (rc != HAL3_CAM_OK) {
-        LOGE("hal3appCamInitialize() camidx=%d, err=%d\n",
-                camid, rc);
-        goto EXIT;
-    }
-    EXIT:
-    return rc;
-}
-
-
-void CameraHAL3Base::hal3appCheckStream(int testcase, int camid)
-{
-    if (testcase != MENU_START_PREVIEW) {
-        if (mPreviewtestCase != NULL) {
-            mPreviewtestCase->previewTestEnd(mLibHandle, camid);
-            delete mPreviewtestCase;
-            mPreviewtestCase = NULL;
-        }
-    }
-    if (testcase != MENU_START_VIDEO){
-        if (mVideotestCase != NULL) {
-            mVideotestCase->videoTestEnd(mLibHandle, camid);
-            delete mVideotestCase;
-            mVideotestCase = NULL;
-        }
-    }
-
-    if (testcase != MENU_START_CAPTURE){
-        if (mSnapshottestCase != NULL) {
-            delete mSnapshottestCase;
-            mSnapshottestCase = NULL;
-        }
-    }
-
-    if (testcase != MENU_START_RAW_CAPTURE) {
-        if (mRawSnapshottestCase != NULL) {
-            delete mRawSnapshottestCase;
-            mRawSnapshottestCase = NULL;
-        }
-    }
-}
-
-
-int CameraHAL3Base::hal3appCameraPreviewInit(int testcase, int camid, int w, int h)
-{
-    extern int req_sent;
-    int testCaseEndComplete = 0;
-    int CaptureRequestSent = 0;
-    if (w == 0 || h == 0) {
-        printf("\n Frame dimension is wrong");
-        return -1;
-    }
-    if ( mPreviewtestCase != NULL) {
-        return 0;
-    }
-    else {
-        testCaseEndComplete = 0;
-        do {
-            if (mVideoRunning == 1) {
-                hal3appCheckStream(MENU_START_PREVIEW, camid);
-            }
-            pthread_mutex_lock(&TestAppLock);
-            mTestCaseSelected = MENU_START_PREVIEW;
-            if (mVideoRunning != 1) {
-                hal3appCheckStream(MENU_START_PREVIEW, camid);
-            }
-            mPreviewtestCase = new QCameraHAL3PreviewTest(0);
-            printf("\n\n Testing the Resolution : %d X %d", w, h);
-            req_sent = 0;
-            PreviewQueue.clear();
-            capture_received = 0; mSecElapsed = 1;
-            snapshot_buffer = -1; mFrameCount = 0;
-            mPreviewtestCase->width = w; mPreviewtestCase->height = h;
-            mPreviewtestCase->initTest(mLibHandle,
-                    (int) MENU_START_PREVIEW, camid, w, h);
-            testCaseEndComplete = 1;
-        }while(testCaseEndComplete != 1);
-    }
-    return 0;
-}
-
-int CameraHAL3Base::hal3appCameraVideoInit(int testcase, int camid, int w, int h)
-{
-    extern int req_sent;
-    int testCaseEndComplete = 0;
-    int CaptureRequestSent = 0;
-    if (w == 0 || h == 0) {
-        printf("\n Frame dimension is wrong");
-        return -1;
-    }
-
-    if (mVideotestCase != NULL) {
-            return 0;
-    }
-    else {
-        testCaseEndComplete = 0;
-        do {
-            if (mPreviewRunning == 1) {
-                hal3appCheckStream(MENU_START_VIDEO, camid);
-            }
-            pthread_mutex_lock(&TestAppLock);
-            mTestCaseSelected = MENU_START_VIDEO;
-            if (mPreviewRunning != 1) {
-                hal3appCheckStream(MENU_START_VIDEO, camid);
-            }
-            mVideotestCase = new QCameraHAL3VideoTest(0);
-            VideoQueue.clear();
-            printf("\n\nTesting the Resolution : %d X %d", w, h);
-            req_sent = 0;
-            capture_received =0; mSecElapsed = 1; test_case_end = 0;
-            mVideotestCase->width = w; mVideotestCase->height = h;
-            snapshot_buffer = -1; mFrameCount = 0;
-            mVideotestCase->initTest(mLibHandle,
-                    (int) MENU_START_VIDEO, camid, w, h);
-            testCaseEndComplete = 1;
-        }while(testCaseEndComplete !=1);
-    }
-    return 0;
-}
-
-
-int CameraHAL3Base::hal3appRawCaptureInit(hal3_camera_lib_test *handle, int camid, int req_cap)
-{
-    int testCaseEndComplete = 0;
-    if (mSnapShotRunning != 1) {
-        hal3appCheckStream(MENU_START_RAW_CAPTURE, camid);
-    }
-    testCaseEndComplete = 0;
-    do {
-        pthread_mutex_lock(&TestAppLock);
-        if (mSnapShotRunning == 1) {
-            hal3appCheckStream(MENU_START_RAW_CAPTURE, camid);
-        }
-        printf("\n capture:%d", req_cap);
-        mTestCaseSelected = MENU_START_RAW_CAPTURE;
-        mRawSnapshottestCase = new QCameraHAL3RawSnapshotTest(req_cap);
-        mRawSnapshottestCase->mRequestedCapture = req_cap;
-        mRawSnapshottestCase->initTest(mLibHandle,
-        (int) MENU_START_RAW_CAPTURE, camid, RAWSNAPSHOT_CAPTURE_WIDTH,
-                RAWSNAPSHOT_CAPTURE_HEIGHT);
-        testCaseEndComplete = 1;
-    }while(testCaseEndComplete !=1);
-    return 0;
-}
-
-int CameraHAL3Base::hal3appCameraCaptureInit(hal3_camera_lib_test *handle,
-        int camid, int req_cap)
-{
-    int testCaseEndComplete = 0;
-    if (mSnapShotRunning != 1) {
-        hal3appCheckStream(MENU_START_CAPTURE, camid);
-    }
-    testCaseEndComplete = 0;
-    do {
-        pthread_mutex_lock(&TestAppLock);
-        if (mSnapShotRunning == 1) {
-            hal3appCheckStream(MENU_START_CAPTURE, camid);
-        }
-        printf("\n capture:%d", req_cap);
-        mTestCaseSelected = MENU_START_CAPTURE;
-        mSnapshottestCase = new QCameraHAL3SnapshotTest(req_cap);
-        mSnapshottestCase->mRequestedCapture = req_cap;
-        mSnapshottestCase->initTest(mLibHandle,
-            (int) MENU_START_CAPTURE, camid, SNAPSHOT_CAPTURE_WIDTH, SNAPSHOT_CAPTURE_HEIGHT);
-        testCaseEndComplete = 1;
-    }while(testCaseEndComplete != 1);
-    return 0;
-}
-
-void CameraHAL3Base::hal3appCamCapabilityGet(hal3_camera_lib_test *handle, int camid)
-{
-    camera_module_t *my_if_handle = ((handle->app_obj).hal3_lib).halModule_t;
-    hal3_camera_test_obj_t *test_obj_handle = &(handle->test_obj);
-    camera_metadata_entry entry_hal3app;
-    camera_info info;
-    int i = 0, count = 0, j = 0;
-    long int num = 0;
-    int32_t *available_hdr = NULL, *available_svhdr = NULL, *available_ir = NULL;
-    android::CameraMetadata hal3_cam_settings;
-    printf("\n Number of Cameras are : %d and %p", camid, &(test_obj_handle->cam_info));
-    my_if_handle->get_camera_info(camid, &(test_obj_handle->cam_info));
-    info = test_obj_handle->cam_info;
-    hal3_cam_settings = (info.static_camera_characteristics);
-}
-
-}
-
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3Base.h b/camera/QCamera2/HAL3/test/QCameraHAL3Base.h
deleted file mode 100755
index 2b24816..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3Base.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/*Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3APP_H__
-#define __HAL3APP_H__
-
-#include <hardware/hardware.h>
-#include <dlfcn.h>
-#include <hardware/camera3.h>
-#include <sys/stat.h>
-#include <ctype.h>
-#include <list>
-#include <camera/CameraMetadata.h>
-#include <linux/msm_ion.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <system/window.h>
-#include <stdio.h>
-#include <pthread.h>
-#include <poll.h>
-
-extern "C" {
-#include "mm_camera_dbg.h"
-}
-
-#define HAL3_DATASPACE_UNKNOWN 0x0
-#define HAL3_DATASPACE_ARBITRARY 0x1
-#define HAL3_DATASPACE_JFIF 0x101
-#define FLAGS_VIDEO_ENCODER 0x00010000
-
-#define PREVIEW_WIDTH 1440
-#define PREVIEW_HEIGHT 1080
-
-#define VIDEO_WIDTH 1920
-#define VIDEO_HEIGHT 1080
-
-#define SNAPSHOT_CAPTURE_WIDTH 5344
-#define SNAPSHOT_CAPTURE_HEIGHT 4008
-
-#define RAWSNAPSHOT_CAPTURE_WIDTH 5344
-#define RAWSNAPSHOT_CAPTURE_HEIGHT 4016
-
-namespace qcamera {
-
-typedef enum {
-    HAL3_CAM_OK,
-    HAL3_CAM_E_GENERAL,
-    HAL3_CAM_E_NO_MEMORY,
-    HAL3_CAM_E_NOT_SUPPORTED,
-    HAL3_CAM_E_INVALID_INPUT,
-    HAL3_CAM_E_INVALID_OPERATION,
-    HAL3_CAM_E_ENCODE,
-    HAL3_CAM_E_BUFFER_REG,
-    HAL3_CAM_E_PMEM_ALLOC,
-    HAL3_CAM_E_CAPTURE_FAILED,
-    HAL3_CAM_E_CAPTURE_TIMEOUT,
-} hal3_camera_status_type_t;
-
-typedef enum {
-    PROCESS_BUFFER,
-} buffer_thread_msg_type_t;
-
-typedef struct {
-    camera3_device_t *device;
-    camera3_callback_ops callback_ops;
-    struct camera_info cam_info;
-    camera_module_callbacks_t module_cb;
-} hal3_camera_test_obj_t;
-
-typedef struct {
-    int fd;
-    int ion_fd;
-    ion_user_handle_t ion_handle;
-    size_t size;
-} hal3_camtest_meminfo_t;
-
-typedef struct {
-    buffer_thread_msg_type_t msg;
-    bool stop_thread;
-} buffer_thread_msg_t;
-
-typedef struct {
-    void *ptr;
-    camera_module_t* halModule_t;
-} hal3_interface_lib_t;
-
-typedef struct {
-    uint8_t num_cameras;
-    vendor_tag_ops_t mVendorTagOps;
-    hal3_interface_lib_t hal3_lib;
-} hal3_camera_app_t;
-
-typedef struct {
-    hal3_camera_app_t app_obj;
-    hal3_camera_test_obj_t test_obj;
-} hal3_camera_lib_test;
-
-typedef struct {
-    pthread_t td;
-    pthread_mutex_t mutex;
-    pthread_cond_t cond;
-    int32_t readfd;
-    int32_t writefd;
-    void *data_obj;
-    bool is_thread_started;
-    int testcase;
-} buffer_thread_t;
-
-extern int32_t pfd[2];
-typedef hal3_camera_lib_test hal3_camera_lib_handle;
-
-class CameraHAL3Base
-{
-    friend class MainTestContext;
-protected:
-    int mCameraIndex;
-public:
-    CameraHAL3Base();
-    CameraHAL3Base(int cameraIndex);
-    hal3_camera_lib_test *mLibHandle;
-    int mFrameCount;
-    int fps;
-    int mSecElapsed;
-    int mTestCaseSelected;
-    int mPreviewRunning;
-    int mVideoRunning;
-    int mSnapShotRunning;
-
-    int hal3appCamInitialize(int camid, hal3_camera_test_obj_t *my_test_obj);
-    void hal3appCamCapabilityGet(hal3_camera_lib_test *handle,int camid);
-    int hal3appCameraLibOpen(int );
-    int hal3appTestLoad(hal3_camera_app_t *);
-    int hal3appCamOpen(hal3_camera_app_t *,
-             int,
-             hal3_camera_test_obj_t *);
-    int hal3appCameraPreviewInit(int, int, int, int);
-    int hal3appCameraVideoInit(int, int camid, int w, int h);
-    int hal3appCameraCaptureInit(hal3_camera_lib_test *, int, int);
-    int hal3appRawCaptureInit(hal3_camera_lib_test *handle, int camid, int );
-    int hal3appCameraTestLoad();
-    void hal3appCheckStream(int testcase, int camid);
-};
-
-}
-#endif
\ No newline at end of file
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.cpp
deleted file mode 100755
index 13e46f9..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.cpp
+++ /dev/null
@@ -1,276 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#include "QCameraHAL3MainTestContext.h"
-#include "QCameraHAL3Base.h"
-
-namespace qcamera {
-
-#define MAX_CAMERA_SUPPORTED 20
-
-const CAMERA_BASE_MENU_TBL_T camera_main_menu_tbl[] = {
-    {MENU_START_PREVIEW,             "To Start Preview"},
-    {MENU_START_VIDEO,               "To Start Video"},
-    {MENU_START_CAPTURE,             "To Capture"},
-    {MENU_START_RAW_CAPTURE,         "To Raw Capture"},
-    {MENU_EXIT,                      "EXIT"},
-};
-
-const HAL3TEST_SENSOR_MENU_TBL_T sensor_tbl[] = {
-    {"Rear Camera"},
-    {"Front Camera"},
-};
-
-CameraHAL3Base *mCamHal3Base = NULL;
-pthread_mutex_t gCamLock = PTHREAD_MUTEX_INITIALIZER;
-
-MainTestContext::MainTestContext()
-{
-    int i = 0;
-    mTestRunning = false;
-    mCamHal3Base = NULL;
-}
-
-int MainTestContext::hal3appGetUserEvent()
-{
-    char tc_buf[3];
-    int choice;
-    int rc = 0, req_capture = 0;
-    int num_testcase = MENU_EXIT+1;
-    int submenu_choice, num;
-    int preview_restart;
-    static int prev_menu_choice;
-    uint8_t camid, num_of_cameras;
-    if (mCamHal3Base != NULL) {
-        delete mCamHal3Base;
-    }
-    mCamHal3Base = new CameraHAL3Base(0);
-    num_of_cameras = mCamHal3Base->hal3appCameraTestLoad();
-    if ((num_of_cameras <= 0) && (num_of_cameras >= MAX_CAMERA_SUPPORTED)) {
-        LOGE("\n Supported Camera Value is wrong : %d", num_of_cameras);
-        printf("\n Invalid Number Of Cameras");
-        goto exit;
-    }
-    else {
-        choice = hal3appDisplaySensorMenu(num_of_cameras);
-        if (choice >= num_of_cameras || choice < 0) {
-            printf("\n Unsupported Parameter");
-            goto exit;
-        }
-        else {
-            mCamHal3Base->mCameraIndex = choice;
-            rc = mCamHal3Base->hal3appCameraLibOpen(choice);
-        }
-    }
-    do {
-        choice = hal3appPrintMenu();
-        switch(choice) {
-            case MENU_START_PREVIEW:
-                mCamHal3Base->hal3appCameraPreviewInit(MENU_START_PREVIEW,
-                        mCamHal3Base->mCameraIndex, PREVIEW_WIDTH, PREVIEW_HEIGHT);
-                mCamHal3Base->mPreviewRunning = 1; mCamHal3Base->mVideoRunning = 0;
-                mCamHal3Base->mSnapShotRunning = 0;
-            break;
-
-            case MENU_START_VIDEO:
-                mCamHal3Base->hal3appCameraVideoInit(MENU_START_VIDEO,
-                        mCamHal3Base->mCameraIndex, VIDEO_WIDTH, VIDEO_HEIGHT);
-                mCamHal3Base->mPreviewRunning = 0; mCamHal3Base->mVideoRunning = 1;
-                mCamHal3Base->mSnapShotRunning = 0;
-            break;
-
-            case MENU_START_CAPTURE:
-                hal3appDisplaySnapshotMenu();
-                req_capture = 3; preview_restart = 0;
-                if (mCamHal3Base->mPreviewRunning == 1) {
-                    preview_restart = 1;
-                }
-                mCamHal3Base->hal3appCameraCaptureInit(0, 0, req_capture);
-                mCamHal3Base->mPreviewRunning = 0; mCamHal3Base->mVideoRunning = 0;
-                mCamHal3Base->mSnapShotRunning = 1;
-                if (preview_restart == 1) {
-                    mCamHal3Base->hal3appCameraPreviewInit(MENU_START_PREVIEW,
-                            mCamHal3Base->mCameraIndex, PREVIEW_WIDTH, PREVIEW_HEIGHT);
-                    mCamHal3Base->mPreviewRunning = 1; mCamHal3Base->mVideoRunning = 0;
-                    mCamHal3Base->mSnapShotRunning = 0;
-                }
-            break;
-
-            case MENU_START_RAW_CAPTURE:
-                hal3appDisplayRawCaptureMenu();
-                req_capture = 3;
-                mCamHal3Base->hal3appRawCaptureInit(0, 0, req_capture);
-                mCamHal3Base->mPreviewRunning = 0; mCamHal3Base->mVideoRunning = 0;
-                mCamHal3Base->mSnapShotRunning = 1;
-            break;
-
-            case MENU_EXIT:
-                hal3appDisplayExitMenu();
-            break;
-
-            default:
-                printf("\n Option not in Menu\n");
-        }
-    }while(choice != MENU_EXIT);
-    exit:
-    return 0;
-}
-
-int MainTestContext::hal3appDisplaySensorMenu(uint8_t num_of_cameras)
-{
-    int i, choice;
-    printf("\n");
-    printf("===========================================\n");
-    printf("    Camera Sensor to be used:            \n");
-    printf("===========================================\n\n");
-
-    for ( i=0;i < num_of_cameras; i++) {
-        if (i <= 1) {
-            printf("\n Press %d to select %s", (i), sensor_tbl[i].menu_name);
-        }
-        else {
-            printf("\n Press %d to select Camera%d", (i), i);
-        }
-    }
-    printf("\n Enter your Choice:");
-    fscanf(stdin, "%d", &choice);
-    return choice;
-}
-
-void MainTestContext::hal3appDisplayCapabilityMenu()
-{
-    printf("\n");
-    printf("===========================================\n");
-    printf("      Sensor Capabilty are dumped at location:\n");
-    printf("===========================================\n\n");
-}
-
-int MainTestContext::hal3appDisplayPreviewMenu()
-{
-    int choice;
-    printf("\n");
-    printf("===========================================\n");
-    printf("Select Camera Preview Resolution:\n");
-    printf("===========================================\n\n");
-    printf("========Select Preview Resolutions================\n");
-    printf("\nPress 1 .Aspect Ratio(4:3) Resolution 1440 X 1080");
-    printf("\nPress 2 .Aspect Ratio(16:9) Resolution 1920 X 1080");
-    printf("\n Enter your Choice:");
-    fscanf(stdin, "%d", &choice);
-    return choice;
-}
-
-int MainTestContext::hal3appDisplayVideoMenu()
-{
-    int choice1;
-    printf("\n");
-    printf("===========================================\n");
-    printf("Testing Camera Recording on Different Resolution:\n");
-    printf("===========================================\n\n");
-
-    printf("========Select Video Resolutions================\n");
-    printf("\nPress 1 .Aspect Ratio(4:3) Resolution 640 X 480");
-    printf("\nPress 2 .Aspect Ratio(16:9) Resolution 1920 X 1080");
-    printf("\nPress 3 .To select both");
-
-    printf("\n Enter your Choice:");
-    fscanf(stdin, "%d", &choice1);
-    return choice1;
-}
-
-void MainTestContext::hal3appDisplayRawCaptureMenu()
-{
-    int req_cap;
-    printf("\n");
-    printf("===========================================\n");
-    printf("Testing RAW Camera Capture on Different Resolution::\n");
-    printf("===========================================\n\n");
-}
-
-void MainTestContext::hal3appDisplaySnapshotMenu()
-{
-    int req_cap;
-    printf("\n");
-    printf("===========================================\n");
-    printf("Testing Normal Camera Capture on Resolution 5344 X 4008\n");
-    printf("===========================================\n\n");
-}
-
-
-void MainTestContext::hal3appDisplayExitMenu()
-{
-    printf("\n");
-    printf("===========================================\n");
-    printf("      Exiting HAL3 APP test \n");
-    printf("===========================================\n\n");
-}
-
-int MainTestContext::hal3appPrintMenu()
-{
-    int i, choice = 0;
-    char ch = '0';
-    printf("\n");
-    printf("===========================================\n");
-    printf("       HAL3 MENU \n");
-    printf("===========================================\n\n");
-    for ( i = 0; i < (int)(sizeof(camera_main_menu_tbl)/sizeof(camera_main_menu_tbl[0])); i++) {
-        printf("\n Press %d to select %s", (i+1), camera_main_menu_tbl[i].menu_name);
-    }
-    printf("\n Enter your Choice:");
-    do {
-        std::cin >> ch;
-    } while(!(ch >= '1' && ch <= '9'));
-    choice = ch -'0';
-    return choice;
-}
-}
-
-int main()
-{
-    char tc_buf[3];
-    int mode = 0;
-    int rc = 0;
-    qcamera::MainTestContext main_ctx;
-    printf("Please Select Execution Mode:\n");
-    printf("0: Menu Based 1: Regression\n");
-    printf("\n Enter your choice:");
-    fgets(tc_buf, 3, stdin);
-    mode = tc_buf[0] - '0';
-    if (mode == 0) {
-        printf("\nStarting Menu based!!\n");
-    } else {
-        printf("\nPlease Enter 0 or 1\n");
-        printf("\nExisting the App!!\n");
-        exit(1);
-    }
-    rc = main_ctx.hal3appGetUserEvent();
-    printf("Exiting application\n");
-    return rc;
-}
-
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.h b/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.h
deleted file mode 100755
index 1201cfd..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3MainTestContext.h
+++ /dev/null
@@ -1,82 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3TEST_H__
-#define __HAL3TEST_H__
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <iostream>
-namespace qcamera {
-
-
-typedef enum
-{
-    MENU_BASE = 0,
-    MENU_START_PREVIEW,
-    MENU_START_VIDEO,
-    MENU_START_CAPTURE,
-    MENU_START_RAW_CAPTURE,
-    MENU_EXIT
-} menu_id;
-
-typedef struct {
-    menu_id base_menu;
-    char *  basemenu_name;
-} HAL3TEST_BASE_MENU_TBL_T;
-
-typedef struct {
-    char * menu_name;
-} HAL3TEST_SENSOR_MENU_TBL_T;
-
-typedef struct {
-    menu_id main_menu;
-    char * menu_name;
-} CAMERA_BASE_MENU_TBL_T;
-
-class CameraHAL3Base;
-class MainTestContext
-{
-    int choice;
-    bool mTestRunning;
-public:
-    MainTestContext();
-    int hal3appGetUserEvent();
-    int hal3appDisplaySensorMenu(uint8_t );
-    void hal3appDisplayCapabilityMenu();
-    int hal3appDisplayPreviewMenu();
-    int hal3appDisplayVideoMenu();
-    void hal3appDisplayRawCaptureMenu();
-    void hal3appDisplaySnapshotMenu();
-    void hal3appDisplayExitMenu();
-    int hal3appPrintMenu();
-};
-
-}
-
-#endif
\ No newline at end of file
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.cpp
deleted file mode 100755
index 34693ad..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.cpp
+++ /dev/null
@@ -1,206 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#include "QCameraHAL3PreviewTest.h"
-#include "QCameraHAL3MainTestContext.h"
-
-namespace qcamera {
-extern hal3_camera_lib_test *CamObj_handle;
-int req_sent;
-extern pthread_cond_t mRequestAppCond;
-int test_case_end;
-bool thread_exit;
-extern std::list<uint32_t> PreviewQueue;
-int preview_buffer_allocated;
-extern pthread_mutex_t TestAppLock, mCaptureRequestLock;
-int snapshot_buffer = -1;
-
-
-QCameraHAL3PreviewTest::QCameraHAL3PreviewTest(int camid) :
-    QCameraHAL3Test(0),
-    mPreviewHandle(NULL),
-    mCaptureHandle(NULL),
-    mPreviewStream(NULL),
-    nobuffer(0)
-{
-
-}
-
-void QCameraHAL3PreviewTest::initTest(hal3_camera_lib_test *handle,
-                                int testcase, int camid, int w, int h)
-{
-    int i;
-    CamObj_handle = handle; thread_exit = 0; test_case_end = 0;
-    LOGD("\n buffer thread created %d and %d ", w, h);
-    configurePreviewStream(&(handle->test_obj) , camid, w, h);
-    LOGD("\n preview stream configured");
-    constructDefaultRequest(&(handle->test_obj), camid);
-    LOGD("Default stream setting read ");
-    printf("\npipeline_depth is %d", mPipelineDepthPreview);
-    mPreviewHandle = new native_handle_t *[mPipelineDepthPreview];
-    for (i = 0; i < mPipelineDepthPreview; i++)
-        mPreviewHandle[i] = new native_handle_t;
-    for (i = 0, req_sent = 1; i < mPipelineDepthPreview; i++, req_sent++) {
-        previewAllocateBuffers(width, height, i);
-        PreviewQueue.push_back(i);
-    }
-    LOGD(" Request Number is preview : %d ",mRequest.frame_number);
-    mRequest.frame_number = 0;
-    previewProcessThreadCreate(handle);
-}
-
-void QCameraHAL3PreviewTest::snapshotCaptureRequest(hal3_camera_lib_test *handle,
-        int testcase, int camid, int w, int h)
-{
-    captureRequestRepeat(handle, camid, MENU_START_CAPTURE);
-    pthread_mutex_unlock(&mCaptureRequestLock);
-}
-
-void QCameraHAL3PreviewTest::configurePreviewStream(hal3_camera_test_obj_t *my_test_obj,
-                                int camid, int w, int h)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mPreviewStream =  new camera3_stream_t;
-    memset(mPreviewStream, 0, sizeof(camera3_stream_t));
-    mPreviewStream = initStream(CAMERA3_STREAM_OUTPUT, camid, w, h, 0,
-            HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL3_DATASPACE_UNKNOWN);
-
-    mPreviewConfig = configureStream(CAMERA3_STREAM_CONFIGURATION_NORMAL_MODE, 1);
-    mPreviewConfig.streams[0] = mPreviewStream;
-    device_handle->ops->configure_streams(my_test_obj->device, &(mPreviewConfig));
-    mPipelineDepthPreview = mPreviewConfig.streams[0]->max_buffers;
-    preview_buffer_allocated = mPipelineDepthPreview;
-}
-
-void QCameraHAL3PreviewTest::constructDefaultRequest(
-        hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mMetaDataPtr[0]= device_handle->ops->construct_default_request_settings(my_test_obj->device,
-            CAMERA3_TEMPLATE_PREVIEW);
-    mMetaDataPtr[1] = device_handle->ops->construct_default_request_settings(my_test_obj->device,
-            CAMERA3_TEMPLATE_STILL_CAPTURE);
-}
-
-void QCameraHAL3PreviewTest::captureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase)
-{
-    struct timeval current_time;
-    int num1, num2;
-    double total_elapsedTime;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    int buffer_id;
-
-    if (testcase == MENU_START_PREVIEW) {
-        if (PreviewQueue.empty()) {
-            LOGE("no preview buffer");
-        }
-        else {
-            if (test_case_end == 0) {
-                LOGD(" Request Number is preview : %d ",mRequest.frame_number);
-                pthread_mutex_lock(&mCaptureRequestLock);
-                num2 = PreviewQueue.front();
-                PreviewQueue.pop_front();
-                num1 = mRequest.frame_number;
-                if (num1 < 2) {
-                    (mRequest).settings = mMetaDataPtr[0];
-                }
-                else {
-                    (mRequest).settings = NULL;
-                }
-                (mRequest).input_buffer = NULL;
-                (mRequest).num_output_buffers = 1;
-                mPreviewStreamBuffs.stream = mPreviewStream;
-                mPreviewStreamBuffs.status = 0;
-                mPreviewStreamBuffs.buffer =
-                        (const native_handle_t**)&mPreviewHandle[num2];
-                mPreviewStreamBuffs.release_fence = -1;
-                mPreviewStreamBuffs.acquire_fence = -1;
-                (mRequest).output_buffers = &(mPreviewStreamBuffs);
-                LOGD("Calling HAL3APP repeat capture request %d and %d and free buffer :%d "
-                        , num1, num2, PreviewQueue.size());
-
-                device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-                (mRequest.frame_number)++;
-                pthread_mutex_unlock(&mCaptureRequestLock);
-            }
-        }
-    }
-    else {
-        snapshot_buffer = mRequest.frame_number;
-        (mRequest).settings = mMetaDataPtr[1];
-        mSnapshotStreamBuffs = hal3appGetStreamBuffs(mSnapshotStream);
-        mSnapshotStreamBuffs.buffer = (const native_handle_t**)&mCaptureHandle;
-        mRequest = hal3appGetRequestSettings(&mSnapshotStreamBuffs, 1);
-        LOGD("Calling snap HAL3APP repeat capture request repeat %d  ", snapshot_buffer);
-        device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-        (mRequest.frame_number)++;
-    }
-}
-
-void QCameraHAL3PreviewTest::previewTestEnd(
-        hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    buffer_thread_msg_t msg;
-    test_case_end = 1;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    device_handle->ops->flush(my_test_obj->device);
-    LOGD("%s Closing Camera", __func__);
-    ioctl(mPreviewMeminfo.ion_fd, ION_IOC_FREE, &mPreviewMeminfo.ion_handle);
-    close(mPreviewMeminfo.ion_fd);
-    mPreviewMeminfo.ion_fd = -1;
-    LOGD("%s Closing thread", __func__);
-    thread_exit = 1;
-}
-
-void QCameraHAL3PreviewTest::previewAllocateBuffers(int width, int height, int num)
-{
-    mPreviewHandle[num] = allocateBuffers(width, height, &mPreviewMeminfo);
-}
-
-void QCameraHAL3PreviewTest::snapshotAllocateBuffers(int width, int height)
-{
-    mCaptureHandle = allocateBuffers(width, height, &mCaptureMemInfo);
-}
-
-bool QCameraHAL3PreviewTest::previewProcessThreadCreate(
-        hal3_camera_lib_test *handle)
-{
-    processThreadCreate(this, MENU_START_PREVIEW);
-    return 1;
-}
-
-QCameraHAL3PreviewTest::~QCameraHAL3PreviewTest()
-{
-
-}
-
-}
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.h b/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.h
deleted file mode 100755
index ae687cd..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3PreviewTest.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3APPPREVIEWTEST_H__
-#define __HAL3APPPREVIEWTEST_H__
-
-#include "QCameraHAL3Base.h"
-#include "QCameraHAL3Test.h"
-
-namespace qcamera {
-
-class QCameraHAL3PreviewTest : public QCameraHAL3Test
-{
-private:
-    hal3_camtest_meminfo_t mPreviewMeminfo;
-    native_handle_t **mPreviewHandle;
-    hal3_camtest_meminfo_t mCaptureMemInfo;
-    native_handle_t *mCaptureHandle;
-    const camera_metadata_t *mMetaDataPtr[3];
-    camera3_stream_t *mPreviewStream;
-    camera3_stream_t *mSnapshotStream;
-    camera3_capture_request mRequest;
-    camera3_stream_buffer_t mPreviewStreamBuffs;
-    camera3_stream_buffer_t mSnapshotStreamBuffs;
-    camera3_stream_configuration mPreviewConfig;
-public:
-    int width;
-    int height;
-    int nobuffer;
-    int mPipelineDepthPreview;
-
-    QCameraHAL3PreviewTest(int cameraIndex);
-    void configurePreviewStream(hal3_camera_test_obj_t *my_test_obj, int camid,
-            int w, int h);
-
-    void snapshotCaptureRequest(hal3_camera_lib_test *handle,
-            int testcase, int camid, int w, int h);
-    void constructDefaultRequest(hal3_camera_test_obj_t *, int);
-    void initTest(hal3_camera_lib_test *handle,
-            int testcase, int camid, int w, int h);
-
-    void captureRequestRepeat(hal3_camera_lib_test *, int, int);
-    void previewAllocateBuffers(int,
-            int, int);
-    bool previewProcessThreadCreate(hal3_camera_lib_test *);
-    void previewTestEnd(hal3_camera_lib_test *my_hal3test_obj, int camid);
-    void snapshotAllocateBuffers(int, int );
-    virtual ~QCameraHAL3PreviewTest();
-};
-
-    void * hal3appPreviewProcessBuffers(void *);
-}
-#endif
\ No newline at end of file
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.cpp
deleted file mode 100755
index f7e05a4..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.cpp
+++ /dev/null
@@ -1,263 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#include "QCameraHAL3RawSnapshotTest.h"
-#include "QCameraHAL3MainTestContext.h"
-
-namespace qcamera {
-hal3_camera_lib_test *RawSnapshot_CamObj_handle;
-extern int fcount_captured;
-extern pthread_mutex_t TestAppLock;
-
-QCameraHAL3RawSnapshotTest::QCameraHAL3RawSnapshotTest(int req_cap) :
-    QCameraHAL3Test(0),
-    mRawCaptureHandle(NULL),
-    mRawSnapshotStream(NULL),
-    mRequestedCapture(req_cap)
-{
-
-}
-
-void QCameraHAL3RawSnapshotTest::initTest(hal3_camera_lib_test *handle,
-        int testcase, int camid, int w, int h)
-{
-    int i; fcount_captured = 0;
-    RawSnapshot_CamObj_handle = handle;
-    LOGD("\n Raw buffer thread created");
-    configureRawSnapshotStream(&(handle->test_obj), camid, w, h);
-    constructDefaultRequest(&(handle->test_obj), 0);
-    LOGD("\n Raw Snapshot Default stream setting read");
-    rawProcessThreadCreate(MENU_START_RAW_CAPTURE,
-            rawProcessBuffers);
-    mRequest.frame_number = 0;
-    LOGD("\nRaw  Snapshot stream configured");
-    rawProcessCaptureRequest(&(handle->test_obj), 0);
-    LOGD("\nRaw  Snapshot Process Capture Request Sent");
-}
-
-void QCameraHAL3RawSnapshotTest::constructDefaultRequest(
-        hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mMetaDataPtr[0] = device_handle->ops->construct_default_request_settings(
-            my_test_obj->device, CAMERA3_TEMPLATE_PREVIEW);
-    mMetaDataPtr[1] = device_handle->ops->construct_default_request_settings(
-            my_test_obj->device, CAMERA3_TEMPLATE_STILL_CAPTURE);
-}
-
-void QCameraHAL3RawSnapshotTest::configureRawSnapshotStream(hal3_camera_test_obj_t *my_test_obj,
-                                    int camid, int w, int h)
-{
-    camera3_stream_t *r_stream, *p_stream;
-    camera3_device_t *device_handle = my_test_obj->device;
-    mPreviewStream = new camera3_stream_t;
-    mRawSnapshotStream = new camera3_stream_t;
-
-    memset(mPreviewStream, 0, sizeof(camera3_stream_t));
-    memset(mRawSnapshotStream, 0, sizeof(camera3_stream_t));
-
-    mPreviewStream = initStream(CAMERA3_STREAM_OUTPUT, camid, PREVIEW_WIDTH, PREVIEW_HEIGHT, 0,
-            HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL3_DATASPACE_UNKNOWN);
-    mRawSnapshotStream = initStream(CAMERA3_STREAM_OUTPUT, camid, RAWSNAPSHOT_CAPTURE_WIDTH,
-            RAWSNAPSHOT_CAPTURE_HEIGHT, 0, HAL_PIXEL_FORMAT_RAW16, HAL3_DATASPACE_ARBITRARY);
-    mRawSnapshotConfig = configureStream(CAMERA3_STREAM_CONFIGURATION_NORMAL_MODE, 2);
-
-    mRawSnapshotConfig.streams[0] = mPreviewStream;
-    mRawSnapshotConfig.streams[1] = mRawSnapshotStream;
-    device_handle->ops->configure_streams(my_test_obj->device, &(mRawSnapshotConfig));
-}
-
-
-void QCameraHAL3RawSnapshotTest::rawProcessCaptureRequest(
-        hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    int width, height;
-    static int num = 1;
-
-    camera3_device_t *device_handle = my_test_obj->device;
-    width = mRawSnapshotStream->width;
-    height = mRawSnapshotStream->height;
-    rawAllocateBuffers(width, height);
-    mRequest.frame_number = 0;
-    mRequest.settings = mMetaDataPtr[1];
-    mRequest.input_buffer = NULL;
-    mRequest.num_output_buffers = 1;
-    mRawSnapshotStreamBuffs.stream = mRawSnapshotStream;
-    mRawSnapshotStreamBuffs.status = 0;
-    mRawSnapshotStreamBuffs.buffer = (const native_handle_t**)&mRawCaptureHandle;
-    mRawSnapshotStreamBuffs.release_fence = -1;
-    mRawSnapshotStreamBuffs.acquire_fence = -1;
-    mRequest.output_buffers = &(mRawSnapshotStreamBuffs);
-    LOGD("Calling HAL3APP capture request ");
-    device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-}
-
-void QCameraHAL3RawSnapshotTest::rawProcessCaptureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    LOGD("\nRaw Requested Capture : %d and Received Capture : %d",
-            mRequestedCapture, fcount_captured);
-    if (mRequestedCapture == fcount_captured) {
-        LOGD("\n Raw Snapshot is running successfully Ending test");
-        fflush(stdout);
-        LOGD("\n Capture Done , Recieved Frame : %d", fcount_captured);
-        rawTestEnd(my_hal3test_obj, camid);
-    }
-    else {
-        camera3_device_t *device_handle = my_test_obj->device;
-        (mRequest.frame_number)++;
-        mRequest.settings = mMetaDataPtr[1];
-        mRequest.input_buffer = NULL;
-        mRequest.num_output_buffers = 1;
-        mRawSnapshotStreamBuffs.stream = mRawSnapshotStream;
-        mRawSnapshotStreamBuffs.buffer = (const native_handle_t**)&mRawCaptureHandle;
-        mRawSnapshotStreamBuffs.release_fence = -1;
-        mRawSnapshotStreamBuffs.acquire_fence = -1;
-        mRequest.output_buffers = &(mRawSnapshotStreamBuffs);
-        LOGD("Calling HAL3APP repeat capture request repeat ");
-        device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-    }
-}
-
-void QCameraHAL3RawSnapshotTest::rawTestEnd(
-        hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    buffer_thread_msg_t msg;
-    extern pthread_mutex_t gCamLock;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    device_handle->ops->flush(my_test_obj->device);
-    LOGD("%s Closing Camera", __func__);
-    /* Free the Allocated ION Memory */
-    ioctl(mRawCaptureMemInfo.ion_fd, ION_IOC_FREE, &mRawCaptureMemInfo.ion_handle);
-    close(mRawCaptureMemInfo.ion_fd);
-    mRawCaptureMemInfo.ion_fd = -1;
-    /* Close the Thread */
-    memset(&msg, 0, sizeof(buffer_thread_msg_t));
-    msg.stop_thread = 1;
-    write(pfd[1], &msg, sizeof(buffer_thread_msg_t));
-}
-
-
-void QCameraHAL3RawSnapshotTest::rawAllocateBuffers(int width, int height)
-{
-    mRawCaptureHandle = allocateBuffers(width, height, &mRawCaptureMemInfo);
-}
-
-bool QCameraHAL3RawSnapshotTest::rawProcessThreadCreate(int testcase_id,
-        void *(*hal3_thread_ops)(void *))
-{
-    int32_t ret = 0;
-    buffer_thread_t thread;
-    pthread_attr_t attr;
-    if (pipe(pfd) < 0) {
-        LOGE("%s: Error in creating the pipe", __func__);
-    }
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    pthread_mutex_init(&thread.mutex, NULL);
-    pthread_cond_init(&thread.cond, NULL);
-    thread.is_thread_started = 0;
-    thread.readfd = pfd[0];
-    thread.writefd = pfd[1];
-    thread.data_obj = this;
-    ret = pthread_create(&thread.td, &attr, hal3_thread_ops, &thread );
-    pthread_setname_np(thread.td, "TestApp_Thread");
-    if (ret < 0) {
-        LOGE("Failed to create status thread");
-        return 0;
-    }
-    pthread_mutex_lock(&thread.mutex);
-    while(thread.is_thread_started == 0) {
-        pthread_cond_wait(&thread.cond, &thread.mutex);
-    }
-    pthread_mutex_unlock(&thread.mutex);
-    return 1;
-}
-
-void QCameraHAL3RawSnapshotTest::captureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase)
-{
-}
-
-void * rawProcessBuffers(void *data) {
-    buffer_thread_t *thread = (buffer_thread_t*)data;
-    int32_t readfd, writefd;
-    hal3_camera_lib_test *hal3_test_handle;
-    pthread_mutex_lock(&thread->mutex);
-    thread->is_thread_started = 1;
-    readfd = thread->readfd;
-    writefd = thread->writefd;
-    QCameraHAL3RawSnapshotTest *obj;
-    obj = (QCameraHAL3RawSnapshotTest *)thread->data_obj;
-    pthread_cond_signal(&thread->cond);
-    pthread_mutex_unlock(&thread->mutex);
-    struct pollfd pollfds;
-    int32_t num_of_fds = 1;
-    bool rthread_exit = 0;
-    int32_t ready = 0;
-    pollfds.fd = readfd;
-    pollfds.events = POLLIN | POLLPRI;
-    while(!rthread_exit) {
-        ready = poll(&pollfds, (nfds_t)num_of_fds, -1);
-        if (ready > 0) {
-            if (pollfds.revents & (POLLIN | POLLPRI)) {
-                ssize_t nread = 0;
-                buffer_thread_msg_t msg;
-                nread = read(pollfds.fd, &msg, sizeof(buffer_thread_msg_t));
-                if (nread < 0) {
-                    LOGE("Unable to read the message");
-                }
-                if (msg.stop_thread) {
-                    break;
-                }
-                hal3_test_handle = RawSnapshot_CamObj_handle;
-                obj->rawProcessCaptureRequestRepeat(hal3_test_handle, 0);
-            }
-        }
-        else {
-            LOGE("Unable to poll exiting the thread");
-            break;
-        }
-    }
-    LOGD("Sensor thread is exiting");
-    close(readfd);
-    close(writefd);
-    pthread_mutex_unlock(&TestAppLock);
-    pthread_exit(0);
-    return NULL;
-}
-
-QCameraHAL3RawSnapshotTest::~QCameraHAL3RawSnapshotTest()
-{
-
-}
-
-}
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.h b/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.h
deleted file mode 100755
index c92d04a..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3RawSnapshotTest.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#ifndef __HAL3APPRAWSNAPSHOT_H__
-#define __HAL3APPRAWSNAPSHOT_H__
-
-#include "QCameraHAL3SnapshotTest.h"
-
-namespace qcamera
-{
-class QCameraHAL3RawSnapshotTest : public QCameraHAL3Test
-{
-private:
-    hal3_camtest_meminfo_t mRawCaptureMemInfo;
-    native_handle_t *mRawCaptureHandle;
-    const camera_metadata_t *mMetaDataPtr[3];
-    camera3_stream_t *mPreviewStream;
-    camera3_stream_t *mRawSnapshotStream;
-    camera3_capture_request mRequest;
-    camera3_stream_buffer_t mRawSnapshotStreamBuffs;
-    camera3_stream_configuration mRawSnapshotConfig;
-public:
-    int mRequestedCapture;
-    QCameraHAL3RawSnapshotTest(int req_cap);
-    void constructDefaultRequest(hal3_camera_test_obj_t *my_test_obj,
-            int camid);
-    void configureRawSnapshotStream(hal3_camera_test_obj_t *my_test_obj,
-            int camid, int, int );
-    void rawProcessCaptureRequest(hal3_camera_test_obj_t *my_test_obj,
-            int camid);
-    void rawProcessCaptureRequestRepeat(hal3_camera_lib_test *my_hal3test_obj,
-            int camid);
-    void initTest(hal3_camera_lib_test *handle, int testcase, int, int, int);
-    bool rawProcessThreadCreate(int testcase_id,
-            void *(*hal3_thread_ops)(void *));
-    void rawAllocateBuffers(int height, int width);
-    void rawTestEnd(hal3_camera_lib_test *my_hal3test_obj, int camid);
-    void captureRequestRepeat(hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase);
-    virtual ~QCameraHAL3RawSnapshotTest();
-};
-    void * rawProcessBuffers(void *data);
-}
-#endif
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.cpp
deleted file mode 100755
index 1ef3c54..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.cpp
+++ /dev/null
@@ -1,260 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#include "QCameraHAL3SnapshotTest.h"
-#include "QCameraHAL3MainTestContext.h"
-
-
-namespace qcamera {
-
-hal3_camera_lib_test *Snapshot_CamObj_handle;
-int fcount_captured;
-extern pthread_mutex_t TestAppLock;
-QCameraHAL3SnapshotTest::QCameraHAL3SnapshotTest(int req_cap) :
-    QCameraHAL3Test(0),
-    mCaptureHandle(NULL),
-    mSnapshotStream(NULL),
-    mRequestedCapture(req_cap)
-{
-
-}
-
-void QCameraHAL3SnapshotTest::initTest(hal3_camera_lib_test *handle,
-        int testcase, int camid, int w, int h)
-{
-    int i;
-    fcount_captured = 0;
-    Snapshot_CamObj_handle = handle;
-    configureSnapshotStream(&(handle->test_obj), camid, w, h);
-
-    constructDefaultRequest(&(handle->test_obj), 0);
-    LOGD("\n Snapshot Default stream setting read");
-
-    LOGD("\n Snapshot stream configured");
-    snapshotThreadCreate(MENU_START_CAPTURE, hal3appSnapshotProcessBuffers);
-    (mRequest.frame_number) = 0;
-    snapshotProcessCaptureRequest(&(handle->test_obj), 0);
-    LOGD("\n Snapshot Process Capture Request Sent");
-}
-
-void QCameraHAL3SnapshotTest::constructDefaultRequest(
-        hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mMetaDataPtr[0]= device_handle->ops->construct_default_request_settings(my_test_obj->device,
-            CAMERA3_TEMPLATE_PREVIEW);
-    mMetaDataPtr[1] = device_handle->ops->construct_default_request_settings(my_test_obj->device,
-            CAMERA3_TEMPLATE_STILL_CAPTURE);
-}
-
-void QCameraHAL3SnapshotTest::configureSnapshotStream(hal3_camera_test_obj_t *my_test_obj,
-        int camid, int w, int h)
-{
-    camera3_stream_t *s_stream, *p_stream;
-    camera3_device_t *device_handle = my_test_obj->device;
-    mPreviewStream = new camera3_stream_t;
-    mSnapshotStream = new camera3_stream_t;
-
-    memset(mPreviewStream, 0, sizeof(camera3_stream_t));
-    memset(mSnapshotStream, 0, sizeof(camera3_stream_t));
-    mPreviewStream = initStream(CAMERA3_STREAM_OUTPUT, camid, PREVIEW_WIDTH, PREVIEW_HEIGHT, 0,
-            HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL3_DATASPACE_UNKNOWN);
-    mSnapshotStream = initStream(CAMERA3_STREAM_OUTPUT, camid, SNAPSHOT_CAPTURE_WIDTH,
-            SNAPSHOT_CAPTURE_HEIGHT, 0, HAL_PIXEL_FORMAT_BLOB, HAL3_DATASPACE_JFIF);
-
-    mSnapshotConfig = configureStream(CAMERA3_STREAM_CONFIGURATION_NORMAL_MODE, 2);
-    mSnapshotConfig.streams[0] = mPreviewStream;
-    mSnapshotConfig.streams[1] = mSnapshotStream;
-    device_handle->ops->configure_streams(my_test_obj->device, &(mSnapshotConfig));
-}
-
-void QCameraHAL3SnapshotTest::snapshotProcessCaptureRequest(
-                hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    int width, height;
-    camera3_device_t *device_handle = my_test_obj->device;
-    width = mSnapshotStream->width;
-    height = mSnapshotStream->height;
-    snapshotAllocateBuffers(width, height);
-    mRequest.settings = mMetaDataPtr[1];
-    mRequest.input_buffer = NULL;
-    mRequest.num_output_buffers = 1;
-    mSnapshotStreamBuffs.stream = mSnapshotStream;
-    mSnapshotStreamBuffs.status = 0;
-    mSnapshotStreamBuffs.buffer = (const native_handle_t**)&mCaptureHandle;
-    mSnapshotStreamBuffs.release_fence = -1;
-    mSnapshotStreamBuffs.acquire_fence = -1;
-    mRequest.output_buffers = &(mSnapshotStreamBuffs);
-    LOGD("Calling HAL3APP capture request ");
-    device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-    (mRequest.frame_number)++;
-}
-
-void QCameraHAL3SnapshotTest::snapshotProcessCaptureRequestRepeat(
-                    hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    LOGD("\nSnapshot Requested Capture : %d and Received Capture : %d",
-            mRequestedCapture, fcount_captured);
-    if (mRequestedCapture == fcount_captured) {
-        LOGD("\n Snapshot is running successfully Ending test");
-        fflush(stdout);
-        LOGD("\n Capture Done , Recieved Frame : %d", fcount_captured);
-        snapshotTestEnd(my_hal3test_obj, camid);
-    }
-    else {
-        camera3_device_t *device_handle = my_test_obj->device;
-        mRequest.settings = mMetaDataPtr[1];
-        mRequest.input_buffer = NULL;
-        mRequest.num_output_buffers = 1;
-        mSnapshotStreamBuffs.stream = mSnapshotStream;
-        mSnapshotStreamBuffs.buffer = (const native_handle_t**)&mCaptureHandle;
-        mSnapshotStreamBuffs.release_fence = -1;
-        mSnapshotStreamBuffs.acquire_fence = -1;
-        mRequest.output_buffers = &(mSnapshotStreamBuffs);
-        LOGD("Calling HAL3APP repeat capture request repeat %d and %d",
-                mRequestedCapture, fcount_captured);
-        device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-        (mRequest.frame_number)++;
-    }
-}
-
-void QCameraHAL3SnapshotTest::snapshotTestEnd(
-        hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    buffer_thread_msg_t msg;
-    extern pthread_mutex_t gCamLock;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    device_handle->ops->flush(my_test_obj->device);
-    LOGD("%s Closing Camera", __func__);
-    ioctl(mCaptureMemInfo.ion_fd, ION_IOC_FREE, &mCaptureMemInfo.ion_handle);
-    close(mCaptureMemInfo.ion_fd);
-    mCaptureMemInfo.ion_fd = -1;
-    memset(&msg, 0, sizeof(buffer_thread_msg_t));
-    msg.stop_thread = 1;
-    write(pfd[1], &msg, sizeof(buffer_thread_msg_t));
-}
-
-void QCameraHAL3SnapshotTest::snapshotAllocateBuffers(int width, int height)
-{
-    mCaptureHandle= allocateBuffers(width, height, &mCaptureMemInfo);
-}
-
-bool QCameraHAL3SnapshotTest::snapshotThreadCreate(int testcase_id,
-                void *(*hal3_thread_ops)(void *))
-{
-    int32_t ret = 0;
-    buffer_thread_t thread;
-    pthread_attr_t attr;
-    if (pipe(pfd) < 0) {
-        LOGE("%s: Error in creating the pipe", __func__);
-    }
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    pthread_mutex_init(&thread.mutex, NULL);
-    pthread_cond_init(&thread.cond, NULL);
-    thread.is_thread_started = 0;
-    thread.readfd = pfd[0];
-    thread.writefd = pfd[1];
-    thread.data_obj = this;
-    ret = pthread_create(&thread.td, &attr, hal3_thread_ops, &thread );
-    pthread_setname_np(thread.td, "TestApp_Thread");
-    if (ret < 0) {
-        LOGE("Failed to create status thread");
-        return 0;
-    }
-    pthread_mutex_lock(&thread.mutex);
-    while(thread.is_thread_started == 0) {
-        pthread_cond_wait(&thread.cond, &thread.mutex);
-    }
-    pthread_mutex_unlock(&thread.mutex);
-    return 1;
-}
-
-void * hal3appSnapshotProcessBuffers(void *data)
-{
-    buffer_thread_t *thread = (buffer_thread_t*)data;
-    int32_t readfd, writefd;
-    hal3_camera_lib_test *hal3_test_handle;
-    pthread_mutex_lock(&thread->mutex);
-    thread->is_thread_started = 1;
-    readfd = thread->readfd;
-    writefd = thread->writefd;
-    QCameraHAL3SnapshotTest *obj;
-    obj = (QCameraHAL3SnapshotTest *)thread->data_obj;
-    pthread_cond_signal(&thread->cond);
-    pthread_mutex_unlock(&thread->mutex);
-    struct pollfd pollfds;
-    int32_t num_of_fds = 1;
-    bool sthread_exit = 0;
-    int32_t ready = 0;
-    pollfds.fd = readfd;
-    pollfds.events = POLLIN | POLLPRI;
-    while(!sthread_exit) {
-        ready = poll(&pollfds, (nfds_t)num_of_fds, -1);
-        if (ready > 0) {
-            LOGD("Got some events");
-            if (pollfds.revents & (POLLIN | POLLPRI)) {
-                ssize_t nread = 0;
-                buffer_thread_msg_t msg;
-                nread = read(pollfds.fd, &msg, sizeof(buffer_thread_msg_t));
-                if (nread < 0) {
-                    LOGE("Unable to read the message");
-                }
-                if (msg.stop_thread) {
-                    break;
-                }
-                hal3_test_handle = Snapshot_CamObj_handle;
-                obj->snapshotProcessCaptureRequestRepeat(hal3_test_handle, 0);
-            }
-        }
-        else {
-            LOGE("Unable to poll exiting the thread");
-            break;
-        }
-    }
-    LOGD("Sensor thread is exiting");
-    close(readfd);
-    close(writefd);
-    pthread_mutex_unlock(&TestAppLock);
-    pthread_exit(0);
-    return NULL;
-}
-
-void QCameraHAL3SnapshotTest::captureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase)
-{
-}
-
-QCameraHAL3SnapshotTest::~QCameraHAL3SnapshotTest()
-{
-
-}
-
-}
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.h b/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.h
deleted file mode 100755
index e52a21e..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3SnapshotTest.h
+++ /dev/null
@@ -1,69 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3APPSNAPSHOT_H__
-#define __HAL3APPSNAPSHOT_H__
-
-#include "QCameraHAL3VideoTest.h"
-
-namespace qcamera
-{
-class QCameraHAL3SnapshotTest : public QCameraHAL3Test
-{
-private:
-    hal3_camtest_meminfo_t mCaptureMemInfo;
-    native_handle_t *mCaptureHandle;
-    const camera_metadata_t *mMetaDataPtr[3];
-    camera3_stream_t *mPreviewStream;
-    camera3_stream_t *mSnapshotStream;
-    camera3_capture_request mRequest;
-    camera3_stream_buffer_t mSnapshotStreamBuffs;
-    camera3_stream_configuration mSnapshotConfig;
-public:
-    int mRequestedCapture;
-    QCameraHAL3SnapshotTest(int req_cap);
-    void constructDefaultRequest(hal3_camera_test_obj_t *, int );
-    void configureSnapshotStream(hal3_camera_test_obj_t *, int,
-            int w, int h);
-    void snapshotProcessCaptureRequest(hal3_camera_test_obj_t *my_test_obj,
-            int camid);
-    void snapshotAllocateBuffers(int, int );
-    void initTest(hal3_camera_lib_test *my_test_obj,
-            int testcase, int camid, int w, int h);
-    bool snapshotThreadCreate(int testcase_id, void * (*hal3_thread_ops)(void *));
-    void snapshotProcessCaptureRequestRepeat(hal3_camera_lib_test *my_hal3test_obj,
-            int camid);
-    void captureRequestRepeat(hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase);
-    void snapshotTestEnd(hal3_camera_lib_test *my_hal3test_obj, int camid);
-    virtual ~QCameraHAL3SnapshotTest();
-};
-
-    void * hal3appSnapshotProcessBuffers(void *data);
-}
-
-#endif
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3Test.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3Test.cpp
deleted file mode 100755
index fc27a34..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3Test.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-
-#include "QCameraHAL3Test.h"
-#include "QCameraHAL3Base.h"
-
-namespace qcamera {
-hal3_camera_lib_test *CamObj_handle;
-extern bool thread_exit;
-extern int test_case_end;
-buffer_thread_t thread;
-extern pthread_cond_t mRequestAppCond;
-extern pthread_mutex_t TestAppLock, mCaptureRequestLock;
-
-camera3_stream_t *QCameraHAL3Test::initStream(int streamtype,
-        int camid, int w, int h, int usage, int format, int dataspace)
-{
-    requested_stream =  new camera3_stream_t;
-    memset(requested_stream, 0, sizeof(camera3_stream_t));
-
-    requested_stream->stream_type = streamtype;
-    requested_stream->width = w;
-    requested_stream->height = h;
-    requested_stream->format = format;
-    requested_stream->usage = usage;
-    requested_stream->data_space = (android_dataspace_t)dataspace;
-    requested_stream->rotation = CAMERA3_STREAM_ROTATION_0;
-    return requested_stream;
-}
-
-QCameraHAL3Test::QCameraHAL3Test(int id)
-{
-    mCamId = id;
-}
-
-camera3_stream_configuration QCameraHAL3Test::configureStream(
-        int opmode, int num_streams)
-{
-    int i;
-    camera3_stream_configuration requested_config;
-    requested_config.operation_mode  = opmode;
-    requested_config.num_streams = num_streams;
-    requested_config.streams = new camera3_stream_t *[num_streams];
-    return requested_config;
-}
-
-
-camera3_stream_buffer_t QCameraHAL3Test::hal3appGetStreamBuffs(camera3_stream_t *req_stream)
-{
-    camera3_stream_buffer_t stream_buffs;
-    stream_buffs.stream = req_stream;
-    stream_buffs.release_fence = -1;
-    stream_buffs.acquire_fence = -1;
-    return stream_buffs;
-}
-
-camera3_capture_request QCameraHAL3Test::hal3appGetRequestSettings(
-        camera3_stream_buffer_t *stream_buffs, int num_buffer)
-{
-    camera3_capture_request request_settings;
-    request_settings.input_buffer = NULL;
-    request_settings.num_output_buffers = 1;
-    request_settings.output_buffers = stream_buffs;
-    return request_settings;
-}
-
-native_handle_t *QCameraHAL3Test::allocateBuffers(int width, int height,
-        hal3_camtest_meminfo_t *req_meminfo)
-{
-    struct ion_handle_data handle_data;
-    struct ion_allocation_data alloc;
-    struct ion_fd_data ion_info_fd;
-    int main_ion_fd = -1, rc;
-    size_t buf_size;
-    void *data = NULL;
-    native_handle_t *nh_test;
-    main_ion_fd = open("/dev/ion", O_RDONLY);
-    if (main_ion_fd <= 0) {
-        LOGE("Ion dev open failed %s\n", strerror(errno));
-        return NULL;
-    }
-    memset(&alloc, 0, sizeof(alloc));
-    buf_size = (size_t)(width * height *2);
-    alloc.len = (size_t)(buf_size);
-    alloc.len = (alloc.len + 4095U) & (~4095U);
-    alloc.align = 4096;
-    alloc.flags = ION_FLAG_CACHED;
-    alloc.heap_id_mask = ION_HEAP(ION_SYSTEM_HEAP_ID);
-    rc = ioctl(main_ion_fd, ION_IOC_ALLOC, &alloc);
-    if (rc < 0) {
-        LOGE("ION allocation failed %s with rc = %d \n", strerror(errno), rc);
-        return NULL;
-    }
-    memset(&ion_info_fd, 0, sizeof(ion_info_fd));
-    ion_info_fd.handle = alloc.handle;
-    rc = ioctl(main_ion_fd, ION_IOC_SHARE, &ion_info_fd);
-    if (rc < 0) {
-        LOGE("ION map failed %s\n", strerror(errno));
-        return NULL;
-    }
-    req_meminfo->ion_fd = main_ion_fd;
-    req_meminfo->ion_handle = ion_info_fd.handle;
-    LOGD("%s ION FD %d len %d\n", __func__, ion_info_fd.fd, alloc.len);
-    nh_test = native_handle_create(2, 4);
-    nh_test->data[0] = ion_info_fd.fd;
-    nh_test->data[1] = 0;
-    nh_test->data[2] = 0;
-    nh_test->data[3] = 0;
-    nh_test->data[4] = alloc.len;
-    nh_test->data[5] = 0;
-    return nh_test;
-}
-
-void QCameraHAL3Test::captureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase)
-{
-
-}
-
-bool QCameraHAL3Test::processThreadCreate(
-        void *obj, int testcase)
-{
-    int32_t ret = 0;
-    pthread_attr_t attr;
-    if (pipe(pfd) < 0) {
-        LOGE("%s: Error in creating the pipe", __func__);
-    }
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-    pthread_mutex_init(&thread.mutex, NULL);
-    pthread_cond_init(&thread.cond, NULL);
-    pthread_cond_init(&mRequestAppCond, NULL);
-    thread.is_thread_started = 0;
-    thread.readfd = pfd[0];
-    thread.writefd = pfd[1];
-    thread.data_obj = obj;
-    thread.testcase = testcase;
-    pthread_mutex_lock(&thread.mutex);
-    ret = pthread_create(&thread.td, &attr, processBuffers, &thread );
-    pthread_setname_np(thread.td, "TestApp_Thread");
-    if (ret < 0) {
-        LOGE("Failed to create status thread");
-        return 0;
-    }
-    pthread_mutex_unlock(&thread.mutex);
-    return 1;
-}
-
-void * processBuffers(void *data) {
-    buffer_thread_t *thread = (buffer_thread_t*)data;
-    int32_t readfd, writefd;
-    int testcase;
-    hal3_camera_lib_test *hal3_test_handle;
-    struct timespec ts1;
-    thread->is_thread_started = 1;
-    readfd = thread->readfd;
-    writefd = thread->writefd;
-    testcase = thread->testcase;
-    QCameraHAL3Test *obj;
-    obj = (QCameraHAL3Test *)thread->data_obj;
-    struct pollfd pollfds;
-    int32_t num_of_fds = 1;
-    int32_t ready = 0;
-    while(!thread_exit) {
-        pthread_mutex_lock(&thread->mutex);
-        clock_gettime(CLOCK_REALTIME, &ts1);
-        ts1.tv_nsec += 10000000L;
-        pthread_cond_timedwait(&mRequestAppCond, &thread->mutex, &ts1);
-        pthread_mutex_unlock(&thread->mutex);
-        hal3_test_handle = CamObj_handle;
-        if (test_case_end == 0) {
-            obj->captureRequestRepeat(hal3_test_handle, 0, testcase);
-        }
-    }
-    LOGD("Sensor thread is exiting");
-    close(readfd);
-    close(writefd);
-    pthread_cond_destroy(&mRequestAppCond);
-    pthread_mutex_unlock(&TestAppLock);
-    pthread_exit(0);
-    return NULL;
-}
-
-QCameraHAL3Test::~QCameraHAL3Test()
-{
-
-}
-
-}
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3Test.h b/camera/QCamera2/HAL3/test/QCameraHAL3Test.h
deleted file mode 100755
index 8582681..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3Test.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3APPTESTINIT_H__
-#define __HAL3APPTESTINIT_H__
-
-#include "QCameraHAL3MainTestContext.h"
-#include "QCameraHAL3Base.h"
-
-namespace qcamera {
-
-class QCameraHAL3Test
-{
-    int mCamId;
-public:
-    QCameraHAL3Test(int cameraIndex);
-    camera3_stream_t *requested_stream;
-    camera3_stream_t *initStream(int streamtype,
-            int camid, int w, int h, int format,int usage,int dataspace);
-
-    camera3_stream_configuration configureStream(
-            int opmode, int num_streams);
-    virtual void captureRequestRepeat(hal3_camera_lib_test *, int, int);
-    camera_metadata_t* hal3appGetDefaultRequest(int type);
-
-    camera3_capture_request hal3appGetRequestSettings(
-            camera3_stream_buffer_t *stream_buffs, int num_buffer);
-    camera3_stream_buffer_t hal3appGetStreamBuffs(camera3_stream_t *req_stream);
-
-    native_handle_t *allocateBuffers(int width, int height,
-            hal3_camtest_meminfo_t *req_meminfo);
-    bool processThreadCreate(void *obj, int testcase);
-    virtual ~QCameraHAL3Test();
-};
-
-    void * processBuffers(void *data);
-}
-#endif
\ No newline at end of file
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.cpp b/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.cpp
deleted file mode 100755
index bca887c..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.cpp
+++ /dev/null
@@ -1,211 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-#include "QCameraHAL3VideoTest.h"
-#include "QCameraHAL3MainTestContext.h"
-
-namespace qcamera {
-
-extern hal3_camera_lib_test *CamObj_handle;
-buffer_thread_t Video_thread;
-int video_req_sent;
-extern pthread_cond_t mRequestAppCond;
-
-extern int test_case_end;
-extern bool thread_exit;
-extern std::list<uint32_t> VideoQueue;
-int video_buffer_allocated;
-extern pthread_mutex_t TestAppLock, mCaptureRequestLock;
-extern int snapshot_buffer;
-
-
-QCameraHAL3VideoTest::QCameraHAL3VideoTest(int camid) :
-    QCameraHAL3Test(0),
-    mVideoHandle(NULL),
-    mCaptureHandle(NULL),
-    mVideoStream(NULL)
-{
-
-}
-
-void QCameraHAL3VideoTest::initTest(hal3_camera_lib_test *handle,
-        int testcase, int camid, int w, int h)
-{
-    int i;
-    CamObj_handle = handle; thread_exit = 0;
-    test_case_end = 0;
-    LOGD("\n buffer thread created");
-    configureVideoStream(&(handle->test_obj), camid, w, h);
-    LOGD("\n video stream configured");
-    constructDefaultRequest(&(handle->test_obj), camid);
-    LOGD("pipeline_depth is %d", mPipelineDepthVideo);
-    mVideoHandle = new native_handle_t *[mPipelineDepthVideo];
-    for (i = 0; i < mPipelineDepthVideo; i++) {
-        mVideoHandle[i] = new native_handle_t;
-    }
-
-    for (i = 0, video_req_sent = 1; i < mPipelineDepthVideo; i++, video_req_sent++) {
-        vidoeAllocateBuffers(width, height, i);
-        VideoQueue.push_back(i);
-    }
-    LOGD(" Request Number is : %d ",mRequest.frame_number);
-    mRequest.frame_number = 0;
-    videoProcessThreadCreate(handle);
-}
-
-
-void QCameraHAL3VideoTest::snapshotCaptureRequest(hal3_camera_lib_test *handle,
-        int testcase, int camid, int w, int h)
-{
-
-    captureRequestRepeat(handle, camid, MENU_START_CAPTURE);
-    pthread_mutex_unlock(&mCaptureRequestLock);
-}
-
-
-void QCameraHAL3VideoTest::configureVideoStream(hal3_camera_test_obj_t *my_test_obj,
-        int camid, int w, int h)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mVideoStream = new camera3_stream_t;
-    memset(mVideoStream, 0, sizeof(camera3_stream_t));
-    mVideoStream = initStream(CAMERA3_STREAM_OUTPUT, camid, w, h, FLAGS_VIDEO_ENCODER,
-            HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED, HAL3_DATASPACE_UNKNOWN);
-    mVideoConfig = configureStream(CAMERA3_STREAM_CONFIGURATION_NORMAL_MODE, 1);
-    mVideoConfig.streams[0] = mVideoStream;
-
-    device_handle->ops->configure_streams(my_test_obj->device, &(mVideoConfig));
-    mPipelineDepthVideo = mVideoConfig.streams[0]->max_buffers;
-    video_buffer_allocated = mPipelineDepthVideo;
-}
-
-void QCameraHAL3VideoTest::constructDefaultRequest(
-        hal3_camera_test_obj_t *my_test_obj, int camid)
-{
-    camera3_device_t *device_handle = my_test_obj->device;
-    mMetaDataPtr[0] = device_handle->ops->construct_default_request_settings(
-            my_test_obj->device, CAMERA3_TEMPLATE_VIDEO_RECORD);
-    mMetaDataPtr[1] = device_handle->ops->construct_default_request_settings(my_test_obj->device,
-            CAMERA3_TEMPLATE_STILL_CAPTURE);
-}
-
-
-
-void QCameraHAL3VideoTest::captureRequestRepeat(
-        hal3_camera_lib_test *my_hal3test_obj, int camid, int testcase)
-{
-    struct timeval current_time;
-    int num1, num2;
-    double total_elapsedTime;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    if (testcase == MENU_START_VIDEO) {
-        if (VideoQueue.empty()) {
-            LOGE("no Video buffer");
-        }
-        else {
-            if (test_case_end == 0) {
-                LOGD(" Request Number is : %d ", mRequest.frame_number);
-                pthread_mutex_lock(&mCaptureRequestLock);
-                num2 = VideoQueue.front();
-                VideoQueue.pop_front();
-                num1 = mRequest.frame_number;
-                if (num1 < 2) {
-                    (mRequest).settings = mMetaDataPtr[0];
-                }
-                else {
-                    (mRequest).settings = NULL;
-                }
-                (mRequest).input_buffer = NULL;
-                (mRequest).num_output_buffers = 1;
-                mVideoStreamBuffs.stream = mVideoStream;
-                mVideoStreamBuffs.status = 0;
-                mVideoStreamBuffs.buffer =
-                        (const native_handle_t**)&mVideoHandle[num2];
-                mVideoStreamBuffs.release_fence = -1;
-                mVideoStreamBuffs.acquire_fence = -1;
-                (mRequest).output_buffers = &(mVideoStreamBuffs);
-                LOGD("Calling HAL3APP repeat capture request %d and %d and free buffer :%d "
-                        , num1, num2, VideoQueue.size());
-                device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-                        (mRequest.frame_number)++;
-                pthread_mutex_unlock(&mCaptureRequestLock);
-            }
-        }
-    }
-    else {
-        snapshot_buffer = mRequest.frame_number;
-        (mRequest).settings = mMetaDataPtr[1];
-        mSnapshotStreamBuffs = hal3appGetStreamBuffs(mSnapshotStream);
-        mSnapshotStreamBuffs.buffer = (const native_handle_t**)&mCaptureHandle;
-        mRequest = hal3appGetRequestSettings(&mSnapshotStreamBuffs, 1);
-        LOGD("Calling snap HAL3APP repeat capture request repeat %d  ", snapshot_buffer);
-        device_handle->ops->process_capture_request(my_test_obj->device, &(mRequest));
-        (mRequest.frame_number)++;
-    }
-}
-
-void QCameraHAL3VideoTest::videoTestEnd(
-                    hal3_camera_lib_test *my_hal3test_obj, int camid)
-{
-    buffer_thread_msg_t msg;
-    test_case_end = 1;
-    hal3_camera_test_obj_t *my_test_obj = &(my_hal3test_obj->test_obj);
-    camera3_device_t *device_handle = my_test_obj->device;
-    device_handle->ops->flush(my_test_obj->device);
-    LOGD("%s Closing Camera", __func__);
-    ioctl(mVideoMeminfo.ion_fd, ION_IOC_FREE, &mVideoMeminfo.ion_handle);
-    close(mVideoMeminfo.ion_fd);
-    mVideoMeminfo.ion_fd = -1;
-    LOGD("%s Closing thread", __func__);
-    thread_exit = 1;
-}
-
-void QCameraHAL3VideoTest::vidoeAllocateBuffers(int height, int width, int num)
-{
-    mVideoHandle[num] = allocateBuffers(width, height, &mVideoMeminfo);
-}
-
-void QCameraHAL3VideoTest::snapshotAllocateBuffers(int width, int height)
-{
-    mCaptureHandle = allocateBuffers(width, height, &mCaptureMemInfo);
-}
-
-bool QCameraHAL3VideoTest::videoProcessThreadCreate(
-                    hal3_camera_lib_test *handle) {
-    processThreadCreate(this, MENU_START_VIDEO);
-    return 1;
-}
-
-QCameraHAL3VideoTest::~QCameraHAL3VideoTest()
-{
-
-}
-
-}
diff --git a/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.h b/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.h
deleted file mode 100755
index b4d609a..0000000
--- a/camera/QCamera2/HAL3/test/QCameraHAL3VideoTest.h
+++ /dev/null
@@ -1,84 +0,0 @@
-/* Copyright (c) 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-#ifndef __HAL3APPVIDEOTEST_H__
-#define __HAL3APPVIDEOTEST_H__
-
-#include "QCameraHAL3Base.h"
-#include "QCameraHAL3Test.h"
-
-
-namespace qcamera {
-
-
-class QCameraHAL3VideoTest : public QCameraHAL3Test
-{
-
-private:
-    hal3_camtest_meminfo_t mVideoMeminfo;
-    native_handle_t **mVideoHandle;
-    hal3_camtest_meminfo_t mCaptureMemInfo;
-    native_handle_t *mCaptureHandle;
-    const camera_metadata_t *mMetaDataPtr[3];
-    camera3_stream_t *mVideoStream;
-    camera3_stream_t *mSnapshotStream;
-    camera3_capture_request mRequest;
-    camera3_stream_buffer_t mVideoStreamBuffs;
-    camera3_stream_buffer_t mSnapshotStreamBuffs;
-    camera3_stream_configuration mVideoConfig;
-public:
-    int width;
-    int height;
-    int nobuffer;
-    int mPipelineDepthVideo;
-
-    QCameraHAL3VideoTest(int cameraIndex);
-
-    void configureVideoStream(hal3_camera_test_obj_t *,
-            int, int, int);
-    void snapshotCaptureRequest(hal3_camera_lib_test *handle,int testcase,
-            int camid, int w, int h);
-
-    void constructDefaultRequest(hal3_camera_test_obj_t *,
-            int);
-
-    void captureRequestRepeat(hal3_camera_lib_test *, int, int);
-    void initTest(hal3_camera_lib_test *handle, int testcase, int camid,
-            int w, int h);
-    void vidoeAllocateBuffers(int, int, int);
-
-    bool videoProcessThreadCreate(hal3_camera_lib_test *);
-    void videoTestEnd(hal3_camera_lib_test *my_hal3test_obj, int camid);
-    void snapshotAllocateBuffers(int, int );
-    virtual ~QCameraHAL3VideoTest();
-};
-
-    void * hal3appVideoProcessBuffers(void *);
-}
-
-#endif
diff --git a/camera/QCamera2/stack/Android.mk b/camera/QCamera2/stack/Android.mk
index a357417..bd1c3e6 100644
--- a/camera/QCamera2/stack/Android.mk
+++ b/camera/QCamera2/stack/Android.mk
@@ -1,5 +1,3 @@
 LOCAL_PATH:= $(call my-dir)
 include $(LOCAL_PATH)/mm-camera-interface/Android.mk
 include $(LOCAL_PATH)/mm-jpeg-interface/Android.mk
-include $(LOCAL_PATH)/mm-jpeg-interface/test/Android.mk
-include $(LOCAL_PATH)/mm-camera-test/Android.mk
diff --git a/camera/QCamera2/stack/mm-camera-test/Android.mk b/camera/QCamera2/stack/mm-camera-test/Android.mk
deleted file mode 100644
index 54da261..0000000
--- a/camera/QCamera2/stack/mm-camera-test/Android.mk
+++ /dev/null
@@ -1,195 +0,0 @@
-OLD_LOCAL_PATH := $(LOCAL_PATH)
-LOCAL_PATH:=$(call my-dir)
-
-# Build command line test app: mm-qcamera-app
-include $(LOCAL_PATH)/../../../common.mk
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS:= \
-        -DAMSS_VERSION=$(AMSS_VERSION) \
-        $(mmcamera_debug_defines) \
-        $(mmcamera_debug_cflags) \
-        $(USE_SERVER_TREE)
-
-ifeq ($(strip $(TARGET_USES_ION)),true)
-LOCAL_CFLAGS += -DUSE_ION
-endif
-
-LOCAL_CFLAGS += -D_ANDROID_ -DQCAMERA_REDEFINE_LOG
-
-# System header file path prefix
-LOCAL_CFLAGS += -DSYSTEM_HEADER_PREFIX=sys
-
-LOCAL_SRC_FILES:= \
-        src/mm_qcamera_main_menu.c \
-        src/mm_qcamera_app.c \
-        src/mm_qcamera_unit_test.c \
-        src/mm_qcamera_video.c \
-        src/mm_qcamera_preview.c \
-        src/mm_qcamera_snapshot.c \
-        src/mm_qcamera_rdi.c \
-        src/mm_qcamera_reprocess.c\
-        src/mm_qcamera_queue.c \
-        src/mm_qcamera_socket.c \
-        src/mm_qcamera_commands.c
-#        src/mm_qcamera_dual_test.c \
-
-LOCAL_C_INCLUDES:=$(LOCAL_PATH)/inc
-LOCAL_C_INCLUDES+= \
-        frameworks/native/include/media/openmax \
-        $(LOCAL_PATH)/../common \
-        $(LOCAL_PATH)/../mm-camera-interface/inc \
-        $(LOCAL_PATH)/../../../mm-image-codec/qexif \
-        $(LOCAL_PATH)/../../../mm-image-codec/qomx_core
-
-LOCAL_C_INCLUDES+= $(kernel_includes)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
-
-LOCAL_CFLAGS += -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
-ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(filter $(TARGET_BOARD_PLATFORM), apq8084 msm8084),$(TARGET_BOARD_PLATFORM))
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8994)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8916 msm8952 msm8937 msm8953)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8226)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8610)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8960)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-else ifneq (,$(filter msm8660,$(TARGET_BOARD_PLATFORM)))
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID # EBI
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-else
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=GRALLOC_USAGE_PRIVATE_UNCACHED #uncached
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_CAMERA_HEAP_ID
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-endif
-LOCAL_CFLAGS += -Wall -Wextra -Werror
-
-LOCAL_SHARED_LIBRARIES:= \
-         libcutils libdl libmmcamera_interface
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-
-LOCAL_MODULE:= mm-qcamera-app
-LOCAL_VENDOR_MODULE := true
-
-include $(BUILD_EXECUTABLE)
-
-# Build tuning library
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS:= \
-        -DAMSS_VERSION=$(AMSS_VERSION) \
-        $(mmcamera_debug_defines) \
-        $(mmcamera_debug_cflags) \
-        $(USE_SERVER_TREE)
-
-ifeq ($(strip $(TARGET_USES_ION)),true)
-LOCAL_CFLAGS += -DUSE_ION
-endif
-
-LOCAL_CFLAGS += -D_ANDROID_ -DQCAMERA_REDEFINE_LOG
-
-# System header file path prefix
-LOCAL_CFLAGS += -DSYSTEM_HEADER_PREFIX=sys
-
-LOCAL_SRC_FILES:= \
-        src/mm_qcamera_main_menu.c \
-        src/mm_qcamera_app.c \
-        src/mm_qcamera_unit_test.c \
-        src/mm_qcamera_video.c \
-        src/mm_qcamera_preview.c \
-        src/mm_qcamera_snapshot.c \
-        src/mm_qcamera_rdi.c \
-        src/mm_qcamera_reprocess.c\
-        src/mm_qcamera_queue.c \
-        src/mm_qcamera_socket.c \
-        src/mm_qcamera_commands.c
-#        src/mm_qcamera_dual_test.c \
-
-LOCAL_C_INCLUDES:=$(LOCAL_PATH)/inc
-LOCAL_C_INCLUDES+= \
-        frameworks/native/include/media/openmax \
-        $(LOCAL_PATH)/../common \
-        $(LOCAL_PATH)/../mm-camera-interface/inc \
-        $(LOCAL_PATH)/../../../mm-image-codec/qexif \
-        $(LOCAL_PATH)/../../../mm-image-codec/qomx_core
-
-LOCAL_C_INCLUDES+= $(kernel_includes)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
-
-LOCAL_CFLAGS += -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
-ifeq ($(TARGET_BOARD_PLATFORM),msm8974)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(filter $(TARGET_BOARD_PLATFORM), apq8084 msm8084),$(TARGET_BOARD_PLATFORM))
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8994)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8916 msm8952 msm8937 msm8953)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8226)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8610)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=9
-else ifeq ($(TARGET_BOARD_PLATFORM),msm8960)
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-else ifneq (,$(filter msm8660,$(TARGET_BOARD_PLATFORM)))
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_IOMMU_HEAP_ID # EBI
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=0
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-else
-        LOCAL_CFLAGS += -DCAMERA_GRALLOC_CACHING_ID=GRALLOC_USAGE_PRIVATE_UNCACHED #uncached
-        LOCAL_CFLAGS += -DCAMERA_ION_FALLBACK_HEAP_ID=ION_CAMERA_HEAP_ID
-        LOCAL_CFLAGS += -DNUM_RECORDING_BUFFERS=5
-endif
-LOCAL_CFLAGS += -Wall -Wextra -Werror
-
-LOCAL_SHARED_LIBRARIES:= \
-         libcutils libdl libmmcamera_interface
-
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-
-LOCAL_MODULE:= libmm-qcamera
-LOCAL_VENDOR_MODULE := true
-
-include $(BUILD_SHARED_LIBRARY)
-
-LOCAL_PATH := $(OLD_LOCAL_PATH)
diff --git a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h b/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
deleted file mode 100644
index a78a332..0000000
--- a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_app.h
+++ /dev/null
@@ -1,535 +0,0 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MM_QCAMERA_APP_H__
-#define __MM_QCAMERA_APP_H__
-
-// System dependencies
-#include <pthread.h>
-#include <linux/msm_ion.h>
-#include <linux/msm_mdp.h>
-
-// Camera dependencies
-#include "mm_camera_interface.h"
-#include "mm_jpeg_interface.h"
-#include "mm_qcamera_socket.h"
-
-#define MM_QCAMERA_APP_INTERATION 1
-
-#define MM_APP_MAX_DUMP_FRAME_NUM 1000
-
-#define PREVIEW_BUF_NUM 7
-#define SNAPSHOT_BUF_NUM 10
-#define VIDEO_BUF_NUM 7
-#define ISP_PIX_BUF_NUM 9
-#define STATS_BUF_NUM 4
-#define RDI_BUF_NUM 8
-#define CAPTURE_BUF_NUM 5
-
-#define DEFAULT_PREVIEW_FORMAT    CAM_FORMAT_YUV_420_NV21
-#define DEFAULT_PREVIEW_WIDTH     1280
-#define DEFAULT_PREVIEW_HEIGHT    960
-#define DEFAULT_PREVIEW_PADDING   CAM_PAD_TO_WORD
-#define DEFAULT_VIDEO_FORMAT      CAM_FORMAT_YUV_420_NV12
-#define DEFAULT_VIDEO_WIDTH       800
-#define DEFAULT_VIDEO_HEIGHT      480
-#define DEFAULT_VIDEO_PADDING     CAM_PAD_TO_2K
-#define DEFAULT_SNAPSHOT_FORMAT   CAM_FORMAT_YUV_420_NV21
-#define DEFAULT_RAW_FORMAT        CAM_FORMAT_BAYER_MIPI_RAW_10BPP_GBRG
-
-#define DEFAULT_SNAPSHOT_WIDTH    4160
-#define DEFAULT_SNAPSHOT_HEIGHT   3120
-#define DEFAULT_SNAPSHOT_PADDING  CAM_PAD_TO_WORD
-
-#define DEFAULT_OV_FORMAT         MDP_Y_CRCB_H2V2
-#define DEFAULT_OV_FORMAT_BPP     3/2
-#define DEFAULT_CAMERA_FORMAT_BPP 3/2
-#define FB_PATH                   "/dev/graphics/fb0"
-#define BACKLIGHT_CONTROL         "/sys/class/leds/lcd-backlight/brightness"
-#define BACKLIGHT_LEVEL           "205"
-
-#define ENABLE_REPROCESSING       1
-
-#define INVALID_KEY_PRESS 0
-#define BASE_OFFSET  ('Z' - 'A' + 1)
-#define BASE_OFFSET_NUM  ('Z' - 'A' + 2)
-
-#ifndef TRUE
-#define TRUE 1
-#endif
-
-#ifndef FALSE
-#define FALSE 0
-#endif
-
-typedef enum {
-    TUNE_CMD_INIT,
-    TUNE_CMD_GET_LIST,
-    TUNE_CMD_GET_PARAMS,
-    TUNE_CMD_SET_PARAMS,
-    TUNE_CMD_MISC,
-    TUNE_CMD_DEINIT,
-} mm_camera_tune_cmd_t;
-
-typedef enum {
-    TUNE_PREVCMD_INIT,
-    TUNE_PREVCMD_SETDIM,
-    TUNE_PREVCMD_GETINFO,
-    TUNE_PREVCMD_GETCHUNKSIZE,
-    TUNE_PREVCMD_GETFRAME,
-    TUNE_PREVCMD_UNSUPPORTED,
-    TUNE_PREVCMD_DEINIT,
-} mm_camera_tune_prevcmd_t;
-
-typedef void (*cam_stream_user_cb) (mm_camera_buf_def_t *frame);
-typedef void (*prev_callback) (mm_camera_buf_def_t *preview_frame);
-
-
-typedef struct {
-  char *send_buf;
-  uint32_t send_len;
-  void *next;
-} eztune_prevcmd_rsp;
-
-typedef struct {
-    int (*command_process) (void *recv, mm_camera_tune_cmd_t cmd,
-      void *param, char *send_buf, uint32_t send_len);
-    int (*prevcommand_process) (void *recv, mm_camera_tune_prevcmd_t cmd,
-      void *param, char **send_buf, uint32_t *send_len);
-    void (*prevframe_callback) (mm_camera_buf_def_t *preview_frame);
-} mm_camera_tune_func_t;
-
-typedef struct {
-    mm_camera_tune_func_t *func_tbl;
-    void *lib_handle;
-}mm_camera_tuning_lib_params_t;
-
-typedef enum {
-    MM_CAMERA_OK,
-    MM_CAMERA_E_GENERAL,
-    MM_CAMERA_E_NO_MEMORY,
-    MM_CAMERA_E_NOT_SUPPORTED,
-    MM_CAMERA_E_INVALID_INPUT,
-    MM_CAMERA_E_INVALID_OPERATION, /* 5 */
-    MM_CAMERA_E_ENCODE,
-    MM_CAMERA_E_BUFFER_REG,
-    MM_CAMERA_E_PMEM_ALLOC,
-    MM_CAMERA_E_CAPTURE_FAILED,
-    MM_CAMERA_E_CAPTURE_TIMEOUT, /* 10 */
-} mm_camera_status_type_t;
-
-typedef enum {
-    MM_CHANNEL_TYPE_ZSL,      /* preview, and snapshot main */
-    MM_CHANNEL_TYPE_CAPTURE,  /* snapshot main, and postview */
-    MM_CHANNEL_TYPE_PREVIEW,  /* preview only */
-    MM_CHANNEL_TYPE_SNAPSHOT, /* snapshot main only */
-    MM_CHANNEL_TYPE_VIDEO,    /* video only */
-    MM_CHANNEL_TYPE_RDI,      /* rdi only */
-    MM_CHANNEL_TYPE_REPROCESS,/* offline reprocess */
-    MM_CHANNEL_TYPE_MAX
-} mm_camera_channel_type_t;
-
-typedef struct {
-    int                     fd;
-    int                     main_ion_fd;
-    ion_user_handle_t       handle;
-    size_t                  size;
-    parm_buffer_t          *data;
-} mm_camera_app_meminfo_t;
-
-typedef struct {
-    mm_camera_buf_def_t buf;
-    mm_camera_app_meminfo_t mem_info;
-} mm_camera_app_buf_t;
-
-typedef struct {
-    uint32_t s_id;
-    mm_camera_stream_config_t s_config;
-    cam_frame_len_offset_t offset;
-    uint8_t num_of_bufs;
-    uint32_t multipleOf;
-    mm_camera_app_buf_t s_bufs[MM_CAMERA_MAX_NUM_FRAMES];
-    mm_camera_app_buf_t s_info_buf;
-} mm_camera_stream_t;
-
-typedef struct {
-    uint32_t ch_id;
-    uint8_t num_streams;
-    mm_camera_stream_t streams[MAX_STREAM_NUM_IN_BUNDLE];
-} mm_camera_channel_t;
-
-typedef void (*release_data_fn)(void* data, void *user_data);
-
-typedef struct {
-    struct cam_list list;
-    void* data;
-} camera_q_node;
-
-typedef struct {
-    camera_q_node m_head;
-    int m_size;
-    pthread_mutex_t m_lock;
-    release_data_fn m_dataFn;
-    void * m_userData;
-} mm_camera_queue_t;
-
-typedef struct {
-    uint16_t user_input_display_width;
-    uint16_t user_input_display_height;
-} USER_INPUT_DISPLAY_T;
-
-typedef struct {
-    mm_camera_vtbl_t *cam;
-    uint8_t num_channels;
-    mm_camera_channel_t channels[MM_CHANNEL_TYPE_MAX];
-    mm_jpeg_ops_t jpeg_ops;
-    uint32_t jpeg_hdl;
-    mm_camera_app_buf_t cap_buf;
-    mm_camera_app_buf_t parm_buf;
-
-    uint32_t current_jpeg_sess_id;
-    mm_camera_super_buf_t* current_job_frames;
-    uint32_t current_job_id;
-    mm_camera_app_buf_t jpeg_buf;
-
-    int fb_fd;
-    struct fb_var_screeninfo vinfo;
-    struct mdp_overlay data_overlay;
-    uint32_t slice_size;
-    uint32_t buffer_width, buffer_height;
-    uint32_t buffer_size;
-    cam_format_t buffer_format;
-    uint32_t frame_size;
-    uint32_t frame_count;
-    int encodeJpeg;
-    int zsl_enabled;
-    int8_t focus_supported;
-    cam_stream_user_cb user_preview_cb;
-    cam_stream_user_cb user_metadata_cb;
-    parm_buffer_t *params_buffer;
-    USER_INPUT_DISPLAY_T preview_resolution;
-
-    //Reprocess params&stream
-    int8_t enable_reproc;
-    int32_t reproc_sharpness;
-    cam_denoise_param_t reproc_wnr;
-    int8_t enable_CAC;
-    int8_t enable_EZTune;
-    mm_camera_queue_t pp_frames;
-    mm_camera_stream_t *reproc_stream;
-    metadata_buffer_t *metadata;
-    int8_t is_chromatix_reload;
-} mm_camera_test_obj_t;
-
-typedef struct {
-  void *ptr;
-  void* ptr_jpeg;
-
-  uint8_t (*get_num_of_cameras) ();
-  int32_t (*mm_camera_open) (uint8_t camera_idx, mm_camera_vtbl_t **camera_vtbl);
-  uint32_t (*jpeg_open)(mm_jpeg_ops_t *ops, mm_jpeg_mpo_ops_t *mpo_ops,
-                   mm_dimension picture_size,
-                   cam_jpeg_metadata_t *jpeg_metadata);
-
-} hal_interface_lib_t;
-
-typedef struct {
-    uint8_t num_cameras;
-    hal_interface_lib_t hal_lib;
-} mm_camera_app_t;
-
-typedef struct {
-    uint32_t width;
-    uint32_t height;
-} mm_camera_lib_snapshot_params;
-
-typedef enum {
-    MM_CAMERA_LIB_NO_ACTION = 0,
-    MM_CAMERA_LIB_RAW_CAPTURE,
-    MM_CAMERA_LIB_JPEG_CAPTURE,
-    MM_CAMERA_LIB_SET_FOCUS_MODE,
-    MM_CAMERA_LIB_DO_AF,
-    MM_CAMERA_LIB_CANCEL_AF,
-    MM_CAMERA_LIB_LOCK_AE,
-    MM_CAMERA_LIB_UNLOCK_AE,
-    MM_CAMERA_LIB_LOCK_AWB,
-    MM_CAMERA_LIB_UNLOCK_AWB,
-    MM_CAMERA_LIB_GET_CHROMATIX,
-    MM_CAMERA_LIB_SET_RELOAD_CHROMATIX,
-    MM_CAMERA_LIB_GET_AFTUNE,
-    MM_CAMERA_LIB_SET_RELOAD_AFTUNE,
-    MM_CAMERA_LIB_SET_AUTOFOCUS_TUNING,
-    MM_CAMERA_LIB_ZSL_ENABLE,
-    MM_CAMERA_LIB_EV,
-    MM_CAMERA_LIB_ANTIBANDING,
-    MM_CAMERA_LIB_SET_VFE_COMMAND,
-    MM_CAMERA_LIB_SET_POSTPROC_COMMAND,
-    MM_CAMERA_LIB_SET_3A_COMMAND,
-    MM_CAMERA_LIB_AEC_ENABLE,
-    MM_CAMERA_LIB_AEC_DISABLE,
-    MM_CAMERA_LIB_AF_ENABLE,
-    MM_CAMERA_LIB_AF_DISABLE,
-    MM_CAMERA_LIB_AWB_ENABLE,
-    MM_CAMERA_LIB_AWB_DISABLE,
-    MM_CAMERA_LIB_AEC_FORCE_LC,
-    MM_CAMERA_LIB_AEC_FORCE_GAIN,
-    MM_CAMERA_LIB_AEC_FORCE_EXP,
-    MM_CAMERA_LIB_AEC_FORCE_SNAP_LC,
-    MM_CAMERA_LIB_AEC_FORCE_SNAP_GAIN,
-    MM_CAMERA_LIB_AEC_FORCE_SNAP_EXP,
-    MM_CAMERA_LIB_WB,
-    MM_CAMERA_LIB_EXPOSURE_METERING,
-    MM_CAMERA_LIB_BRIGHTNESS,
-    MM_CAMERA_LIB_CONTRAST,
-    MM_CAMERA_LIB_SATURATION,
-    MM_CAMERA_LIB_SHARPNESS,
-    MM_CAMERA_LIB_ISO,
-    MM_CAMERA_LIB_ZOOM,
-    MM_CAMERA_LIB_BESTSHOT,
-    MM_CAMERA_LIB_FLASH,
-    MM_CAMERA_LIB_FPS_RANGE,
-    MM_CAMERA_LIB_WNR_ENABLE,
-    MM_CAMERA_LIB_SET_TINTLESS,
-    MM_CAMERA_LIB_EZTUNE_ENABLE,
-} mm_camera_lib_commands;
-
-typedef struct {
-    int32_t stream_width, stream_height;
-    cam_focus_mode_type af_mode;
-} mm_camera_lib_params;
-
-typedef struct {
-  tuneserver_protocol_t *proto;
-  int clientsocket_id;
-  prserver_protocol_t *pr_proto;
-  int pr_clientsocket_id;
-  mm_camera_tuning_lib_params_t tuning_params;
-} tuningserver_t;
-
-typedef struct {
-    mm_camera_app_t app_ctx;
-    mm_camera_test_obj_t test_obj;
-    mm_camera_lib_params current_params;
-    int stream_running;
-    tuningserver_t tsctrl;
-} mm_camera_lib_ctx;
-
-typedef mm_camera_lib_ctx mm_camera_lib_handle;
-
-typedef int (*mm_app_test_t) (mm_camera_app_t *cam_apps);
-typedef struct {
-    mm_app_test_t f;
-    int r;
-} mm_app_tc_t;
-
-extern int mm_app_unit_test_entry(mm_camera_app_t *cam_app);
-extern int mm_app_dual_test_entry(mm_camera_app_t *cam_app);
-extern int setmetainfoCommand(mm_camera_test_obj_t *test_obj,
-                              cam_stream_size_info_t *value);
-
-extern void mm_app_dump_frame(mm_camera_buf_def_t *frame,
-                              char *name,
-                              char *ext,
-                              uint32_t frame_idx);
-extern void mm_app_dump_jpeg_frame(const void * data,
-                                   size_t size,
-                                   char* name,
-                                   char* ext,
-                                   uint32_t index);
-extern int mm_camera_app_timedwait(uint8_t seconds);
-extern int mm_camera_app_wait();
-extern void mm_camera_app_done();
-extern int mm_app_alloc_bufs(mm_camera_app_buf_t* app_bufs,
-                             cam_frame_len_offset_t *frame_offset_info,
-                             uint8_t num_bufs,
-                             uint8_t is_streambuf,
-                             size_t multipleOf);
-extern int mm_app_release_bufs(uint8_t num_bufs,
-                               mm_camera_app_buf_t* app_bufs);
-extern int mm_app_stream_initbuf(cam_frame_len_offset_t *frame_offset_info,
-                                 uint8_t *num_bufs,
-                                 uint8_t **initial_reg_flag,
-                                 mm_camera_buf_def_t **bufs,
-                                 mm_camera_map_unmap_ops_tbl_t *ops_tbl,
-                                 void *user_data);
-extern int32_t mm_app_stream_deinitbuf(mm_camera_map_unmap_ops_tbl_t *ops_tbl,
-                                       void *user_data);
-extern int mm_app_cache_ops(mm_camera_app_meminfo_t *mem_info, int cmd);
-extern int32_t mm_app_stream_clean_invalidate_buf(uint32_t index, void *user_data);
-extern int32_t mm_app_stream_invalidate_buf(uint32_t index, void *user_data);
-extern int mm_app_open(mm_camera_app_t *cam_app,
-                       int cam_id,
-                       mm_camera_test_obj_t *test_obj);
-extern int mm_app_close(mm_camera_test_obj_t *test_obj);
-extern mm_camera_channel_t * mm_app_add_channel(
-                                         mm_camera_test_obj_t *test_obj,
-                                         mm_camera_channel_type_t ch_type,
-                                         mm_camera_channel_attr_t *attr,
-                                         mm_camera_buf_notify_t channel_cb,
-                                         void *userdata);
-extern int mm_app_del_channel(mm_camera_test_obj_t *test_obj,
-                              mm_camera_channel_t *channel);
-extern mm_camera_stream_t * mm_app_add_stream(mm_camera_test_obj_t *test_obj,
-                                              mm_camera_channel_t *channel);
-extern int mm_app_del_stream(mm_camera_test_obj_t *test_obj,
-                             mm_camera_channel_t *channel,
-                             mm_camera_stream_t *stream);
-extern int mm_app_config_stream(mm_camera_test_obj_t *test_obj,
-                                mm_camera_channel_t *channel,
-                                mm_camera_stream_t *stream,
-                                mm_camera_stream_config_t *config);
-extern int mm_app_start_channel(mm_camera_test_obj_t *test_obj,
-                                mm_camera_channel_t *channel);
-extern int mm_app_stop_channel(mm_camera_test_obj_t *test_obj,
-                               mm_camera_channel_t *channel);
-extern mm_camera_channel_t *mm_app_get_channel_by_type(
-                                    mm_camera_test_obj_t *test_obj,
-                                    mm_camera_channel_type_t ch_type);
-
-extern int mm_app_start_preview(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_preview(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_preview_zsl(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_preview_zsl(mm_camera_test_obj_t *test_obj);
-extern mm_camera_channel_t * mm_app_add_preview_channel(
-                                mm_camera_test_obj_t *test_obj);
-extern mm_camera_stream_t * mm_app_add_raw_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst);
-extern int mm_app_stop_and_del_channel(mm_camera_test_obj_t *test_obj,
-                                       mm_camera_channel_t *channel);
-extern mm_camera_channel_t * mm_app_add_snapshot_channel(
-                                               mm_camera_test_obj_t *test_obj);
-extern mm_camera_stream_t * mm_app_add_snapshot_stream(
-                                                mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst);
-extern mm_camera_stream_t * mm_app_add_metadata_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs);
-extern int mm_app_start_record_preview(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_record_preview(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_record(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_record(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_live_snapshot(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_live_snapshot(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_capture(mm_camera_test_obj_t *test_obj,
-                                uint8_t num_snapshots);
-extern int mm_app_stop_capture(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_capture_raw(mm_camera_test_obj_t *test_obj,
-                                    uint8_t num_snapshots);
-extern int mm_app_stop_capture_raw(mm_camera_test_obj_t *test_obj);
-extern int mm_app_start_rdi(mm_camera_test_obj_t *test_obj, uint8_t num_burst);
-extern int mm_app_stop_rdi(mm_camera_test_obj_t *test_obj);
-extern int mm_app_initialize_fb(mm_camera_test_obj_t *test_obj);
-extern int mm_app_close_fb(mm_camera_test_obj_t *test_obj);
-extern int mm_app_fb_write(mm_camera_test_obj_t *test_obj, char *buffer);
-extern int mm_app_overlay_display(mm_camera_test_obj_t *test_obj, int bufferFd);
-extern int mm_app_allocate_ion_memory(mm_camera_app_buf_t *buf, unsigned int ion_type);
-extern int mm_app_deallocate_ion_memory(mm_camera_app_buf_t *buf);
-extern int mm_app_set_params(mm_camera_test_obj_t *test_obj,
-                      cam_intf_parm_type_t param_type,
-                      int32_t value);
-extern int mm_app_set_preview_fps_range(mm_camera_test_obj_t *test_obj,
-                        cam_fps_range_t *fpsRange);
-extern int mm_app_set_face_detection(mm_camera_test_obj_t *test_obj,
-                        cam_fd_set_parm_t *fd_set_parm);
-extern int mm_app_set_metadata_usercb(mm_camera_test_obj_t *test_obj,
-                      cam_stream_user_cb usercb);
-extern int mm_app_set_face_detection(mm_camera_test_obj_t *test_obj,
-        cam_fd_set_parm_t *fd_set_parm);
-extern int mm_app_set_flash_mode(mm_camera_test_obj_t *test_obj,
-        cam_flash_mode_t flashMode);
-
-/* JIG camera lib interface */
-
-int mm_camera_lib_open(mm_camera_lib_handle *handle, int cam_id);
-int mm_camera_lib_get_caps(mm_camera_lib_handle *handle,
-                           cam_capability_t *caps);
-int mm_camera_lib_start_stream(mm_camera_lib_handle *handle);
-int mm_camera_lib_send_command(mm_camera_lib_handle *handle,
-                               mm_camera_lib_commands cmd,
-                               void *data, void *out_data);
-int mm_camera_lib_stop_stream(mm_camera_lib_handle *handle);
-int mm_camera_lib_number_of_cameras(mm_camera_lib_handle *handle);
-int mm_camera_lib_close(mm_camera_lib_handle *handle);
-int32_t mm_camera_load_tuninglibrary(
-  mm_camera_tuning_lib_params_t *tuning_param);
-int mm_camera_lib_set_preview_usercb(
-  mm_camera_lib_handle *handle, cam_stream_user_cb cb);
-//
-
-int mm_app_start_regression_test(int run_tc);
-int mm_app_load_hal(mm_camera_app_t *my_cam_app);
-
-extern int createEncodingSession(mm_camera_test_obj_t *test_obj,
-                          mm_camera_stream_t *m_stream,
-                          mm_camera_buf_def_t *m_frame);
-extern int encodeData(mm_camera_test_obj_t *test_obj, mm_camera_super_buf_t* recvd_frame,
-               mm_camera_stream_t *m_stream);
-extern int mm_app_take_picture(mm_camera_test_obj_t *test_obj, uint8_t);
-
-extern mm_camera_channel_t * mm_app_add_reprocess_channel(mm_camera_test_obj_t *test_obj,
-                                                   mm_camera_stream_t *source_stream);
-extern int mm_app_start_reprocess(mm_camera_test_obj_t *test_obj);
-extern int mm_app_stop_reprocess(mm_camera_test_obj_t *test_obj);
-extern int mm_app_do_reprocess(mm_camera_test_obj_t *test_obj,
-        mm_camera_buf_def_t *frame,
-        uint32_t meta_idx,
-        mm_camera_super_buf_t *super_buf,
-        mm_camera_stream_t *src_meta);
-extern void mm_app_release_ppinput(void *data, void *user_data);
-
-extern int mm_camera_queue_init(mm_camera_queue_t *queue,
-                         release_data_fn data_rel_fn,
-                         void *user_data);
-extern int mm_qcamera_queue_release(mm_camera_queue_t *queue);
-extern int mm_qcamera_queue_isempty(mm_camera_queue_t *queue);
-extern int mm_qcamera_queue_enqueue(mm_camera_queue_t *queue, void *data);
-extern void* mm_qcamera_queue_dequeue(mm_camera_queue_t *queue,
-                                      int bFromHead);
-extern void mm_qcamera_queue_flush(mm_camera_queue_t *queue);
-
-#endif /* __MM_QCAMERA_APP_H__ */
-
-
-
-
-
-
-
-
-
diff --git a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h b/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
deleted file mode 100644
index 1a7ac33..0000000
--- a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_commands.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/* Copyright (c) 2013, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MM_QCAMERA_COMMANDS_H__
-#define __MM_QCAMERA_COMMANDS_H__
-
-// Camera dependencies
-#include "mm_qcamera_socket.h"
-#include "mm_qcamera_app.h"
-
-int tuneserver_close_cam(mm_camera_lib_handle *lib_handle);
-int tuneserver_stop_cam(mm_camera_lib_handle *lib_handle);
-int tuneserver_open_cam(mm_camera_lib_handle *lib_handle);
-
-int tuneserver_initialize_tuningp(void * ctrl, int client_socket_id,
-  char *send_buf, uint32_t send_len);
-int tuneserver_deinitialize_tuningp(void * ctrl, int client_socket_id,
-  char *send_buf, uint32_t send_len);
-int tuneserver_process_get_list_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len);
-int tuneserver_process_misc_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len);
-int tuneserver_process_get_params_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len);
-int tuneserver_process_set_params_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len);
-
-int tuneserver_initialize_prevtuningp(void * ctrl,
-  int pr_client_socket_id, cam_dimension_t dimension,
-  char **send_buf, uint32_t *send_len);
-int tuneserver_deinitialize_prevtuningp(void * ctrl,
-  char **send_buf, uint32_t *send_len);
-int tuneserver_preview_getinfo(void * ctrl,
-  char **send_buf, uint32_t *send_len);
-int tuneserver_preview_getchunksize(void * ctrl,
-  char **send_buf, uint32_t *send_len);
-int tuneserver_preview_getframe(void * ctrl,
-  char **send_buf, uint32_t *send_len);
-int tuneserver_preview_unsupported(void * ctrl,
-  char **send_buf, uint32_t *send_len);
-
-#endif /*__MM_QCAMERA_COMMANDS_H__*/
diff --git a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h b/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
deleted file mode 100644
index acd197e..0000000
--- a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_dbg.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/* Copyright (c) 2012, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MM_QCAMERA_DBG_H__
-#define __MM_QCAMERA_DBG_H__
-
-#ifdef QCAMERA_REDEFINE_LOG
-#define CAM_MODULE CAM_HAL_MODULE
-#include "mm_camera_dbg.h"
-#endif
-
-#endif /* __MM_QCAMERA_DBG_H__ */
diff --git a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_main_menu.h b/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_main_menu.h
deleted file mode 100644
index faf9453..0000000
--- a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_main_menu.h
+++ /dev/null
@@ -1,440 +0,0 @@
-/* Copyright (c) 2013, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MM_QCAMERA_MAIN_MENU_H__
-#define __MM_QCAMERA_MAIN_MENU_H__
-
-// Camera dependencies
-#include "mm_camera_interface.h"
-#include "mm_jpeg_interface.h"
-
-#define VIDEO_BUFFER_SIZE       (PREVIEW_WIDTH * PREVIEW_HEIGHT * 3/2)
-#define THUMBNAIL_BUFFER_SIZE   (THUMBNAIL_WIDTH * THUMBNAIL_HEIGHT * 3/2)
-#define SNAPSHOT_BUFFER_SIZE    (PICTURE_WIDTH * PICTURE_HEIGHT * 3/2)
-
-/*===========================================================================
- * Macro
- *===========================================================================*/
-#define PREVIEW_FRAMES_NUM    5
-#define VIDEO_FRAMES_NUM      5
-#define THUMBNAIL_FRAMES_NUM  1
-#define SNAPSHOT_FRAMES_NUM   1
-#define MAX_NUM_FORMAT        32
-
-typedef enum
-{
-  START_PREVIEW,
-  STOP_PREVIEW,
-  SET_WHITE_BALANCE,
-  SET_TINTLESS_ENABLE,
-  SET_TINTLESS_DISABLE,
-  SET_EXP_METERING,
-  GET_CTRL_VALUE,
-  TOGGLE_EZTUNE,
-  SET_ISO,
-  BRIGHTNESS_GOTO_SUBMENU,
-  CONTRAST_GOTO_SUBMENU,
-  EV_GOTO_SUBMENU,
-  SATURATION_GOTO_SUBMENU,
-  SET_ZOOM,
-  SET_SHARPNESS,
-  TAKE_JPEG_SNAPSHOT,
-  START_RECORDING,
-  STOP_RECORDING,
-  BEST_SHOT,
-  LIVE_SHOT,
-  FLASH_MODES,
-  TOGGLE_ZSL,
-  TAKE_RAW_SNAPSHOT,
-  SWITCH_SNAP_RESOLUTION,
-  TOGGLE_WNR,
-  EXIT
-} Camera_main_menu_t;
-
-typedef enum
-{
-  ACTION_NO_ACTION,
-  ACTION_START_PREVIEW,
-  ACTION_STOP_PREVIEW,
-  ACTION_SET_WHITE_BALANCE,
-  ACTION_SET_TINTLESS_ENABLE,
-  ACTION_SET_TINTLESS_DISABLE,
-  ACTION_SET_EXP_METERING,
-  ACTION_GET_CTRL_VALUE,
-  ACTION_TOGGLE_AFR,
-  ACTION_TOGGLE_EZTUNE,
-  ACTION_SET_ISO,
-  ACTION_BRIGHTNESS_INCREASE,
-  ACTION_BRIGHTNESS_DECREASE,
-  ACTION_CONTRAST_INCREASE,
-  ACTION_CONTRAST_DECREASE,
-  ACTION_EV_INCREASE,
-  ACTION_EV_DECREASE,
-  ACTION_SATURATION_INCREASE,
-  ACTION_SATURATION_DECREASE,
-  ACTION_SET_ZOOM,
-  ACTION_SHARPNESS_INCREASE,
-  ACTION_SHARPNESS_DECREASE,
-  ACTION_TAKE_JPEG_SNAPSHOT,
-  ACTION_START_RECORDING,
-  ACTION_STOP_RECORDING,
-  ACTION_SET_BESTSHOT_MODE,
-  ACTION_TAKE_LIVE_SNAPSHOT,
-  ACTION_SET_FLASH_MODE,
-  ACTION_SWITCH_CAMERA,
-  ACTION_TOGGLE_ZSL,
-  ACTION_TAKE_RAW_SNAPSHOT,
-  ACTION_SWITCH_RESOLUTION,
-  ACTION_TOGGLE_WNR,
-  ACTION_EXIT
-} camera_action_t;
-
-#define INVALID_KEY_PRESS 0
-#define BASE_OFFSET  ('Z' - 'A' + 1)
-#define BASE_OFFSET_NUM  ('Z' - 'A' + 2)
-#define PAD_TO_WORD(a)  (((a)+3)&~3)
-
-
-#define SQCIF_WIDTH     128
-#define SQCIF_HEIGHT     96
-#define QCIF_WIDTH      176
-#define QCIF_HEIGHT     144
-#define QVGA_WIDTH      320
-#define QVGA_HEIGHT     240
-#define HD_THUMBNAIL_WIDTH      256
-#define HD_THUMBNAIL_HEIGHT     144
-#define CIF_WIDTH       352
-#define CIF_HEIGHT      288
-#define VGA_WIDTH       640
-#define VGA_HEIGHT      480
-#define WVGA_WIDTH      800
-#define WVGA_HEIGHT     480
-#define WVGA_PLUS_WIDTH      960
-#define WVGA_PLUS_HEIGHT     720
-
-#define MP1_WIDTH      1280
-#define MP1_HEIGHT      960
-#define MP2_WIDTH      1600
-#define MP2_HEIGHT     1200
-#define MP3_WIDTH      2048
-#define MP3_HEIGHT     1536
-#define MP5_WIDTH      2592
-#define MP5_HEIGHT     1944
-#define MP8_WIDTH      3264
-#define MP8_HEIGHT     2448
-#define MP12_WIDTH     4000
-#define MP12_HEIGHT    3000
-
-#define SVGA_WIDTH      800
-#define SVGA_HEIGHT     600
-#define XGA_WIDTH      1024
-#define XGA_HEIGHT      768
-#define HD720_WIDTH    1280
-#define HD720_HEIGHT    720
-#define HD720_PLUS_WIDTH    1440
-#define HD720_PLUS_HEIGHT   1080
-#define WXGA_WIDTH     1280
-#define WXGA_HEIGHT     768
-#define HD1080_WIDTH   1920
-#define HD1080_HEIGHT  1080
-
-
-#define ONEMP_WIDTH    1280
-#define SXGA_WIDTH     1280
-#define UXGA_WIDTH     1600
-#define QXGA_WIDTH     2048
-#define FIVEMP_WIDTH   2560
-
-
-#define ONEMP_HEIGHT    960
-#define SXGA_HEIGHT     1024
-#define UXGA_HEIGHT     1200
-#define QXGA_HEIGHT     1536
-#define FIVEMP_HEIGHT   1920
-
-
-typedef enum
-{
-  RESOLUTION_MIN,
-  QCIF                  = RESOLUTION_MIN,
-  QVGA,
-  VGA,
-  WVGA,
-  WVGA_PLUS ,
-  HD720,
-  HD720_PLUS,
-  HD1080,
-  RESOLUTION_PREVIEW_VIDEO_MAX = HD1080,
-  WXGA,
-  MP1,
-  MP2,
-  MP3,
-  MP5,
-  MP8,
-  MP12,
-  RESOLUTION_MAX         = MP12,
-} Camera_Resolution;
-
-typedef struct{
-    uint16_t width;
-    uint16_t  height;
-    char * name;
-    char * str_name;
-    int supported;
-} DIMENSION_TBL_T;
-
-typedef enum {
-    WHITE_BALANCE_STATE,
-    WHITE_BALANCE_TEMPERATURE,
-    BRIGHTNESS_CTRL,
-    EV,
-    CONTRAST_CTRL,
-    SATURATION_CTRL,
-    SHARPNESS_CTRL
-} Get_Ctrl_modes;
-
-typedef enum {
-    AUTO_EXP_FRAME_AVG,
-    AUTO_EXP_CENTER_WEIGHTED,
-    AUTO_EXP_SPOT_METERING,
-    AUTO_EXP_SMART_METERING,
-    AUTO_EXP_USER_METERING,
-    AUTO_EXP_SPOT_METERING_ADV,
-    AUTO_EXP_CENTER_WEIGHTED_ADV,
-    AUTO_EXP_MAX
-} Exp_Metering_modes;
-
-typedef enum {
-  ISO_AUTO,
-  ISO_DEBLUR,
-  ISO_100,
-  ISO_200,
-  ISO_400,
-  ISO_800,
-  ISO_1600,
-  ISO_MAX
-} ISO_modes;
-
-typedef enum {
-  BESTSHOT_AUTO,
-  BESTSHOT_ACTION,
-  BESTSHOT_PORTRAIT,
-  BESTSHOT_LANDSCAPE,
-  BESTSHOT_NIGHT,
-  BESTSHOT_NIGHT_PORTRAIT,
-  BESTSHOT_THEATRE,
-  BESTSHOT_BEACH,
-  BESTSHOT_SNOW,
-  BESTSHOT_SUNSET,
-  BESTSHOT_ANTISHAKE,
-  BESTSHOT_FIREWORKS,
-  BESTSHOT_SPORTS,
-  BESTSHOT_PARTY,
-  BESTSHOT_CANDLELIGHT,
-  BESTSHOT_ASD,
-  BESTSHOT_BACKLIGHT,
-  BESTSHOT_FLOWERS,
-  BESTSHOT_AR,
-  BESTSHOT_HDR,
-  BESTSHOT_MAX
-}Bestshot_modes;
-
-typedef enum {
-    FLASH_MODE_OFF,
-    FLASH_MODE_AUTO,
-    FLASH_MODE_ON,
-    FLASH_MODE_TORCH,
-    FLASH_MODE_MAX,
-}Flash_modes;
-
-typedef enum {
-  WB_AUTO,
-  WB_INCANDESCENT,
-  WB_FLUORESCENT,
-  WB_WARM_FLUORESCENT,
-  WB_DAYLIGHT,
-  WB_CLOUDY_DAYLIGHT,
-  WB_TWILIGHT,
-  WB_SHADE,
-  WB_MAX
-} White_Balance_modes;
-
-typedef enum
-{
-  MENU_ID_MAIN,
-  MENU_ID_WHITEBALANCECHANGE,
-  MENU_ID_EXPMETERINGCHANGE,
-  MENU_ID_GET_CTRL_VALUE,
-  MENU_ID_TOGGLEAFR,
-  MENU_ID_ISOCHANGE,
-  MENU_ID_BRIGHTNESSCHANGE,
-  MENU_ID_CONTRASTCHANGE,
-  MENU_ID_EVCHANGE,
-  MENU_ID_SATURATIONCHANGE,
-  MENU_ID_ZOOMCHANGE,
-  MENU_ID_SHARPNESSCHANGE,
-  MENU_ID_BESTSHOT,
-  MENU_ID_FLASHMODE,
-  MENU_ID_SENSORS,
-  MENU_ID_SWITCH_RES,
-  MENU_ID_INVALID,
-} menu_id_change_t;
-
-typedef enum
-{
-  DECREASE_ZOOM,
-  INCREASE_ZOOM,
-  INCREASE_STEP_ZOOM,
-  DECREASE_STEP_ZOOM,
-} Camera_Zoom;
-
-typedef enum
-{
-  INC_CONTRAST,
-  DEC_CONTRAST,
-} Camera_Contrast_changes;
-
-typedef enum
-{
-  INC_BRIGHTNESS,
-  DEC_BRIGHTNESS,
-} Camera_Brightness_changes;
-
-typedef enum
-{
-  INCREASE_EV,
-  DECREASE_EV,
-} Camera_EV_changes;
-
-typedef enum {
-  INC_SATURATION,
-  DEC_SATURATION,
-} Camera_Saturation_changes;
-
-typedef enum
-{
-  INC_ISO,
-  DEC_ISO,
-} Camera_ISO_changes;
-
-typedef enum
-{
-  INC_SHARPNESS,
-  DEC_SHARPNESS,
-} Camera_Sharpness_changes;
-
-typedef enum {
-  ZOOM_IN,
-  ZOOM_OUT,
-} Zoom_direction;
-
-typedef struct{
-    Camera_main_menu_t main_menu;
-    char * menu_name;
-} CAMERA_MAIN_MENU_TBL_T;
-
-typedef struct{
-    char * menu_name;
-    int present;
-} CAMERA_SENSOR_MENU_TLB_T;
-
-typedef struct{
-    Camera_Resolution cs_id;
-    uint16_t width;
-    uint16_t  height;
-    char * name;
-    char * str_name;
-} PREVIEW_DIMENSION_TBL_T;
-
-typedef struct {
-  White_Balance_modes wb_id;
-  char * wb_name;
-} WHITE_BALANCE_TBL_T;
-
-typedef struct {
-  Get_Ctrl_modes get_ctrl_id;
-  char * get_ctrl_name;
-} GET_CTRL_TBL_T;
-
-typedef struct{
-  Exp_Metering_modes exp_metering_id;
-  char * exp_metering_name;
-} EXP_METERING_TBL_T;
-
-typedef struct {
-  Bestshot_modes bs_id;
-  char *name;
-} BESTSHOT_MODE_TBT_T;
-
-typedef struct {
-  Flash_modes bs_id;
-  char *name;
-} FLASH_MODE_TBL_T;
-
-typedef struct {
-  ISO_modes iso_modes;
-  char *iso_modes_name;
-} ISO_TBL_T;
-
-typedef struct {
-  Zoom_direction zoom_direction;
-  char * zoom_direction_name;
-} ZOOM_TBL_T;
-
-typedef struct {
-  Camera_Sharpness_changes sharpness_change;
-  char *sharpness_change_name;
-} SHARPNESS_TBL_T;
-
-typedef struct {
-  Camera_Brightness_changes bc_id;
-  char * brightness_name;
-} CAMERA_BRIGHTNESS_TBL_T;
-
-typedef struct {
-  Camera_Contrast_changes cc_id;
-  char * contrast_name;
-} CAMERA_CONTRST_TBL_T;
-
-typedef struct {
-  Camera_EV_changes ec_id;
-  char * EV_name;
-} CAMERA_EV_TBL_T;
-
-typedef struct {
-  Camera_Saturation_changes sc_id;
-  char * saturation_name;
-} CAMERA_SATURATION_TBL_T;
-
-typedef struct {
-  Camera_Sharpness_changes bc_id;
-  char * sharpness_name;
-} CAMERA_SHARPNESS_TBL_T;
-
-#endif /* __MM_QCAMERA_MAIN_MENU_H__ */
diff --git a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h b/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
deleted file mode 100644
index 186c109..0000000
--- a/camera/QCamera2/stack/mm-camera-test/inc/mm_qcamera_socket.h
+++ /dev/null
@@ -1,113 +0,0 @@
-/* Copyright (c) 2013-2014, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-#ifndef __MM_QCAMERA_SOCKET_H__
-#define __MM_QCAMERA_SOCKET_H__
-
-// System dependencies
-#include <arpa/inet.h>
-
-#undef __FD_SET
-#define __FD_SET(fd, fdsetp) \
-  (((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] |= (1LU<<((fd) & 31)))
-
-#undef __FD_CLR
-#define __FD_CLR(fd, fdsetp) \
-  (((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] &= ~(1LU<<((fd) & 31)))
-
-#undef  __FD_ISSET
-#define __FD_ISSET(fd, fdsetp) \
-  ((((fd_set *)(fdsetp))->fds_bits[(fd) >> 5] & (1LU<<((fd) & 31))) != 0)
-
-#undef  __FD_ZERO
-#define __FD_ZERO(fdsetp) \
-  (memset (fdsetp, 0, sizeof (*(fd_set *)(fdsetp))))
-
-#define TUNESERVER_MAX_RECV 2048
-#define TUNESERVER_MAX(a, b)  (((a) > (b)) ? (a) : (b))
-
-#define TUNESERVER_GET_LIST 1014
-#define TUNESERVER_GET_PARMS 1015
-#define TUNESERVER_SET_PARMS 1016
-#define TUNESERVER_MISC_CMDS 1021
-
-#define TUNE_PREV_GET_INFO        0x0001
-#define TUNE_PREV_CH_CNK_SIZE     0x0002
-#define TUNE_PREV_GET_PREV_FRAME  0x0003
-#define TUNE_PREV_GET_JPG_SNAP    0x0004
-#define TUNE_PREV_GET_RAW_SNAP    0x0005
-#define TUNE_PREV_GET_RAW_PREV    0x0006
-
-typedef struct {
-  char data[128];
-} tuneserver_misc_cmd;
-
-typedef enum {
-  TUNESERVER_RECV_COMMAND = 1,
-  TUNESERVER_RECV_PAYLOAD_SIZE,
-  TUNESERVER_RECV_PAYLOAD,
-  TUNESERVER_RECV_RESPONSE,
-  TUNESERVERER_RECV_INVALID,
-} tuneserver_recv_cmd_t;
-
-typedef struct {
-  uint16_t          current_cmd;
-  tuneserver_recv_cmd_t next_recv_code;
-  uint32_t          next_recv_len;
-  void              *recv_buf;
-  uint32_t          recv_len;
-  uint32_t          send_len;
-  void              *send_buf;
-} tuneserver_protocol_t;
-
-typedef enum {
-  TUNE_PREV_RECV_COMMAND = 1,
-  TUNE_PREV_RECV_NEWCNKSIZE,
-  TUNE_PREV_RECV_INVALID
-} tune_prev_cmd_t;
-
-typedef struct _eztune_preview_protocol_t {
-  uint16_t         current_cmd;
-  tune_prev_cmd_t  next_recv_code;
-  uint32_t         next_recv_len;
-  int32_t          send_len;
-  char*            send_buf;
-  uint32_t         send_buf_size;
-  uint32_t         new_cnk_size;
-  uint32_t         new_cmd_available;
-} prserver_protocol_t;
-
-typedef union {
-  struct sockaddr addr;
-  struct sockaddr_in addr_in;
-} mm_qcamera_sock_addr_t;
-
-int eztune_server_start(void *lib_handle);
-
-#endif /*__MM_QCAMERA_SOCKET_H__*/
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
deleted file mode 100644
index 5d845b4..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_app.c
+++ /dev/null
@@ -1,2423 +0,0 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS"AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// To remove
-#include <cutils/properties.h>
-
-// System dependencies
-#include <dlfcn.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <linux/msm_ion.h>
-#define MMAN_H <SYSTEM_HEADER_PREFIX/mman.h>
-#include MMAN_H
-
-// Camera dependencies
-#include "mm_qcamera_dbg.h"
-#include "mm_qcamera_app.h"
-
-static pthread_mutex_t app_mutex;
-static int thread_status = 0;
-static pthread_cond_t app_cond_v;
-
-#define MM_QCAMERA_APP_NANOSEC_SCALE 1000000000
-
-int mm_camera_app_timedwait(uint8_t seconds)
-{
-    int rc = 0;
-    pthread_mutex_lock(&app_mutex);
-    if(FALSE == thread_status) {
-        struct timespec tw;
-        memset(&tw, 0, sizeof tw);
-        tw.tv_sec = 0;
-        tw.tv_nsec = time(0) + seconds * MM_QCAMERA_APP_NANOSEC_SCALE;
-
-        rc = pthread_cond_timedwait(&app_cond_v, &app_mutex,&tw);
-        thread_status = FALSE;
-    }
-    pthread_mutex_unlock(&app_mutex);
-    return rc;
-}
-
-int mm_camera_app_wait()
-{
-    int rc = 0;
-    pthread_mutex_lock(&app_mutex);
-    if(FALSE == thread_status){
-        pthread_cond_wait(&app_cond_v, &app_mutex);
-    }
-    thread_status = FALSE;
-    pthread_mutex_unlock(&app_mutex);
-    return rc;
-}
-
-void mm_camera_app_done()
-{
-  pthread_mutex_lock(&app_mutex);
-  thread_status = TRUE;
-  pthread_cond_signal(&app_cond_v);
-  pthread_mutex_unlock(&app_mutex);
-}
-
-int mm_app_load_hal(mm_camera_app_t *my_cam_app)
-{
-    memset(&my_cam_app->hal_lib, 0, sizeof(hal_interface_lib_t));
-    my_cam_app->hal_lib.ptr = dlopen("libmmcamera_interface.so", RTLD_NOW);
-    my_cam_app->hal_lib.ptr_jpeg = dlopen("libmmjpeg_interface.so", RTLD_NOW);
-    if (!my_cam_app->hal_lib.ptr || !my_cam_app->hal_lib.ptr_jpeg) {
-        LOGE("Error opening HAL library %s\n",  dlerror());
-        return -MM_CAMERA_E_GENERAL;
-    }
-    *(void **)&(my_cam_app->hal_lib.get_num_of_cameras) =
-        dlsym(my_cam_app->hal_lib.ptr, "get_num_of_cameras");
-    *(void **)&(my_cam_app->hal_lib.mm_camera_open) =
-        dlsym(my_cam_app->hal_lib.ptr, "camera_open");
-    *(void **)&(my_cam_app->hal_lib.jpeg_open) =
-        dlsym(my_cam_app->hal_lib.ptr_jpeg, "jpeg_open");
-
-    if (my_cam_app->hal_lib.get_num_of_cameras == NULL ||
-        my_cam_app->hal_lib.mm_camera_open == NULL ||
-        my_cam_app->hal_lib.jpeg_open == NULL) {
-        LOGE("Error loading HAL sym %s\n",  dlerror());
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    my_cam_app->num_cameras = my_cam_app->hal_lib.get_num_of_cameras();
-    LOGD("num_cameras = %d\n",  my_cam_app->num_cameras);
-
-    return MM_CAMERA_OK;
-}
-
-int mm_app_allocate_ion_memory(mm_camera_app_buf_t *buf,
-        __unused unsigned int ion_type)
-{
-    int rc = MM_CAMERA_OK;
-    struct ion_handle_data handle_data;
-    struct ion_allocation_data alloc;
-    struct ion_fd_data ion_info_fd;
-    int main_ion_fd = -1;
-    void *data = NULL;
-
-    main_ion_fd = open("/dev/ion", O_RDONLY);
-    if (main_ion_fd <= 0) {
-        LOGE("Ion dev open failed %s\n", strerror(errno));
-        goto ION_OPEN_FAILED;
-    }
-
-    memset(&alloc, 0, sizeof(alloc));
-    alloc.len = buf->mem_info.size;
-    /* to make it page size aligned */
-    alloc.len = (alloc.len + 4095U) & (~4095U);
-    alloc.align = 4096;
-    alloc.flags = ION_FLAG_CACHED;
-    alloc.heap_id_mask = ION_HEAP(ION_SYSTEM_HEAP_ID);
-    rc = ioctl(main_ion_fd, ION_IOC_ALLOC, &alloc);
-    if (rc < 0) {
-        LOGE("ION allocation failed %s with rc = %d \n",strerror(errno), rc);
-        goto ION_ALLOC_FAILED;
-    }
-
-    memset(&ion_info_fd, 0, sizeof(ion_info_fd));
-    ion_info_fd.handle = alloc.handle;
-    rc = ioctl(main_ion_fd, ION_IOC_SHARE, &ion_info_fd);
-    if (rc < 0) {
-        LOGE("ION map failed %s\n", strerror(errno));
-        goto ION_MAP_FAILED;
-    }
-
-    data = mmap(NULL,
-                alloc.len,
-                PROT_READ  | PROT_WRITE,
-                MAP_SHARED,
-                ion_info_fd.fd,
-                0);
-
-    if (data == MAP_FAILED) {
-        LOGE("ION_MMAP_FAILED: %s (%d)\n", strerror(errno), errno);
-        goto ION_MAP_FAILED;
-    }
-    buf->mem_info.main_ion_fd = main_ion_fd;
-    buf->mem_info.fd = ion_info_fd.fd;
-    buf->mem_info.handle = ion_info_fd.handle;
-    buf->mem_info.size = alloc.len;
-    buf->mem_info.data = data;
-    return MM_CAMERA_OK;
-
-ION_MAP_FAILED:
-    memset(&handle_data, 0, sizeof(handle_data));
-    handle_data.handle = ion_info_fd.handle;
-    ioctl(main_ion_fd, ION_IOC_FREE, &handle_data);
-ION_ALLOC_FAILED:
-    close(main_ion_fd);
-ION_OPEN_FAILED:
-    return -MM_CAMERA_E_GENERAL;
-}
-
-int mm_app_deallocate_ion_memory(mm_camera_app_buf_t *buf)
-{
-  struct ion_handle_data handle_data;
-  int rc = 0;
-
-  rc = munmap(buf->mem_info.data, buf->mem_info.size);
-
-  if (buf->mem_info.fd >= 0) {
-      close(buf->mem_info.fd);
-      buf->mem_info.fd = -1;
-  }
-
-  if (buf->mem_info.main_ion_fd >= 0) {
-      memset(&handle_data, 0, sizeof(handle_data));
-      handle_data.handle = buf->mem_info.handle;
-      ioctl(buf->mem_info.main_ion_fd, ION_IOC_FREE, &handle_data);
-      close(buf->mem_info.main_ion_fd);
-      buf->mem_info.main_ion_fd = -1;
-  }
-  return rc;
-}
-
-/* cmd = ION_IOC_CLEAN_CACHES, ION_IOC_INV_CACHES, ION_IOC_CLEAN_INV_CACHES */
-int mm_app_cache_ops(mm_camera_app_meminfo_t *mem_info,
-                     int cmd)
-{
-    struct ion_flush_data cache_inv_data;
-    struct ion_custom_data custom_data;
-    int ret = MM_CAMERA_OK;
-
-#ifdef USE_ION
-    if (NULL == mem_info) {
-        LOGE("mem_info is NULL, return here");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    memset(&cache_inv_data, 0, sizeof(cache_inv_data));
-    memset(&custom_data, 0, sizeof(custom_data));
-    cache_inv_data.vaddr = mem_info->data;
-    cache_inv_data.fd = mem_info->fd;
-    cache_inv_data.handle = mem_info->handle;
-    cache_inv_data.length = (unsigned int)mem_info->size;
-    custom_data.cmd = (unsigned int)cmd;
-    custom_data.arg = (unsigned long)&cache_inv_data;
-
-    LOGD("addr = %p, fd = %d, handle = %lx length = %d, ION Fd = %d",
-         cache_inv_data.vaddr, cache_inv_data.fd,
-         (unsigned long)cache_inv_data.handle, cache_inv_data.length,
-         mem_info->main_ion_fd);
-    if(mem_info->main_ion_fd >= 0) {
-        if(ioctl(mem_info->main_ion_fd, ION_IOC_CUSTOM, &custom_data) < 0) {
-            LOGE("Cache Invalidate failed\n");
-            ret = -MM_CAMERA_E_GENERAL;
-        }
-    }
-#endif
-
-    return ret;
-}
-
-void mm_app_dump_frame(mm_camera_buf_def_t *frame,
-                       char *name,
-                       char *ext,
-                       uint32_t frame_idx)
-{
-    char file_name[FILENAME_MAX];
-    int file_fd;
-    int i;
-    int offset = 0;
-    if ( frame != NULL) {
-        snprintf(file_name, sizeof(file_name),
-                QCAMERA_DUMP_FRM_LOCATION"%s_%04d.%s", name, frame_idx, ext);
-        file_fd = open(file_name, O_RDWR | O_CREAT, 0777);
-        if (file_fd < 0) {
-            LOGE("cannot open file %s \n",  file_name);
-        } else {
-            for (i = 0; i < frame->planes_buf.num_planes; i++) {
-                LOGD("saving file from address: %p, data offset: %d, "
-                     "length: %d \n",  frame->buffer,
-                    frame->planes_buf.planes[i].data_offset, frame->planes_buf.planes[i].length);
-                write(file_fd,
-                      (uint8_t *)frame->buffer + offset,
-                      frame->planes_buf.planes[i].length);
-                offset += (int)frame->planes_buf.planes[i].length;
-            }
-
-            close(file_fd);
-            LOGD("dump %s", file_name);
-        }
-    }
-}
-
-void mm_app_dump_jpeg_frame(const void * data, size_t size, char* name,
-        char* ext, uint32_t index)
-{
-    char buf[FILENAME_MAX];
-    int file_fd;
-    if ( data != NULL) {
-        snprintf(buf, sizeof(buf),
-                QCAMERA_DUMP_FRM_LOCATION"test/%s_%u.%s", name, index, ext);
-        LOGD("%s size =%zu, jobId=%u",  buf, size, index);
-        file_fd = open(buf, O_RDWR | O_CREAT, 0777);
-        write(file_fd, data, size);
-        close(file_fd);
-    }
-}
-
-int mm_app_alloc_bufs(mm_camera_app_buf_t* app_bufs,
-                      cam_frame_len_offset_t *frame_offset_info,
-                      uint8_t num_bufs,
-                      uint8_t is_streambuf,
-                      size_t multipleOf)
-{
-    uint32_t i, j;
-    unsigned int ion_type = 0x1 << CAMERA_ION_FALLBACK_HEAP_ID;
-
-    if (is_streambuf) {
-        ion_type |= 0x1 << CAMERA_ION_HEAP_ID;
-    }
-
-    for (i = 0; i < num_bufs ; i++) {
-        if ( 0 < multipleOf ) {
-            size_t m = frame_offset_info->frame_len / multipleOf;
-            if ( ( frame_offset_info->frame_len % multipleOf ) != 0 ) {
-                m++;
-            }
-            app_bufs[i].mem_info.size = m * multipleOf;
-        } else {
-            app_bufs[i].mem_info.size = frame_offset_info->frame_len;
-        }
-        mm_app_allocate_ion_memory(&app_bufs[i], ion_type);
-
-        app_bufs[i].buf.buf_idx = i;
-        app_bufs[i].buf.planes_buf.num_planes = (int8_t)frame_offset_info->num_planes;
-        app_bufs[i].buf.fd = app_bufs[i].mem_info.fd;
-        app_bufs[i].buf.frame_len = app_bufs[i].mem_info.size;
-        app_bufs[i].buf.buffer = app_bufs[i].mem_info.data;
-        app_bufs[i].buf.mem_info = (void *)&app_bufs[i].mem_info;
-
-        /* Plane 0 needs to be set seperately. Set other planes
-             * in a loop. */
-        app_bufs[i].buf.planes_buf.planes[0].length = frame_offset_info->mp[0].len;
-        app_bufs[i].buf.planes_buf.planes[0].m.userptr =
-            (long unsigned int)app_bufs[i].buf.fd;
-        app_bufs[i].buf.planes_buf.planes[0].data_offset = frame_offset_info->mp[0].offset;
-        app_bufs[i].buf.planes_buf.planes[0].reserved[0] = 0;
-        for (j = 1; j < (uint8_t)frame_offset_info->num_planes; j++) {
-            app_bufs[i].buf.planes_buf.planes[j].length = frame_offset_info->mp[j].len;
-            app_bufs[i].buf.planes_buf.planes[j].m.userptr =
-                (long unsigned int)app_bufs[i].buf.fd;
-            app_bufs[i].buf.planes_buf.planes[j].data_offset = frame_offset_info->mp[j].offset;
-            app_bufs[i].buf.planes_buf.planes[j].reserved[0] =
-                app_bufs[i].buf.planes_buf.planes[j-1].reserved[0] +
-                app_bufs[i].buf.planes_buf.planes[j-1].length;
-        }
-    }
-    LOGD("X");
-    return MM_CAMERA_OK;
-}
-
-int mm_app_release_bufs(uint8_t num_bufs,
-                        mm_camera_app_buf_t* app_bufs)
-{
-    int i, rc = MM_CAMERA_OK;
-
-    LOGD("E");
-
-    for (i = 0; i < num_bufs; i++) {
-        rc = mm_app_deallocate_ion_memory(&app_bufs[i]);
-    }
-    memset(app_bufs, 0, num_bufs * sizeof(mm_camera_app_buf_t));
-    LOGD("X");
-    return rc;
-}
-
-int mm_app_stream_initbuf(cam_frame_len_offset_t *frame_offset_info,
-                          uint8_t *num_bufs,
-                          uint8_t **initial_reg_flag,
-                          mm_camera_buf_def_t **bufs,
-                          mm_camera_map_unmap_ops_tbl_t *ops_tbl,
-                          void *user_data)
-{
-    mm_camera_stream_t *stream = (mm_camera_stream_t *)user_data;
-    mm_camera_buf_def_t *pBufs = NULL;
-    uint8_t *reg_flags = NULL;
-    int i, rc;
-
-    stream->offset = *frame_offset_info;
-
-    LOGD("alloc buf for stream_id %d, len=%d, num planes: %d, offset: %d",
-         stream->s_id,
-         frame_offset_info->frame_len,
-         frame_offset_info->num_planes,
-         frame_offset_info->mp[1].offset);
-
-    if (stream->num_of_bufs > CAM_MAX_NUM_BUFS_PER_STREAM)
-        stream->num_of_bufs = CAM_MAX_NUM_BUFS_PER_STREAM;
-
-    pBufs = (mm_camera_buf_def_t *)malloc(sizeof(mm_camera_buf_def_t) * stream->num_of_bufs);
-    reg_flags = (uint8_t *)malloc(sizeof(uint8_t) * stream->num_of_bufs);
-    if (pBufs == NULL || reg_flags == NULL) {
-        LOGE("No mem for bufs");
-        if (pBufs != NULL) {
-            free(pBufs);
-        }
-        if (reg_flags != NULL) {
-            free(reg_flags);
-        }
-        return -1;
-    }
-
-    rc = mm_app_alloc_bufs(&stream->s_bufs[0],
-                           frame_offset_info,
-                           stream->num_of_bufs,
-                           1,
-                           stream->multipleOf);
-
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_stream_alloc_bufs err = %d",  rc);
-        free(pBufs);
-        free(reg_flags);
-        return rc;
-    }
-
-    for (i = 0; i < stream->num_of_bufs; i++) {
-        /* mapping stream bufs first */
-        pBufs[i] = stream->s_bufs[i].buf;
-        reg_flags[i] = 1;
-        rc = ops_tbl->map_ops(pBufs[i].buf_idx,
-                              -1,
-                              pBufs[i].fd,
-                              (uint32_t)pBufs[i].frame_len,
-                              NULL,
-                              CAM_MAPPING_BUF_TYPE_STREAM_BUF, ops_tbl->userdata);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mapping buf[%d] err = %d",  i, rc);
-            break;
-        }
-    }
-
-    if (rc != MM_CAMERA_OK) {
-        int j;
-        for (j=0; j>i; j++) {
-            ops_tbl->unmap_ops(pBufs[j].buf_idx, -1,
-                    CAM_MAPPING_BUF_TYPE_STREAM_BUF, ops_tbl->userdata);
-        }
-        mm_app_release_bufs(stream->num_of_bufs, &stream->s_bufs[0]);
-        free(pBufs);
-        free(reg_flags);
-        return rc;
-    }
-
-    *num_bufs = stream->num_of_bufs;
-    *bufs = pBufs;
-    *initial_reg_flag = reg_flags;
-
-    LOGD("X");
-    return rc;
-}
-
-int32_t mm_app_stream_deinitbuf(mm_camera_map_unmap_ops_tbl_t *ops_tbl,
-                                void *user_data)
-{
-    mm_camera_stream_t *stream = (mm_camera_stream_t *)user_data;
-    int i;
-
-    for (i = 0; i < stream->num_of_bufs ; i++) {
-        /* mapping stream bufs first */
-        ops_tbl->unmap_ops(stream->s_bufs[i].buf.buf_idx, -1,
-                CAM_MAPPING_BUF_TYPE_STREAM_BUF, ops_tbl->userdata);
-    }
-
-    mm_app_release_bufs(stream->num_of_bufs, &stream->s_bufs[0]);
-
-    LOGD("X");
-    return 0;
-}
-
-int32_t mm_app_stream_clean_invalidate_buf(uint32_t index, void *user_data)
-{
-    mm_camera_stream_t *stream = (mm_camera_stream_t *)user_data;
-    return mm_app_cache_ops(&stream->s_bufs[index].mem_info,
-      ION_IOC_CLEAN_INV_CACHES);
-}
-
-int32_t mm_app_stream_invalidate_buf(uint32_t index, void *user_data)
-{
-    mm_camera_stream_t *stream = (mm_camera_stream_t *)user_data;
-    return mm_app_cache_ops(&stream->s_bufs[index].mem_info, ION_IOC_INV_CACHES);
-}
-
-static void notify_evt_cb(uint32_t camera_handle,
-                          mm_camera_event_t *evt,
-                          void *user_data)
-{
-    mm_camera_test_obj_t *test_obj =
-        (mm_camera_test_obj_t *)user_data;
-    if (test_obj == NULL || test_obj->cam->camera_handle != camera_handle) {
-        LOGE("Not a valid test obj");
-        return;
-    }
-
-    LOGD("E evt = %d",  evt->server_event_type);
-    switch (evt->server_event_type) {
-       case CAM_EVENT_TYPE_AUTO_FOCUS_DONE:
-           LOGD("rcvd auto focus done evt");
-           break;
-       case CAM_EVENT_TYPE_ZOOM_DONE:
-           LOGD("rcvd zoom done evt");
-           break;
-       default:
-           break;
-    }
-
-    LOGD("X");
-}
-
-int mm_app_open(mm_camera_app_t *cam_app,
-                int cam_id,
-                mm_camera_test_obj_t *test_obj)
-{
-    int32_t rc = 0;
-    cam_frame_len_offset_t offset_info;
-
-    LOGD("BEGIN\n");
-
-    rc = cam_app->hal_lib.mm_camera_open((uint8_t)cam_id, &(test_obj->cam));
-    if(rc || !test_obj->cam) {
-        LOGE("dev open error. rc = %d, vtbl = %p\n",  rc, test_obj->cam);
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    LOGD("Open Camera id = %d handle = %d", cam_id, test_obj->cam->camera_handle);
-
-    /* alloc ion mem for capability buf */
-    memset(&offset_info, 0, sizeof(offset_info));
-    offset_info.frame_len = sizeof(cam_capability_t);
-
-    rc = mm_app_alloc_bufs(&test_obj->cap_buf,
-                           &offset_info,
-                           1,
-                           0,
-                           0);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("alloc buf for capability error\n");
-        goto error_after_cam_open;
-    }
-
-    /* mapping capability buf */
-    rc = test_obj->cam->ops->map_buf(test_obj->cam->camera_handle,
-                                     CAM_MAPPING_BUF_TYPE_CAPABILITY,
-                                     test_obj->cap_buf.mem_info.fd,
-                                     test_obj->cap_buf.mem_info.size,
-                                     NULL);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("map for capability error\n");
-        goto error_after_cap_buf_alloc;
-    }
-
-    /* alloc ion mem for getparm buf */
-    memset(&offset_info, 0, sizeof(offset_info));
-    offset_info.frame_len = sizeof(parm_buffer_t);
-    rc = mm_app_alloc_bufs(&test_obj->parm_buf,
-                           &offset_info,
-                           1,
-                           0,
-                           0);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("alloc buf for getparm_buf error\n");
-        goto error_after_cap_buf_map;
-    }
-
-    /* mapping getparm buf */
-    rc = test_obj->cam->ops->map_buf(test_obj->cam->camera_handle,
-                                     CAM_MAPPING_BUF_TYPE_PARM_BUF,
-                                     test_obj->parm_buf.mem_info.fd,
-                                     test_obj->parm_buf.mem_info.size,
-                                     NULL);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("map getparm_buf error\n");
-        goto error_after_getparm_buf_alloc;
-    }
-    test_obj->params_buffer = (parm_buffer_t*) test_obj->parm_buf.mem_info.data;
-    LOGH("\n%s params_buffer=%p\n",test_obj->params_buffer);
-
-    rc = test_obj->cam->ops->register_event_notify(test_obj->cam->camera_handle,
-                                                   notify_evt_cb,
-                                                   test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("failed register_event_notify");
-        rc = -MM_CAMERA_E_GENERAL;
-        goto error_after_getparm_buf_map;
-    }
-
-    rc = test_obj->cam->ops->query_capability(test_obj->cam->camera_handle);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("failed query_capability");
-        rc = -MM_CAMERA_E_GENERAL;
-        goto error_after_getparm_buf_map;
-    }
-    memset(&test_obj->jpeg_ops, 0, sizeof(mm_jpeg_ops_t));
-    mm_dimension pic_size;
-    memset(&pic_size, 0, sizeof(mm_dimension));
-    pic_size.w = 4000;
-    pic_size.h = 3000;
-    test_obj->jpeg_hdl = cam_app->hal_lib.jpeg_open(&test_obj->jpeg_ops, NULL, pic_size, NULL);
-    if (test_obj->jpeg_hdl == 0) {
-        LOGE("jpeg lib open err");
-        rc = -MM_CAMERA_E_GENERAL;
-        goto error_after_getparm_buf_map;
-    }
-
-    return rc;
-
-error_after_getparm_buf_map:
-    test_obj->cam->ops->unmap_buf(test_obj->cam->camera_handle,
-                                  CAM_MAPPING_BUF_TYPE_PARM_BUF);
-error_after_getparm_buf_alloc:
-    mm_app_release_bufs(1, &test_obj->parm_buf);
-error_after_cap_buf_map:
-    test_obj->cam->ops->unmap_buf(test_obj->cam->camera_handle,
-                                  CAM_MAPPING_BUF_TYPE_CAPABILITY);
-error_after_cap_buf_alloc:
-    mm_app_release_bufs(1, &test_obj->cap_buf);
-error_after_cam_open:
-    test_obj->cam->ops->close_camera(test_obj->cam->camera_handle);
-    test_obj->cam = NULL;
-    return rc;
-}
-
-int init_batch_update(parm_buffer_t *p_table)
-{
-    int rc = MM_CAMERA_OK;
-    LOGH("\nEnter %s\n");
-    int32_t hal_version = CAM_HAL_V1;
-
-    memset(p_table, 0, sizeof(parm_buffer_t));
-    if(ADD_SET_PARAM_ENTRY_TO_BATCH(p_table, CAM_INTF_PARM_HAL_VERSION, hal_version)) {
-        rc = -1;
-    }
-
-    return rc;
-}
-
-int commit_set_batch(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    int i = 0;
-
-    for(i = 0; i < CAM_INTF_PARM_MAX; i++){
-        if(test_obj->params_buffer->is_valid[i])
-            break;
-    }
-    if (i < CAM_INTF_PARM_MAX) {
-        LOGH("\n set_param p_buffer =%p\n",test_obj->params_buffer);
-        rc = test_obj->cam->ops->set_parms(test_obj->cam->camera_handle, test_obj->params_buffer);
-    }
-    if (rc != MM_CAMERA_OK) {
-        LOGE("cam->ops->set_parms failed !!");
-    }
-    return rc;
-}
-
-int mm_app_close(mm_camera_test_obj_t *test_obj)
-{
-    int32_t rc = MM_CAMERA_OK;
-
-    if (test_obj == NULL || test_obj->cam ==NULL) {
-        LOGE("cam not opened");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    /* unmap capability buf */
-    rc = test_obj->cam->ops->unmap_buf(test_obj->cam->camera_handle,
-                                       CAM_MAPPING_BUF_TYPE_CAPABILITY);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("unmap capability buf failed, rc=%d",  rc);
-    }
-
-    /* unmap parm buf */
-    rc = test_obj->cam->ops->unmap_buf(test_obj->cam->camera_handle,
-                                       CAM_MAPPING_BUF_TYPE_PARM_BUF);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("unmap setparm buf failed, rc=%d",  rc);
-    }
-
-    rc = test_obj->cam->ops->close_camera(test_obj->cam->camera_handle);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("close camera failed, rc=%d",  rc);
-    }
-    test_obj->cam = NULL;
-
-    /* close jpeg client */
-    if (test_obj->jpeg_hdl && test_obj->jpeg_ops.close) {
-        rc = test_obj->jpeg_ops.close(test_obj->jpeg_hdl);
-        test_obj->jpeg_hdl = 0;
-        if (rc != MM_CAMERA_OK) {
-            LOGE("close jpeg failed, rc=%d",  rc);
-        }
-    }
-
-    /* dealloc capability buf */
-    rc = mm_app_release_bufs(1, &test_obj->cap_buf);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("release capability buf failed, rc=%d",  rc);
-    }
-
-    /* dealloc parm buf */
-    rc = mm_app_release_bufs(1, &test_obj->parm_buf);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("release setparm buf failed, rc=%d",  rc);
-    }
-
-    return MM_CAMERA_OK;
-}
-
-mm_camera_channel_t * mm_app_add_channel(mm_camera_test_obj_t *test_obj,
-                                         mm_camera_channel_type_t ch_type,
-                                         mm_camera_channel_attr_t *attr,
-                                         mm_camera_buf_notify_t channel_cb,
-                                         void *userdata)
-{
-    uint32_t ch_id = 0;
-    mm_camera_channel_t *channel = NULL;
-
-    ch_id = test_obj->cam->ops->add_channel(test_obj->cam->camera_handle,
-                                            attr,
-                                            channel_cb,
-                                            userdata);
-    if (ch_id == 0) {
-        LOGE("add channel failed");
-        return NULL;
-    }
-    channel = &test_obj->channels[ch_type];
-    channel->ch_id = ch_id;
-    return channel;
-}
-
-int mm_app_del_channel(mm_camera_test_obj_t *test_obj,
-                       mm_camera_channel_t *channel)
-{
-    test_obj->cam->ops->delete_channel(test_obj->cam->camera_handle,
-                                       channel->ch_id);
-    memset(channel, 0, sizeof(mm_camera_channel_t));
-    return MM_CAMERA_OK;
-}
-
-mm_camera_stream_t * mm_app_add_stream(mm_camera_test_obj_t *test_obj,
-                                       mm_camera_channel_t *channel)
-{
-    mm_camera_stream_t *stream = NULL;
-    int rc = MM_CAMERA_OK;
-    cam_frame_len_offset_t offset_info;
-
-    stream = &(channel->streams[channel->num_streams++]);
-    stream->s_id = test_obj->cam->ops->add_stream(test_obj->cam->camera_handle,
-                                                  channel->ch_id);
-    if (stream->s_id == 0) {
-        LOGE("add stream failed");
-        return NULL;
-    }
-
-    stream->multipleOf = test_obj->slice_size;
-
-    /* alloc ion mem for stream_info buf */
-    memset(&offset_info, 0, sizeof(offset_info));
-    offset_info.frame_len = sizeof(cam_stream_info_t);
-
-    rc = mm_app_alloc_bufs(&stream->s_info_buf,
-                           &offset_info,
-                           1,
-                           0,
-                           0);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("alloc buf for stream_info error\n");
-        test_obj->cam->ops->delete_stream(test_obj->cam->camera_handle,
-                                          channel->ch_id,
-                                          stream->s_id);
-        stream->s_id = 0;
-        return NULL;
-    }
-
-    /* mapping streaminfo buf */
-    rc = test_obj->cam->ops->map_stream_buf(test_obj->cam->camera_handle,
-                                            channel->ch_id,
-                                            stream->s_id,
-                                            CAM_MAPPING_BUF_TYPE_STREAM_INFO,
-                                            0,
-                                            -1,
-                                            stream->s_info_buf.mem_info.fd,
-                                            (uint32_t)stream->s_info_buf.mem_info.size, NULL);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("map setparm_buf error\n");
-        mm_app_deallocate_ion_memory(&stream->s_info_buf);
-        test_obj->cam->ops->delete_stream(test_obj->cam->camera_handle,
-                                          channel->ch_id,
-                                          stream->s_id);
-        stream->s_id = 0;
-        return NULL;
-    }
-
-    return stream;
-}
-
-int mm_app_del_stream(mm_camera_test_obj_t *test_obj,
-                      mm_camera_channel_t *channel,
-                      mm_camera_stream_t *stream)
-{
-    test_obj->cam->ops->unmap_stream_buf(test_obj->cam->camera_handle,
-                                         channel->ch_id,
-                                         stream->s_id,
-                                         CAM_MAPPING_BUF_TYPE_STREAM_INFO,
-                                         0,
-                                         -1);
-    mm_app_deallocate_ion_memory(&stream->s_info_buf);
-    test_obj->cam->ops->delete_stream(test_obj->cam->camera_handle,
-                                      channel->ch_id,
-                                      stream->s_id);
-    memset(stream, 0, sizeof(mm_camera_stream_t));
-    return MM_CAMERA_OK;
-}
-
-mm_camera_channel_t *mm_app_get_channel_by_type(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_type_t ch_type)
-{
-    return &test_obj->channels[ch_type];
-}
-
-int mm_app_config_stream(mm_camera_test_obj_t *test_obj,
-                         mm_camera_channel_t *channel,
-                         mm_camera_stream_t *stream,
-                         mm_camera_stream_config_t *config)
-{
-    return test_obj->cam->ops->config_stream(test_obj->cam->camera_handle,
-                                             channel->ch_id,
-                                             stream->s_id,
-                                             config);
-}
-
-int mm_app_start_channel(mm_camera_test_obj_t *test_obj,
-                         mm_camera_channel_t *channel)
-{
-    return test_obj->cam->ops->start_channel(test_obj->cam->camera_handle,
-                                             channel->ch_id);
-}
-
-int mm_app_stop_channel(mm_camera_test_obj_t *test_obj,
-                        mm_camera_channel_t *channel)
-{
-    return test_obj->cam->ops->stop_channel(test_obj->cam->camera_handle,
-                                            channel->ch_id);
-}
-
-int initBatchUpdate(mm_camera_test_obj_t *test_obj)
-{
-    int32_t hal_version = CAM_HAL_V1;
-
-    parm_buffer_t *parm_buf = ( parm_buffer_t * ) test_obj->parm_buf.mem_info.data;
-    memset(parm_buf, 0, sizeof(parm_buffer_t));
-    ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_HAL_VERSION, hal_version);
-
-    return MM_CAMERA_OK;
-}
-
-int commitSetBatch(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    int i = 0;
-
-    parm_buffer_t *p_table = ( parm_buffer_t * ) test_obj->parm_buf.mem_info.data;
-    for(i = 0; i < CAM_INTF_PARM_MAX; i++){
-        if(p_table->is_valid[i])
-            break;
-    }
-    if (i < CAM_INTF_PARM_MAX) {
-        rc = test_obj->cam->ops->set_parms(test_obj->cam->camera_handle, p_table);
-    }
-    return rc;
-}
-
-
-int commitGetBatch(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    int i = 0;
-    parm_buffer_t *p_table = ( parm_buffer_t * ) test_obj->parm_buf.mem_info.data;
-    for(i = 0; i < CAM_INTF_PARM_MAX; i++){
-        if(p_table->is_valid[i])
-            break;
-    }
-    if (i < CAM_INTF_PARM_MAX) {
-        rc = test_obj->cam->ops->get_parms(test_obj->cam->camera_handle, p_table);
-    }
-    return rc;
-}
-
-int setAecLock(mm_camera_test_obj_t *test_obj, int value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_AEC_LOCK, (uint32_t)value)) {
-        LOGE("AEC Lock parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setAwbLock(mm_camera_test_obj_t *test_obj, int value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_AWB_LOCK, (uint32_t)value)) {
-        LOGE("AWB Lock parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-
-int set3Acommand(mm_camera_test_obj_t *test_obj, cam_eztune_cmd_data_t *value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_EZTUNE_CMD, *value)) {
-        LOGE("CAM_INTF_PARM_EZTUNE_CMD parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setAutoFocusTuning(mm_camera_test_obj_t *test_obj, tune_actuator_t *value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_SET_AUTOFOCUSTUNING, *value)) {
-        LOGE("AutoFocus Tuning not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setVfeCommand(mm_camera_test_obj_t *test_obj, tune_cmd_t *value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_SET_VFE_COMMAND, *value)) {
-        LOGE("VFE Command not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setmetainfoCommand(mm_camera_test_obj_t *test_obj, cam_stream_size_info_t *value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_META_STREAM_INFO, *value)) {
-        LOGE("PP Command not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-
-int setPPCommand(mm_camera_test_obj_t *test_obj, tune_cmd_t *value)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_SET_PP_COMMAND, *value)) {
-        LOGE("PP Command not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setFocusMode(mm_camera_test_obj_t *test_obj, cam_focus_mode_type mode)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    uint32_t value = mode;
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_FOCUS_MODE, value)) {
-        LOGE("Focus mode parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setEVCompensation(mm_camera_test_obj_t *test_obj, int ev)
-{
-    int rc = MM_CAMERA_OK;
-
-    cam_capability_t *camera_cap = NULL;
-
-    camera_cap = (cam_capability_t *) test_obj->cap_buf.mem_info.data;
-    if ( (ev >= camera_cap->exposure_compensation_min) &&
-         (ev <= camera_cap->exposure_compensation_max) ) {
-
-        rc = initBatchUpdate(test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("Batch camera parameter update failed\n");
-            goto ERROR;
-        }
-
-        if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-                CAM_INTF_PARM_EXPOSURE_COMPENSATION, ev)) {
-            LOGE("EV compensation parameter not added to batch\n");
-            rc = -1;
-            goto ERROR;
-        }
-
-        rc = commitSetBatch(test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("Batch parameters commit failed\n");
-            goto ERROR;
-        }
-
-        LOGE("EV compensation set to: %d",  ev);
-    } else {
-        LOGE("Invalid EV compensation");
-        return -EINVAL;
-    }
-
-ERROR:
-    return rc;
-}
-
-int setAntibanding(mm_camera_test_obj_t *test_obj, cam_antibanding_mode_type antibanding)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_ANTIBANDING, antibanding)) {
-        LOGE("Antibanding parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Antibanding set to: %d",  (int)antibanding);
-
-ERROR:
-    return rc;
-}
-
-int setWhiteBalance(mm_camera_test_obj_t *test_obj, cam_wb_mode_type mode)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_WHITE_BALANCE, mode)) {
-        LOGE("White balance parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("White balance set to: %d",  (int)mode);
-
-ERROR:
-    return rc;
-}
-
-int setExposureMetering(mm_camera_test_obj_t *test_obj, cam_auto_exposure_mode_type mode)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_EXPOSURE, mode)) {
-        LOGE("Exposure metering parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Exposure metering set to: %d",  (int)mode);
-
-ERROR:
-    return rc;
-}
-
-int setBrightness(mm_camera_test_obj_t *test_obj, int brightness)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_BRIGHTNESS, brightness)) {
-        LOGE("Brightness parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Brightness set to: %d",  brightness);
-
-ERROR:
-    return rc;
-}
-
-int setContrast(mm_camera_test_obj_t *test_obj, int contrast)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_CONTRAST, contrast)) {
-        LOGE("Contrast parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Contrast set to: %d",  contrast);
-
-ERROR:
-    return rc;
-}
-
-int setTintless(mm_camera_test_obj_t *test_obj, int tintless)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_TINTLESS, tintless)) {
-        LOGE("Tintless parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("set Tintless to: %d",  tintless);
-
-ERROR:
-    return rc;
-}
-
-int setSaturation(mm_camera_test_obj_t *test_obj, int saturation)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_SATURATION, saturation)) {
-        LOGE("Saturation parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Saturation set to: %d",  saturation);
-
-ERROR:
-    return rc;
-}
-
-int setSharpness(mm_camera_test_obj_t *test_obj, int sharpness)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_SHARPNESS, sharpness)) {
-        LOGE("Sharpness parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    test_obj->reproc_sharpness = sharpness;
-    LOGE("Sharpness set to: %d",  sharpness);
-
-ERROR:
-    return rc;
-}
-
-int setISO(mm_camera_test_obj_t *test_obj, cam_iso_mode_type iso)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    cam_intf_parm_manual_3a_t iso_settings;
-    memset(&iso_settings, 0, sizeof(cam_intf_parm_manual_3a_t));
-    iso_settings.previewOnly = FALSE;
-    iso_settings.value = (uint64_t)iso;
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_ISO, iso_settings)) {
-        LOGE("ISO parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("ISO set to: %d",  (int)iso);
-
-ERROR:
-    return rc;
-}
-
-int setZoom(mm_camera_test_obj_t *test_obj, int zoom)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_ZOOM, zoom)) {
-        LOGE("Zoom parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Zoom set to: %d",  zoom);
-
-ERROR:
-    return rc;
-}
-
-int setFPSRange(mm_camera_test_obj_t *test_obj, cam_fps_range_t range)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_FPS_RANGE, range)) {
-        LOGE("FPS range parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("FPS Range set to: [%5.2f:%5.2f]",
-            range.min_fps,
-            range.max_fps);
-
-ERROR:
-    return rc;
-}
-
-int setScene(mm_camera_test_obj_t *test_obj, cam_scene_mode_type scene)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_BESTSHOT_MODE, scene)) {
-        LOGE("Scene parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Scene set to: %d",  (int)scene);
-
-ERROR:
-    return rc;
-}
-
-int setFlash(mm_camera_test_obj_t *test_obj, cam_flash_mode_t flash)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_LED_MODE, flash)) {
-        LOGE("Flash parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-    LOGE("Flash set to: %d",  (int)flash);
-
-ERROR:
-    return rc;
-}
-
-int setWNR(mm_camera_test_obj_t *test_obj, uint8_t enable)
-{
-    int rc = MM_CAMERA_OK;
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    cam_denoise_param_t param;
-    memset(&param, 0, sizeof(cam_denoise_param_t));
-    param.denoise_enable = enable;
-    param.process_plates = CAM_WAVELET_DENOISE_YCBCR_PLANE;
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-            CAM_INTF_PARM_WAVELET_DENOISE, param)) {
-        LOGE("WNR enabled parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-
-    test_obj->reproc_wnr = param;
-    LOGE("WNR enabled: %d",  enable);
-
-ERROR:
-    return rc;
-}
-
-int setEZTune(mm_camera_test_obj_t *test_obj, uint8_t enable)
-{
-    test_obj->enable_EZTune = enable;
-    return 0;
-}
-/** tuneserver_capture
- *    @lib_handle: the camera handle object
- *    @dim: snapshot dimensions
- *
- *  makes JPEG capture
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-int tuneserver_capture(mm_camera_lib_handle *lib_handle,
-                       mm_camera_lib_snapshot_params *dim)
-{
-    int rc = 0;
-
-    printf("Take jpeg snapshot\n");
-    if ( lib_handle->stream_running ) {
-
-        if ( lib_handle->test_obj.zsl_enabled) {
-            if ( NULL != dim) {
-                if ( ( lib_handle->test_obj.buffer_width != dim->width) ||
-                     ( lib_handle->test_obj.buffer_height = dim->height ) ) {
-
-                    lib_handle->test_obj.buffer_width = dim->width;
-                    lib_handle->test_obj.buffer_height = dim->height;
-
-                    rc = mm_camera_lib_stop_stream(lib_handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_stop_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-
-                    rc = mm_camera_lib_start_stream(lib_handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_start_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-                }
-
-            }
-
-            lib_handle->test_obj.encodeJpeg = 1;
-
-            mm_camera_app_wait();
-        } else {
-            // For standard 2D capture streaming has to be disabled first
-            rc = mm_camera_lib_stop_stream(lib_handle);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_camera_lib_stop_stream() err=%d\n",
-                          rc);
-                goto EXIT;
-            }
-
-            if ( NULL != dim ) {
-                lib_handle->test_obj.buffer_width = dim->width;
-                lib_handle->test_obj.buffer_height = dim->height;
-            }
-            rc = mm_app_start_capture(&lib_handle->test_obj, 1);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_start_capture() err=%d\n",
-                          rc);
-                goto EXIT;
-            }
-
-            mm_camera_app_wait();
-
-            rc = mm_app_stop_capture(&lib_handle->test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_stop_capture() err=%d\n",
-                          rc);
-                goto EXIT;
-            }
-
-            // Restart streaming after capture is done
-            rc = mm_camera_lib_start_stream(lib_handle);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_camera_lib_start_stream() err=%d\n",
-                          rc);
-                goto EXIT;
-            }
-        }
-    }
-
-EXIT:
-
-    return rc;
-}
-
-int mm_app_start_regression_test(int run_tc)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_app_t my_cam_app;
-
-    LOGD("\nCamera Test Application\n");
-    memset(&my_cam_app, 0, sizeof(mm_camera_app_t));
-
-    rc = mm_app_load_hal(&my_cam_app);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_app_load_hal failed !!");
-        return rc;
-    }
-
-    if(run_tc) {
-        rc = mm_app_unit_test_entry(&my_cam_app);
-        return rc;
-    }
-#if 0
-    if(run_dual_tc) {
-        printf("\tRunning Dual camera test engine only\n");
-        rc = mm_app_dual_test_entry(&my_cam_app);
-        printf("\t Dual camera engine. EXIT(%d)!!!\n", rc);
-        exit(rc);
-    }
-#endif
-    return rc;
-}
-
-int32_t mm_camera_load_tuninglibrary(mm_camera_tuning_lib_params_t *tuning_param)
-{
-  void *(*tuning_open_lib)(void) = NULL;
-
-  LOGD("E");
-  tuning_param->lib_handle = dlopen("libmmcamera_tuning.so", RTLD_NOW);
-  if (!tuning_param->lib_handle) {
-    LOGE("Failed opening libmmcamera_tuning.so\n");
-    return -EINVAL;
-  }
-
-  *(void **)&tuning_open_lib  = dlsym(tuning_param->lib_handle,
-    "open_tuning_lib");
-  if (!tuning_open_lib) {
-    LOGE("Failed symbol libmmcamera_tuning.so\n");
-    return -EINVAL;
-  }
-
-  if (tuning_param->func_tbl) {
-    LOGE("already loaded tuninglib..");
-    return 0;
-  }
-
-  tuning_param->func_tbl = (mm_camera_tune_func_t *)tuning_open_lib();
-  if (!tuning_param->func_tbl) {
-    LOGE("Failed opening library func table ptr\n");
-    return -EINVAL;
-  }
-
-  LOGD("X");
-  return 0;
-}
-
-int mm_camera_lib_open(mm_camera_lib_handle *handle, int cam_id)
-{
-    int rc = MM_CAMERA_OK;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    memset(handle, 0, sizeof(mm_camera_lib_handle));
-    rc = mm_app_load_hal(&handle->app_ctx);
-    if( MM_CAMERA_OK != rc ) {
-        LOGE("mm_app_init err\n");
-        goto EXIT;
-    }
-
-    handle->test_obj.buffer_width = DEFAULT_PREVIEW_WIDTH;
-    handle->test_obj.buffer_height = DEFAULT_PREVIEW_HEIGHT;
-    handle->test_obj.buffer_format = DEFAULT_SNAPSHOT_FORMAT;
-    handle->current_params.stream_width = DEFAULT_SNAPSHOT_WIDTH;
-    handle->current_params.stream_height = DEFAULT_SNAPSHOT_HEIGHT;
-    handle->current_params.af_mode = CAM_FOCUS_MODE_AUTO; // Default to auto focus mode
-    rc = mm_app_open(&handle->app_ctx, (uint8_t)cam_id, &handle->test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                    cam_id, rc);
-        goto EXIT;
-    }
-
-    //rc = mm_app_initialize_fb(&handle->test_obj);
-    rc = MM_CAMERA_OK;
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_app_initialize_fb() cam_idx=%d, err=%d\n",
-                    cam_id, rc);
-        goto EXIT;
-    }
-
-EXIT:
-
-    return rc;
-}
-
-int mm_camera_lib_start_stream(mm_camera_lib_handle *handle)
-{
-    int rc = MM_CAMERA_OK;
-    cam_capability_t camera_cap;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    if ( handle->test_obj.zsl_enabled ) {
-        rc = mm_app_start_preview_zsl(&handle->test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_start_preview_zsl() err=%d\n",
-                        rc);
-            goto EXIT;
-        }
-    } else {
-        handle->test_obj.enable_reproc = ENABLE_REPROCESSING;
-        rc = mm_app_start_preview(&handle->test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_start_preview() err=%d\n",
-                        rc);
-            goto EXIT;
-        }
-    }
-
-    // Configure focus mode after stream starts
-    rc = mm_camera_lib_get_caps(handle, &camera_cap);
-    if ( MM_CAMERA_OK != rc ) {
-      LOGE("mm_camera_lib_get_caps() err=%d\n",  rc);
-      return -1;
-    }
-    if (camera_cap.supported_focus_modes_cnt == 1 &&
-      camera_cap.supported_focus_modes[0] == CAM_FOCUS_MODE_FIXED) {
-      LOGD("focus not supported");
-      handle->test_obj.focus_supported = 0;
-      handle->current_params.af_mode = CAM_FOCUS_MODE_FIXED;
-    } else {
-      handle->test_obj.focus_supported = 1;
-    }
-    rc = setFocusMode(&handle->test_obj, handle->current_params.af_mode);
-    if (rc != MM_CAMERA_OK) {
-      LOGE("autofocus error\n");
-      goto EXIT;
-    }
-    handle->stream_running = 1;
-
-EXIT:
-    return rc;
-}
-
-int mm_camera_lib_stop_stream(mm_camera_lib_handle *handle)
-{
-    int rc = MM_CAMERA_OK;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    if ( handle->test_obj.zsl_enabled ) {
-        rc = mm_app_stop_preview_zsl(&handle->test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_stop_preview_zsl() err=%d\n",
-                        rc);
-            goto EXIT;
-        }
-    } else {
-        rc = mm_app_stop_preview(&handle->test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_stop_preview() err=%d\n",
-                        rc);
-            goto EXIT;
-        }
-    }
-
-    handle->stream_running = 0;
-
-EXIT:
-    return rc;
-}
-
-int mm_camera_lib_get_caps(mm_camera_lib_handle *handle,
-                           cam_capability_t *caps)
-{
-    int rc = MM_CAMERA_OK;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    if ( NULL == caps ) {
-        LOGE(" Invalid capabilities structure");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    *caps = *( (cam_capability_t *) handle->test_obj.cap_buf.mem_info.data );
-
-EXIT:
-
-    return rc;
-}
-
-
-int mm_camera_lib_send_command(mm_camera_lib_handle *handle,
-                               mm_camera_lib_commands cmd,
-                               void *in_data,
-                               __unused void *out_data)
-{
-    uint32_t width, height;
-    int rc = MM_CAMERA_OK;
-    cam_capability_t *camera_cap = NULL;
-    mm_camera_lib_snapshot_params *dim = NULL;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    camera_cap = (cam_capability_t *) handle->test_obj.cap_buf.mem_info.data;
-
-    switch(cmd) {
-        case MM_CAMERA_LIB_EZTUNE_ENABLE:
-            if ( NULL != in_data) {
-                int enable_eztune = *(( int * )in_data);
-                if ( ( enable_eztune != handle->test_obj.enable_EZTune) &&
-                        handle->stream_running ) {
-                    rc = mm_camera_lib_stop_stream(handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_stop_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-                    handle->test_obj.enable_EZTune= enable_eztune;
-                    rc = mm_camera_lib_start_stream(handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_start_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-                } else {
-                    handle->test_obj.enable_EZTune= enable_eztune;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_FLASH:
-            if ( NULL != in_data ) {
-                cam_flash_mode_t flash = *(( int * )in_data);
-                rc = setFlash(&handle->test_obj, flash);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setFlash() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_BESTSHOT:
-            if ( NULL != in_data ) {
-                cam_scene_mode_type scene = *(( int * )in_data);
-                rc = setScene(&handle->test_obj, scene);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setScene() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_ZOOM:
-            if ( NULL != in_data ) {
-                int zoom = *(( int * )in_data);
-                rc = setZoom(&handle->test_obj, zoom);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setZoom() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_ISO:
-            if ( NULL != in_data ) {
-                cam_iso_mode_type iso = *(( int * )in_data);
-                rc = setISO(&handle->test_obj, iso);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setISO() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_SHARPNESS:
-            if ( NULL != in_data ) {
-                int sharpness = *(( int * )in_data);
-                rc = setSharpness(&handle->test_obj, sharpness);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setSharpness() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_SATURATION:
-            if ( NULL != in_data ) {
-                int saturation = *(( int * )in_data);
-                rc = setSaturation(&handle->test_obj, saturation);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setSaturation() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_CONTRAST:
-            if ( NULL != in_data ) {
-                int contrast = *(( int * )in_data);
-                rc = setContrast(&handle->test_obj, contrast);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setContrast() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_SET_TINTLESS:
-            if ( NULL != in_data ) {
-                int tintless = *(( int * )in_data);
-                rc = setTintless(&handle->test_obj, tintless);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("enlabe/disable:%d tintless() err=%d\n",
-                                    tintless, rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_BRIGHTNESS:
-            if ( NULL != in_data ) {
-                int brightness = *(( int * )in_data);
-                rc = setBrightness(&handle->test_obj, brightness);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setBrightness() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_EXPOSURE_METERING:
-            if ( NULL != in_data ) {
-                cam_auto_exposure_mode_type exp = *(( int * )in_data);
-                rc = setExposureMetering(&handle->test_obj, exp);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setExposureMetering() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_WB:
-            if ( NULL != in_data ) {
-                cam_wb_mode_type wb = *(( int * )in_data);
-                rc = setWhiteBalance(&handle->test_obj, wb);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setWhiteBalance() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_ANTIBANDING:
-            if ( NULL != in_data ) {
-                int antibanding = *(( int * )in_data);
-                rc = setAntibanding(&handle->test_obj, antibanding);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setAntibanding() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_EV:
-            if ( NULL != in_data ) {
-                int ev = *(( int * )in_data);
-                rc = setEVCompensation(&handle->test_obj, ev);
-                if (rc != MM_CAMERA_OK) {
-                        LOGE("setEVCompensation() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_ZSL_ENABLE:
-            if ( NULL != in_data) {
-                int enable_zsl = *(( int * )in_data);
-                if ( ( enable_zsl != handle->test_obj.zsl_enabled ) &&
-                        handle->stream_running ) {
-                    rc = mm_camera_lib_stop_stream(handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_stop_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-                    handle->test_obj.zsl_enabled = enable_zsl;
-                    rc = mm_camera_lib_start_stream(handle);
-                    if (rc != MM_CAMERA_OK) {
-                        LOGE("mm_camera_lib_start_stream() err=%d\n",
-                                    rc);
-                        goto EXIT;
-                    }
-                } else {
-                    handle->test_obj.zsl_enabled = enable_zsl;
-                }
-            }
-            break;
-        case MM_CAMERA_LIB_RAW_CAPTURE:
-
-            if ( 0 == handle->stream_running ) {
-                LOGE(" Streaming is not enabled!");
-                rc = MM_CAMERA_E_INVALID_OPERATION;
-                goto EXIT;
-            }
-
-            rc = mm_camera_lib_stop_stream(handle);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_camera_lib_stop_stream() err=%d\n",
-                            rc);
-                goto EXIT;
-            }
-
-            width = handle->test_obj.buffer_width;
-            height = handle->test_obj.buffer_height;
-            handle->test_obj.buffer_width =
-                    (uint32_t)camera_cap->raw_dim[0].width;
-            handle->test_obj.buffer_height =
-                    (uint32_t)camera_cap->raw_dim[0].height;
-            handle->test_obj.buffer_format = DEFAULT_RAW_FORMAT;
-            LOGE("MM_CAMERA_LIB_RAW_CAPTURE %dx%d\n",
-                    camera_cap->raw_dim[0].width,
-                    camera_cap->raw_dim[0].height);
-            rc = mm_app_start_capture_raw(&handle->test_obj, 1);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_start_capture() err=%d\n",
-                            rc);
-                goto EXIT;
-            }
-
-            mm_camera_app_wait();
-
-            rc = mm_app_stop_capture_raw(&handle->test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_stop_capture() err=%d\n",
-                            rc);
-                goto EXIT;
-            }
-
-            handle->test_obj.buffer_width = width;
-            handle->test_obj.buffer_height = height;
-            handle->test_obj.buffer_format = DEFAULT_SNAPSHOT_FORMAT;
-            rc = mm_camera_lib_start_stream(handle);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_camera_lib_start_stream() err=%d\n",
-                            rc);
-                goto EXIT;
-            }
-
-            break;
-
-        case MM_CAMERA_LIB_JPEG_CAPTURE:
-            if ( 0 == handle->stream_running ) {
-                LOGE(" Streaming is not enabled!");
-                rc = MM_CAMERA_E_INVALID_OPERATION;
-                goto EXIT;
-            }
-
-            if ( NULL != in_data ) {
-                dim = ( mm_camera_lib_snapshot_params * ) in_data;
-            }
-
-            rc = tuneserver_capture(handle, dim);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("capture error %d\n",  rc);
-                goto EXIT;
-            }
-            break;
-
-        case MM_CAMERA_LIB_SET_FOCUS_MODE: {
-            cam_focus_mode_type mode = *((cam_focus_mode_type *)in_data);
-            handle->current_params.af_mode = mode;
-            rc = setFocusMode(&handle->test_obj, mode);
-            if (rc != MM_CAMERA_OK) {
-              LOGE("autofocus error\n");
-              goto EXIT;
-            }
-            break;
-        }
-
-        case MM_CAMERA_LIB_DO_AF:
-            if (handle->test_obj.focus_supported) {
-              rc = handle->test_obj.cam->ops->do_auto_focus(handle->test_obj.cam->camera_handle);
-              if (rc != MM_CAMERA_OK) {
-                LOGE("autofocus error\n");
-                goto EXIT;
-              }
-              /*Waiting for Auto Focus Done Call Back*/
-              mm_camera_app_wait();
-            }
-            break;
-
-        case MM_CAMERA_LIB_CANCEL_AF:
-            rc = handle->test_obj.cam->ops->cancel_auto_focus(handle->test_obj.cam->camera_handle);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("autofocus error\n");
-                goto EXIT;
-            }
-
-            break;
-
-        case MM_CAMERA_LIB_LOCK_AWB:
-            rc = setAwbLock(&handle->test_obj, 1);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("AWB locking failed\n");
-                goto EXIT;
-            }
-            break;
-
-        case MM_CAMERA_LIB_UNLOCK_AWB:
-            rc = setAwbLock(&handle->test_obj, 0);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("AE unlocking failed\n");
-                goto EXIT;
-            }
-            break;
-
-        case MM_CAMERA_LIB_LOCK_AE:
-            rc = setAecLock(&handle->test_obj, 1);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("AE locking failed\n");
-                goto EXIT;
-            }
-            break;
-
-        case MM_CAMERA_LIB_UNLOCK_AE:
-            rc = setAecLock(&handle->test_obj, 0);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("AE unlocking failed\n");
-                goto EXIT;
-            }
-            break;
-
-       case MM_CAMERA_LIB_SET_3A_COMMAND: {
-          rc = set3Acommand(&handle->test_obj, (cam_eztune_cmd_data_t *)in_data);
-          if (rc != MM_CAMERA_OK) {
-            LOGE("3A set command error\n");
-            goto EXIT;
-          }
-          break;
-        }
-
-       case MM_CAMERA_LIB_SET_AUTOFOCUS_TUNING: {
-           rc = setAutoFocusTuning(&handle->test_obj, in_data);
-           if (rc != MM_CAMERA_OK) {
-             LOGE("Set AF tuning failed\n");
-             goto EXIT;
-           }
-           break;
-       }
-
-       case MM_CAMERA_LIB_SET_VFE_COMMAND: {
-           rc = setVfeCommand(&handle->test_obj, in_data);
-           if (rc != MM_CAMERA_OK) {
-             LOGE("Set vfe command failed\n");
-             goto EXIT;
-           }
-           break;
-       }
-
-       case MM_CAMERA_LIB_SET_POSTPROC_COMMAND: {
-           rc = setPPCommand(&handle->test_obj, in_data);
-           if (rc != MM_CAMERA_OK) {
-             LOGE("Set pp command failed\n");
-             goto EXIT;
-           }
-           break;
-       }
-
-        case MM_CAMERA_LIB_WNR_ENABLE: {
-            rc = setWNR(&handle->test_obj, *((uint8_t *)in_data));
-            if ( rc != MM_CAMERA_OK) {
-                LOGE("Set wnr enable failed\n");
-                goto EXIT;
-            }
-        }
-
-      case MM_CAMERA_LIB_NO_ACTION:
-        default:
-            break;
-    };
-
-EXIT:
-
-    return rc;
-}
-int mm_camera_lib_number_of_cameras(mm_camera_lib_handle *handle)
-{
-    int rc = 0;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        goto EXIT;
-    }
-
-    rc = handle->app_ctx.num_cameras;
-
-EXIT:
-
-    return rc;
-}
-
-int mm_camera_lib_close(mm_camera_lib_handle *handle)
-{
-    int rc = MM_CAMERA_OK;
-
-    if ( NULL == handle ) {
-        LOGE(" Invalid handle");
-        rc = MM_CAMERA_E_INVALID_INPUT;
-        goto EXIT;
-    }
-
-    //rc = mm_app_close_fb(&handle->test_obj);
-    rc = MM_CAMERA_OK;
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_app_close_fb() err=%d\n",
-                    rc);
-        goto EXIT;
-    }
-
-    rc = mm_app_close(&handle->test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_app_close() err=%d\n",
-                    rc);
-        goto EXIT;
-    }
-
-EXIT:
-    return rc;
-}
-
-int mm_camera_lib_set_preview_usercb(
-   mm_camera_lib_handle *handle, cam_stream_user_cb cb)
-{
-    if (handle->test_obj.user_preview_cb != NULL) {
-        LOGE(" already set preview callbacks\n");
-        return -1;
-    }
-    handle->test_obj.user_preview_cb = *cb;
-    return 0;
-}
-
-int mm_app_set_preview_fps_range(mm_camera_test_obj_t *test_obj,
-                        cam_fps_range_t *fpsRange)
-{
-    int rc = MM_CAMERA_OK;
-    LOGH("preview fps range: min=%f, max=%f.",
-            fpsRange->min_fps, fpsRange->max_fps);
-    rc = setFPSRange(test_obj, *fpsRange);
-
-    if (rc != MM_CAMERA_OK) {
-        LOGE("add_parm_entry_tobatch failed !!");
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_set_face_detection(mm_camera_test_obj_t *test_obj,
-        cam_fd_set_parm_t *fd_set_parm)
-{
-    int rc = MM_CAMERA_OK;
-
-    if (test_obj == NULL || fd_set_parm == NULL) {
-        LOGE(" invalid params!");
-        return MM_CAMERA_E_INVALID_INPUT;
-    }
-
-    LOGH("mode = %d, num_fd = %d",
-          fd_set_parm->fd_mode, fd_set_parm->num_fd);
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-        CAM_INTF_PARM_FD, *fd_set_parm)) {
-        LOGE("FD parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int mm_app_set_flash_mode(mm_camera_test_obj_t *test_obj,
-        cam_flash_mode_t flashMode)
-{
-    int rc = MM_CAMERA_OK;
-
-    if (test_obj == NULL) {
-        LOGE(" invalid params!");
-        return MM_CAMERA_E_INVALID_INPUT;
-    }
-
-    LOGH("mode = %d",  (int)flashMode);
-
-    rc = initBatchUpdate(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch camera parameter update failed\n");
-        goto ERROR;
-    }
-
-    if (ADD_SET_PARAM_ENTRY_TO_BATCH(test_obj->parm_buf.mem_info.data,
-        CAM_INTF_PARM_LED_MODE, flashMode)) {
-        LOGE("Flash mode parameter not added to batch\n");
-        rc = -1;
-        goto ERROR;
-    }
-
-    rc = commitSetBatch(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("Batch parameters commit failed\n");
-        goto ERROR;
-    }
-
-ERROR:
-    return rc;
-}
-
-int mm_app_set_metadata_usercb(mm_camera_test_obj_t *test_obj,
-                        cam_stream_user_cb usercb)
-{
-    if (test_obj == NULL || usercb == NULL) {
-        LOGE(" invalid params!");
-        return MM_CAMERA_E_INVALID_INPUT;
-    }
-
-    LOGH("%s, set user metadata callback, addr: %p\n",  usercb);
-
-    if (test_obj->user_metadata_cb != NULL) {
-        LOGH("%s, already set user metadata callback");
-    }
-    test_obj->user_metadata_cb = usercb;
-
-    return 0;
-}
-
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
deleted file mode 100644
index 45fb7a8..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_commands.c
+++ /dev/null
@@ -1,291 +0,0 @@
-/* Copyright (c) 2012-2013, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// To remove
-#include <cutils/properties.h>
-
-// Camera dependencies
-#include "mm_qcamera_commands.h"
-#include "mm_qcamera_dbg.h"
-
-int tuneserver_initialize_prevtuningp(void * ctrl,
-  int pr_client_socket_id, cam_dimension_t dimension,
-  char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *) ctrl;
-  tuningserver_t *tctrl = &lib_handle->tsctrl;
-
-  LOGD("E");
-  if (tctrl->tuning_params.func_tbl->prevcommand_process == NULL) {
-      LOGE("prevcommand_process is NULL");
-      return -1;
-  }
-
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-      NULL, TUNE_PREVCMD_INIT, (void *)&pr_client_socket_id,
-      send_buf, send_len);
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-      NULL, TUNE_PREVCMD_SETDIM, (void *)&dimension,
-      send_buf, send_len);
-
-  mm_camera_lib_set_preview_usercb(lib_handle,
-      (tctrl->tuning_params.func_tbl->prevframe_callback));
-
-  return result;
-}
-
-int tuneserver_deinitialize_prevtuningp(void * ctrl,
-    char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-    &tctrl->pr_proto, TUNE_PREVCMD_DEINIT, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_preview_getinfo(void * ctrl, char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-    &tctrl->pr_proto, TUNE_PREVCMD_GETINFO, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_preview_getchunksize(void * ctrl,
-  char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-    &tctrl->pr_proto, TUNE_PREVCMD_GETCHUNKSIZE,
-    (void *)&tctrl->pr_proto->new_cnk_size, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_preview_getframe(void * ctrl,
-  char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-    &tctrl->pr_proto, TUNE_PREVCMD_GETFRAME, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_preview_unsupported(void * ctrl,
-  char **send_buf, uint32_t *send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->prevcommand_process(
-    &tctrl->pr_proto, TUNE_PREVCMD_UNSUPPORTED, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_initialize_tuningp(void * ctrl, int client_socket_id,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *) ctrl;
-  tuningserver_t *tctrl = &lib_handle->tsctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->command_process(
-    lib_handle, TUNE_CMD_INIT, &client_socket_id, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_deinitialize_tuningp(void * ctrl, int client_socket_id,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-
-  result = tctrl->tuning_params.func_tbl->command_process(
-    NULL, TUNE_CMD_DEINIT, &client_socket_id, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_process_get_list_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->command_process(
-     recv_cmd, TUNE_CMD_GET_LIST, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_process_get_params_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->command_process
-    (recv_cmd, TUNE_CMD_GET_PARAMS, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_process_set_params_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->command_process(
-     recv_cmd, TUNE_CMD_SET_PARAMS, NULL, send_buf, send_len);
-
-  return result;
-}
-
-int tuneserver_process_misc_cmd(void * ctrl, void *recv_cmd,
-  char *send_buf, uint32_t send_len)
-{
-  int result = 0;
-  tuningserver_t *tctrl = (tuningserver_t *) ctrl;
-
-  LOGD("E");
-  result = tctrl->tuning_params.func_tbl->command_process(
-     recv_cmd, TUNE_CMD_MISC, NULL, send_buf, send_len);
-
-  return result;
-}
-
-/** tuneserver_close_cam
- *    @lib_handle: the camera handle object
- *
- *  closes the camera
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-int tuneserver_close_cam(mm_camera_lib_handle *lib_handle)
-{
-  int result = 0;
-
-  result = mm_camera_lib_close(lib_handle);
-  if (result < 0) {
-    printf(" Camera close failed\n");
-  } else {
-    printf("Camera is closed \n");
-  }
-  return result;
-}
-#if 0
-/** tuneserver_start_cam
- *    @lib_handle: the camera handle object
- *
- *  starts the camera
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-static int tuneserver_start_cam(mm_camera_lib_handle *lib_handle)
-{
-  int result = 0;
-
-  result = mm_camera_lib_start_stream(lib_handle);
-  if (result < 0) {
-    printf(" Camera start failed\n");
-    goto error1;
-  }
-  return result;
-error1:
-  mm_camera_lib_close(lib_handle);
-  return result;
-}
-#endif
-
-/** tuneserver_stop_cam
- *    @lib_handle: the camera handle object
- *
- *  stops the camera
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-int tuneserver_stop_cam(mm_camera_lib_handle *lib_handle)
-{
-  int result = 0;
-
-  result = mm_camera_lib_stop_stream(lib_handle);
-  if (result < 0) {
-    printf(" Camera stop failed\n");
-  }
-//  result = mm_camera_lib_close(lib_handle);
-  return result;
-}
-
-/** tuneserver_open_cam
- *    @lib_handle: the camera handle object
- *
- *  opens the camera
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-#if 1
-int tuneserver_open_cam(mm_camera_lib_handle *lib_handle)
-{
-  int result = 0;
-
-  LOGD("E");
-  result = mm_camera_load_tuninglibrary(&lib_handle->tsctrl.tuning_params);
-  if (result < 0) {
-    LOGE(" tuning library open failed\n");
-  }
-  return result;
-}
-#endif
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_dual_test.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_dual_test.c
deleted file mode 100644
index 564c474..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_dual_test.c
+++ /dev/null
@@ -1,1933 +0,0 @@
-/*
-Copyright (c) 2012, 2016, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// System dependencies
-#include <pthread.h>
-
-// Camera dependencies
-#include "mm_qcamera_unit_test.h"
-#include "mm_camera_dbg.h"
-
-#define MM_QCAMERA_APP_UTEST_MAX_MAIN_LOOP 4
-#define MM_QCAM_APP_TEST_NUM 128
-
-#define MM_QCAMERA_APP_WAIT_TIME 1000000000
-
-extern int system_dimension_set(int cam_id);
-extern int stopPreview(int cam_id);
-extern int takePicture_yuv(int cam_id);
-extern int takePicture_rdi(int cam_id);
-extern int startRdi(int cam_id);
-extern int stopRdi(int cam_id);
-extern int startStats(int cam_id);
-extern int stopStats(int cam_id);
-
-
-/*
-* 1. open back
-* 2. open front
-* 3. start back
-* 4. start front
-* 5. stop back
-* 6. stop front
-* 7. close back
-* 8. close front
-* 9. take picture
-* a. start recording
-* b. stop recording
-* c. take picture rdi
-*/
-static mm_app_tc_t mm_app_tc[MM_QCAM_APP_TEST_NUM];
-static int num_test_cases = 0;
-struct test_case_params {
-  uint16_t launch;
-  uint16_t preview;
-  uint16_t recording;
-  uint16_t snapshot;
-};
-
-/*  Test case 12436857 :*/
-
-int mm_app_dtc_0(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 0...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera Preview for back \n");
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL stop camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-
-        LOGE("DUAL close front camera\n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        sleep(1);
-        LOGE("DUAL stop camera Preview for back \n");
-        if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                LOGD(" startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close back camera \n");
-        if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 12436587 :*/
-
-int mm_app_dtc_1(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 1...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera Preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-        LOGE("DUAL stop camera Preview for front \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL stop camera Preview for back \n");
-        if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                LOGD(" startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close front camera\n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL close back camera \n");
-        if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 12436578 :*/
-
-int mm_app_dtc_2(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 2...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera Preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-        LOGE("DUAL stop camera Preview for front \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL stop camera Preview for back \n");
-        if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                LOGD(" startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close back camera \n");
-        if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL close front camera\n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 241395768 : 1357 * 3, This is performed three times
-* And for each iteration 9 is performed thrice */
-
-int mm_app_dtc_3(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j,k;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview and snapshot on back Camera and RDI on Front camera 3...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for front \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() frontcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        usleep(10*1000);
-
-        for (k = 0; k < MM_QCAMERA_APP_INTERATION ; k++) {
-          LOGE("DUAL open back camera %d \n",k);
-          if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                  LOGE("mm_app_open() back camera err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-
-          if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                  LOGE("system_dimension_set() err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-
-          LOGE("DUAL start camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                 LOGE(" back camera startPreview() err=%d\n",  rc);
-                  goto end;
-          }
-
-          for (j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-              LOGE("DUAL take picture for back \n");
-              if ( MM_CAMERA_OK != (rc = takePicture_yuv(back_camera))) {
-                  LOGE(" TakePicture() err=%d\n",  rc);
-                  break;
-              }
-              mm_camera_app_wait();
-
-          }
-          usleep(10*1000);
-          LOGE("DUAL stop camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                  LOGE(" stopPreview() backcamera err=%d\n",  rc);
-                  goto end;
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL close back camera\n");
-          if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                  LOGE("mm_app_close() err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-          usleep(20*1000);
-        }
-        LOGE("DUAL stop camera Preview for Rdi \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGD(" stopRdi() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close front camera \n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 2413ab5768 : 1357 * 3, This is performed three times
-* And for each iteration ab is performed thrice */
-
-int mm_app_dtc_4(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j,k;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 4...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for front \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() frontcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        usleep(20*1000);
-
-        for (k = 0; k < MM_QCAMERA_APP_INTERATION ; k++){
-          LOGE("DUAL open back camera %d \n",k);
-          if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                 LOGE("mm_app_open() back camera err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-
-          if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                 LOGE("system_dimension_set() err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-
-          LOGE("DUAL start camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" back camera startPreview() err=%d\n",  rc);
-                 goto end;
-          }
-          usleep(30*1000);
-
-          for (j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-             LOGE("DUAL start camera record for back \n");
-             if ( MM_CAMERA_OK != (rc = startRecording(back_camera))) {
-                 LOGE(" StartVideorecording() err=%d\n",  rc);
-                 break;
-             }
-
-             mm_camera_app_wait();
-             usleep(15*1000);
-             LOGE("DUAL stop camera record for back \n");
-             if ( MM_CAMERA_OK != (rc = stopRecording(back_camera))) {
-                 LOGE(" Stopvideorecording() err=%d\n",  rc);
-                 break;
-             }
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL stop camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                 LOGE(" stopPreview() backcamera err=%d\n",  rc);
-                 goto end;
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL close back camera\n");
-          if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                 LOGE("mm_app_close() err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-          usleep(20*1000);
-        }
-        LOGE("DUAL stop camera Preview for Rdi \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGD(" stopRdi() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close front camera \n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 24135768 : 1357 * 3, This is performed three times*/
-
-int mm_app_dtc_5(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j,k;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 5...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for front \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() frontcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        for (k = 0; k < 4 ; k++) {
-          LOGE("DUAL open back camera %d \n",k);
-          if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                  LOGE("mm_app_open() back camera err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-
-          if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                  LOGE("system_dimension_set() err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-
-          LOGE("DUAL start camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                 LOGE(" back camera startPreview() err=%d\n",  rc);
-                  goto end;
-          }
-          mm_camera_app_wait();
-          sleep(1);
-
-          LOGE("DUAL stop camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                  LOGE(" stopPreview() backcamera err=%d\n",  rc);
-                  goto end;
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL close back camera\n");
-          if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                  LOGE("mm_app_close() err=%d\n", rc);
-                  rc = -1;
-                  goto end;
-          }
-          sleep(1);
-        }
-        LOGE("DUAL stop camera Preview for Rdi \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGD(" stopRdi() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close front camera \n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 13246857 : 2468 * 3, This is performed three times*/
-
-int mm_app_dtc_6(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j,k;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 6...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        for (k = 0; k < 4 ; k++) {
-        LOGE("DUAL open front camera %d \n",k);
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL stop camera Preview for front \n");
-        if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-
-        LOGE("DUAL close front camera\n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        sleep(1);
-        }
-        LOGE("DUAL stop camera Preview for back \n");
-        if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                LOGD(" startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close back camera \n");
-        if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*Multi Threaded Test Cases*/
-static void *front_thread(void *data)
-{
-        int front_camera = 1;
-        int rc = MM_CAMERA_OK;
-        int i,j,k,m;
-        struct test_case_params params
-          = *((struct test_case_params *)data);
-        for (i = 0; i < params.launch; i++) {
-          LOGE("DUAL open front camera %d\n",i);
-          if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-            LOGE("mm_app_open() front camera err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-
-          if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-            LOGE("system_dimension_set() err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-
-          for (j = 0; j < params.preview; j++) {
-            LOGE("DUAL start camera Rdi for front %d ,%d \n",i,j);
-            if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-              LOGE(" back camera startPreview() err=%d\n",  rc);
-              goto end;
-            }
-            mm_camera_app_wait();
-            usleep(20*1000);
-            for (k = 0; k < params.snapshot; k++) {
-              LOGE("DUAL take picture for front %d,%d,%d \n",i,j,k);
-              if ( MM_CAMERA_OK != (rc = takePicture_rdi(front_camera))) {
-                LOGE(" TakePicture() err=%d\n",  rc);
-                goto end;
-              }
-              mm_camera_app_wait();
-              usleep(30*1000);
-            }
-            LOGE("DUAL stop camera Rdi for front %d,%d\n",i,j);
-            if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-              LOGE(" startPreview() backcamera err=%d\n",  rc);
-              goto end;
-            }
-            usleep(10*1000);
-          }
-
-          LOGE("DUAL close front camera %d\n",i);
-          if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-            LOGE("mm_app_close() err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-        }
-end:
-        LOGE("DUAL front thread close %d",rc);
-        return NULL;
-}
-
-static void *back_thread(void *data)
-{
-        int rc = MM_CAMERA_OK;
-        int back_camera = 0;
-        int i,j,k,m;
-        struct test_case_params params
-          = *((struct test_case_params *)data);
-        for (i = 0; i < params.launch; i++) {
-          LOGE("DUAL open back camera %d\n",i);
-          if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-            LOGE("mm_app_open() back camera err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-          if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-            LOGE("system_dimension_set() err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-
-          for (j = 0; j < params.preview; j++) {
-            LOGE("DUAL start camera Preview for back %d, %d\n",i,j);
-            if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-              LOGE(" startPreview() backcamera err=%d\n",  rc);
-              goto end;
-            }
-            mm_camera_app_wait();
-            usleep(20*1000);
-            for (k = 0; k < params.snapshot; k++) {
-              LOGE("DUAL take picture for back %d, %d, %d\n",i,j,k);
-              if ( MM_CAMERA_OK != (rc = takePicture_yuv(back_camera))) {
-                LOGE(" TakePicture() err=%d\n",  rc);
-                goto end;
-              }
-              mm_camera_app_wait();
-              usleep(30*1000);
-            }
-
-            for (m = 0; m < params.recording; m++) {
-              LOGE("DUAL start record for back %d, %d, %d\n",i,j,m);
-              if ( MM_CAMERA_OK != (rc = startRecording(back_camera))) {
-                LOGE(" StartVideorecording() err=%d\n",  rc);
-                break;
-              }
-
-              mm_camera_app_wait();
-              usleep(10*1000);
-              LOGE("DUAL stop camera record for back \n");
-              if ( MM_CAMERA_OK != (rc = stopRecording(back_camera))) {
-                LOGE(" Stopvideorecording() err=%d\n",  rc);
-                break;
-              }
-              usleep(10*1000);
-            }
-            LOGE("DUAL stop camera Preview for back %d, %d\n",i,j);
-            if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-              LOGD(" startPreview() err=%d\n",  rc);
-              goto end;
-            }
-            usleep(10*1000);
-          }
-
-          LOGE("DUAL close back camera %d\n",i);
-          if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-            LOGE("mm_app_close() err=%d\n", rc);
-            rc = -1;
-            goto end;
-          }
-        }
-end:
-        LOGE("DUAL back thread close %d",rc);
-        return NULL;
-}
-
-/*  Test case m13572468 : Open & start  in 2 concurrent pthread*/
-int mm_app_dtc_7(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params params;
-        memset(&params, 0, sizeof(struct test_case_params));
-        params.launch = 5;
-        params.preview = 5;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 7...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &params);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &params);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-          printf("\nPassed\n");
-        }else{
-          printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case m139572468 : Open & start in 2 concurrent pthread*/
-int mm_app_dtc_8(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params bparams, fparams;
-        memset(&bparams, 0, sizeof(struct test_case_params));
-        memset(&fparams, 0, sizeof(struct test_case_params));
-        bparams.launch = 5;
-        bparams.preview = 5;
-        bparams.snapshot= 5;
-        fparams.launch = 5;
-        fparams.preview = 5;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 8...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &bparams);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &fparams);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0)
-          printf("\nPassed\n");
-        else
-          printf("\nFailed\n");
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case m1395724c68 : Open & start in 2 concurrent pthread*/
-int mm_app_dtc_9(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params bparams, fparams;
-        memset(&bparams, 0, sizeof(struct test_case_params));
-        memset(&fparams, 0, sizeof(struct test_case_params));
-        bparams.launch = 5;
-        bparams.preview = 5;
-        bparams.snapshot= 5;
-        fparams.launch = 5;
-        fparams.preview = 5;
-        fparams.snapshot = 5;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 9...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &bparams);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &fparams);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-          printf("\nPassed\n");
-        }else{
-          printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case m13ab572468 : Open & start in 2 concurrent pthread*/
-int mm_app_dtc_10(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params bparams, fparams;
-        memset(&bparams, 0, sizeof(struct test_case_params));
-        memset(&fparams, 0, sizeof(struct test_case_params));
-        bparams.launch = 5;
-        bparams.preview = 5;
-        bparams.recording= 5;
-        fparams.launch = 5;
-        fparams.preview = 5;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 10...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &bparams);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &fparams);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-end:
-        if(rc == 0) {
-          printf("\nPassed\n");
-        }else{
-          printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case m13ab5724c68 : Open & start in 2 concurrent pthread*/
-int mm_app_dtc_11(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params bparams, fparams;
-        memset(&bparams, 0, sizeof(struct test_case_params));
-        memset(&fparams, 0, sizeof(struct test_case_params));
-        bparams.launch = 5;
-        bparams.preview = 5;
-        bparams.recording= 5;
-        fparams.launch = 5;
-        fparams.preview = 5;
-        fparams.snapshot = 5;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 11...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &bparams);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &fparams);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case m1728 : Open & start in 2 concurrent pthread*/
-int mm_app_dtc_12(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int result = 0;
-
-        pthread_t back_thread_id, front_thread_id;
-        struct test_case_params bparams, fparams;
-        memset(&bparams, 0, sizeof(struct test_case_params));
-        memset(&fparams, 0, sizeof(struct test_case_params));
-        bparams.launch = 15;
-        fparams.launch = 15;
-        printf("\n Verifying Preview on back Camera and RDI on Front camera 12...\n");
-
-        LOGE("start back DUAL ");
-        rc = pthread_create(&back_thread_id, NULL, back_thread, &bparams);
-        LOGE("start front DUAL ");
-        rc = pthread_create(&front_thread_id, NULL, front_thread, &fparams);
-        sleep(1);
-        LOGE("stop back DUAL ");
-        rc = pthread_join(back_thread_id, NULL);
-        LOGE("stop front DUAL ");
-        rc = pthread_join(front_thread_id, NULL);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*  Test case 2413(ab)5768
- *  Test the dual camera usecase. We startPreview on front camera,
- *  but backend will allocate RDI buffers and start front camera in
- *  RDI streaming mode. It then diverts RDI frames, converts them into YUV 420
- *  through C2D and generate preview data in the buffers allocated here.
- *  Back camera will use the pixel interface as usual.
- */
-
-int mm_app_dtc_13(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j,k;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n 13. Verifying Preview + Recording on back Camera and Preview(through RDI) on Front camera\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for front \n");
-        if( MM_CAMERA_OK != (rc = startPreview(front_camera))) {
-               LOGE(" front camera startPreview() err=%d\n",  rc);
-               goto end;
-        }
-        mm_camera_app_wait();
-        usleep(20*1000);
-
-        for (k = 0; k < MM_QCAMERA_APP_INTERATION ; k++){
-          LOGE("DUAL open back camera %d \n",k);
-          if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                 LOGE("mm_app_open() back camera err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-
-          if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                 LOGE("system_dimension_set() err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-
-          LOGE("DUAL start camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" back camera startPreview() err=%d\n",  rc);
-                 goto end;
-          }
-          usleep(30*1000);
-
-          for (j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-             LOGE("DUAL start camera record for back Iteration %d \n", j);
-             if ( MM_CAMERA_OK != (rc = startRecording(back_camera))) {
-                 LOGE(" StartVideorecording() err=%d\n",  rc);
-                 break;
-             }
-
-             mm_camera_app_wait();
-             usleep(10*1000*1000);
-             LOGE("DUAL stop camera record for back Iteration %d\n", j);
-             if ( MM_CAMERA_OK != (rc = stopRecording(back_camera))) {
-                 LOGE(" Stopvideorecording() err=%d\n",  rc);
-                 break;
-             }
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL stop camera Preview for back \n");
-          if( MM_CAMERA_OK != (rc = stopPreview(back_camera))) {
-                 LOGE(" stopPreview() backcamera err=%d\n",  rc);
-                 goto end;
-          }
-          usleep(10*1000);
-
-          LOGE("DUAL close back camera\n");
-          if( mm_app_close(back_camera) != MM_CAMERA_OK) {
-                 LOGE("mm_app_close() err=%d\n", rc);
-                 rc = -1;
-                 goto end;
-          }
-          usleep(20*1000);
-        }
-        LOGE("DUAL stop camera Preview for Rdi \n");
-        if( MM_CAMERA_OK != (rc = stopPreview(front_camera))) {
-                LOGE(" stopPreview() frontcamera err=%d\n",  rc);
-                goto end;
-        }
-        usleep(10*1000);
-        LOGE("DUAL close front camera \n");
-        if( mm_app_close(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_close() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/*Below 6  are reference test cases just to test the open path for dual camera*/
-int mm_app_dtc_1243(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera Preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-int mm_app_dtc_2134(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera Preview for front \n");
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera Rdi for back \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-int mm_app_dtc_2143(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-int mm_app_dtc_2413(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera rdi for front \n");
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera preview for back \n");
-
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-int mm_app_dtc_1234(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL open back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL open front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-        LOGE("DUAL start camera preview for back \n");
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-               LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-
-        LOGE("DUAL start camera rdi for front \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-                printf("\nPassed\n");
-        }else{
-                printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-int mm_app_dtc_1324(mm_camera_app_t *cam_apps)
-{
-        int rc = MM_CAMERA_OK;
-        int i,j;
-        int result = 0;
-        int front_camera = 1;
-        int back_camera = 0;
-
-        printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-        LOGE("DUAL start back camera \n");
-        if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() back camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL start camera preview for back \n");
-        if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-                LOGE(" back camera startPreview() err=%d\n",  rc);
-                goto end;
-        }
-        //mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL start front camera \n");
-        if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-                LOGE("mm_app_open() front camera err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-
-       if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-                LOGE("system_dimension_set() err=%d\n", rc);
-                rc = -1;
-                goto end;
-        }
-        LOGE("DUAL start rdi preview \n");
-
-        if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-                LOGE(" startPreview() backcamera err=%d\n",  rc);
-                goto end;
-        }
-        mm_camera_app_wait();
-        sleep(1);
-        LOGE("DUAL end \n");
-
-end:
-        if(rc == 0) {
-          printf("\nPassed\n");
-        }else{
-          printf("\nFailed\n");
-        }
-        LOGD("END, rc = %d\n",  rc);
-        return rc;
-}
-
-/* single camera test cases*/
-int mm_app_dtc_s_0(mm_camera_app_t *cam_apps)
-{
-    int rc = MM_CAMERA_OK;
-    int i,j;
-    int result = 0;
-    int front_camera = 1;
-    int back_camera = 0;
-
-    printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-
-    if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-        LOGE("mm_app_open() back camera err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-    if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-    LOGE("system_dimension_set() err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-
-    if( MM_CAMERA_OK != (rc = startPreview(back_camera))) {
-        LOGE(" back camera startPreview() err=%d\n",  rc);
-        goto end;
-    }
-
-    mm_camera_app_wait();
-    if(mm_app_open(front_camera) != MM_CAMERA_OK) {
-        LOGE("mm_app_open() front camera err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-    if(system_dimension_set(front_camera) != MM_CAMERA_OK){
-        LOGE("system_dimension_set() err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-
-    if( MM_CAMERA_OK != (rc = startRdi(front_camera))) {
-        LOGE(" startPreview() backcamera err=%d\n",  rc);
-        goto end;
-    }
-    mm_camera_app_wait();
-
-    if( MM_CAMERA_OK != (rc = stopRdi(front_camera))) {
-        LOGE(" startPreview() backcamera err=%d\n",  rc);
-        goto end;
-    }
-
-    if( MM_CAMERA_OK != (rc = stopPreview(my_cam_app.cam_open))) {
-        LOGD(" startPreview() err=%d\n",  rc);
-        goto end;
-    }
-
-    if( mm_app_close(my_cam_app.cam_open) != MM_CAMERA_OK) {
-        LOGE("mm_app_close() err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-end:
-    if(rc == 0) {
-        printf("\nPassed\n");
-    }else{
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_dtc_s_1(mm_camera_app_t *cam_apps)
-{
-    int rc = MM_CAMERA_OK;
-    int i,j;
-    int result = 0;
-
-    printf("\n Verifying Snapshot on front and back camera...\n");
-    for(i = 0; i < cam_apps->num_cameras; i++) {
-        if( mm_app_open(i) != MM_CAMERA_OK) {
-            LOGE("mm_app_open() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(system_dimension_set(my_cam_app.cam_open) != MM_CAMERA_OK){
-            LOGE("system_dimension_set() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-
-        if( MM_CAMERA_OK != (rc = startPreview(my_cam_app.cam_open))) {
-                LOGE(" startPreview() err=%d\n",  rc);
-                break;
-        }
-        for(j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-            if( MM_CAMERA_OK != (rc = takePicture_yuv(my_cam_app.cam_open))) {
-                LOGE(" TakePicture() err=%d\n",  rc);
-                break;
-            }
-            /*if(mm_camera_app_timedwait() == ETIMEDOUT) {
-                LOGE(" Snapshot/Preview Callback not received in time or qbuf Faile\n");
-                break;
-            }*/
-            mm_camera_app_wait();
-            result++;
-        }
-        if( MM_CAMERA_OK != (rc = stopPreview(my_cam_app.cam_open))) {
-            LOGD(" startPreview() err=%d\n",  rc);
-            break;
-        }
-        if( mm_app_close(my_cam_app.cam_open) != MM_CAMERA_OK) {
-            LOGE("mm_app_close() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(result != MM_QCAMERA_APP_INTERATION) {
-            printf(" Snapshot Start/Stop Fails for Camera %d in %d iteration",  i,j);
-            rc = -1;
-            break;
-        }
-
-        result = 0;
-    }
-end:
-    if(rc == 0) {
-        printf("\t***Passed***\n");
-    }else{
-        printf("\t***Failed***\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_dtc_s_2(mm_camera_app_t *cam_apps)
-{
-    int rc = MM_CAMERA_OK;
-    int i,j;
-    int result = 0;
-
-    printf("\n Verifying Video on front and back camera...\n");
-    for(i = 0; i < cam_apps->num_cameras; i++) {
-        if( mm_app_open(i) != MM_CAMERA_OK) {
-            LOGE("mm_app_open() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(system_dimension_set(my_cam_app.cam_open) != MM_CAMERA_OK){
-            LOGE("system_dimension_set() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-
-        if( MM_CAMERA_OK != (rc = startPreview(my_cam_app.cam_open))) {
-            LOGE(" startPreview() err=%d\n",  rc);
-            break;
-        }
-        for(j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-            if( MM_CAMERA_OK != (rc = startRecording(my_cam_app.cam_open))) {
-                LOGE(" StartVideorecording() err=%d\n",  rc);
-                break;
-            }
-
-            /*if(mm_camera_app_timedwait() == ETIMEDOUT) {
-            LOGE(" Video Callback not received in time\n");
-            break;
-            }*/
-            mm_camera_app_wait();
-            if( MM_CAMERA_OK != (rc = stopRecording(my_cam_app.cam_open))) {
-                LOGE(" Stopvideorecording() err=%d\n",  rc);
-                break;
-            }
-            result++;
-        }
-        if( MM_CAMERA_OK != (rc = stopPreview(my_cam_app.cam_open))) {
-            LOGD(" startPreview() err=%d\n",  rc);
-            break;
-        }
-        if( mm_app_close(my_cam_app.cam_open) != MM_CAMERA_OK) {
-            LOGE("mm_app_close() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(result != MM_QCAMERA_APP_INTERATION) {
-            printf(" Video Start/Stop Fails for Camera %d in %d iteration",  i,j);
-            rc = -1;
-            break;
-        }
-
-        result = 0;
-    }
-end:
-    if(rc == 0) {
-        printf("\nPassed\n");
-    }else{
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_dtc_s_3(mm_camera_app_t *cam_apps)
-{
-    int rc = MM_CAMERA_OK;
-    int i,j;
-    int result = 0;
-
-    printf("\n Verifying RDI Stream on front and back camera...\n");
-    if(cam_apps->num_cameras == 0) {
-        LOGE("Query Failed: Num of cameras = %d\n", cam_apps->num_cameras);
-        rc = -1;
-        goto end;
-    }
-    for(i = 0; i < cam_apps->num_cameras; i++) {
-        if( mm_app_open(i) != MM_CAMERA_OK) {
-            LOGE("mm_app_open() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(system_dimension_set(my_cam_app.cam_open) != MM_CAMERA_OK){
-            LOGE("system_dimension_set() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        for(j = 0; j < MM_QCAMERA_APP_INTERATION; j++) {
-            if( MM_CAMERA_OK != (rc = startRdi(my_cam_app.cam_open))) {
-                LOGE(" StartVideorecording() err=%d\n",  rc);
-                break;
-            }
-
-            /*if(mm_camera_app_timedwait() == ETIMEDOUT) {
-            LOGE(" Video Callback not received in time\n");
-            break;
-            }*/
-            mm_camera_app_wait();
-            if( MM_CAMERA_OK != (rc = stopRdi(my_cam_app.cam_open))) {
-                LOGE(" Stopvideorecording() err=%d\n",  rc);
-                break;
-            }
-            result++;
-        }
-        if( mm_app_close(my_cam_app.cam_open) != MM_CAMERA_OK) {
-            LOGE("mm_app_close() err=%d\n", rc);
-            rc = -1;
-            goto end;
-        }
-        if(result != MM_QCAMERA_APP_INTERATION) {
-            printf(" Video Start/Stop Fails for Camera %d in %d iteration",  i,j);
-            rc = -1;
-            break;
-        }
-
-        result = 0;
-    }
-end:
-    if(rc == 0) {
-        printf("\nPassed\n");
-    }else{
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-/*Stats Test Case*/
-int mm_app_dtc_s_5(mm_camera_app_t *cam_apps)
-{
-    int rc = MM_CAMERA_OK;
-    int i,j;
-    int result = 0;
-    int front_camera = 1;
-    int back_camera = 0;
-
-    printf("\n Verifying Preview on back Camera and RDI on Front camera...\n");
-
-    if(mm_app_open(back_camera) != MM_CAMERA_OK) {
-        LOGE("mm_app_open() back camera err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-    if(system_dimension_set(back_camera) != MM_CAMERA_OK){
-    LOGE("system_dimension_set() err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-
-    if( MM_CAMERA_OK != (rc = startStats(back_camera))) {
-        LOGE(" back camera startPreview() err=%d\n",  rc);
-        goto end;
-    }
-
-    mm_camera_app_wait();
-
-    if( MM_CAMERA_OK != (rc = stopStats(my_cam_app.cam_open))) {
-        LOGD(" startPreview() err=%d\n",  rc);
-        goto end;
-    }
-
-    if( mm_app_close(my_cam_app.cam_open) != MM_CAMERA_OK) {
-        LOGE("mm_app_close() err=%d\n", rc);
-        rc = -1;
-        goto end;
-    }
-end:
-    if(rc == 0) {
-        printf("\nPassed\n");
-    }else{
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_gen_dual_test_cases()
-{
-    int tc = 0;
-    memset(mm_app_tc, 0, sizeof(mm_app_tc));
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_0;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_1;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_2;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_3;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_4;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_5;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_6;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_7;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_8;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_9;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_10;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_11;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_12;
-    if(tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_dtc_13;
-
-    return tc;
-}
-
-int mm_app_dual_test_entry(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, tc = 0;
-    int cam_id = 0;
-
-    tc = mm_app_gen_dual_test_cases();
-    LOGD("Running %d test cases\n",tc);
-    for(i = 0; i < tc; i++) {
-        mm_app_tc[i].r = mm_app_tc[i].f(cam_app);
-        if(mm_app_tc[i].r != MM_CAMERA_OK) {
-            printf(" test case %d error = %d, abort unit testing engine!!!!\n",
-                     i, mm_app_tc[i].r);
-            rc = mm_app_tc[i].r;
-            goto end;
-        }
-    }
-end:
-    printf("nTOTAL_TSET_CASE = %d, NUM_TEST_RAN = %d, rc=%d\n", tc, i, rc);
-    return rc;
-}
-
-
-
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
deleted file mode 100644
index 25e143f..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_main_menu.c
+++ /dev/null
@@ -1,2060 +0,0 @@
-/* Copyright (c) 2013-2014, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// System dependencies
-#include <ctype.h>
-#include <errno.h>
-
-// Camera dependencies
-#include "mm_qcamera_main_menu.h"
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-/*===========================================================================
- * Macro
- *===========================================================================*/
-#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
-#define VIDEO_BUFFER_SIZE       (PREVIEW_WIDTH * PREVIEW_HEIGHT * 3/2)
-#define THUMBNAIL_BUFFER_SIZE   (THUMBNAIL_WIDTH * THUMBNAIL_HEIGHT * 3/2)
-#define SNAPSHOT_BUFFER_SIZE    (PICTURE_WIDTH * PICTURE_HEIGHT * 3/2)
-//TODO:check this Macros with current app.
-
-/*===========================================================================
- * Defines
- *===========================================================================*/
-//#define VIDEO_FRAMES_NUM      4
-#define THUMBNAIL_FRAMES_NUM  1
-#define SNAPSHOT_FRAMES_NUM   1
-#define MAX_NUM_FORMAT        32
-#define ZOOM_STEP             2
-#define ZOOM_MIN_VALUE        0
-#define EXPOSURE_COMPENSATION_MAXIMUM_NUMERATOR 12
-#define EXPOSURE_COMPENSATION_MINIMUM_NUMERATOR -12
-#define EXPOSURE_COMPENSATION_DEFAULT_NUMERATOR 0
-#define EXPOSURE_COMPENSATION_DENOMINATOR 6
-
-//TODO: find correct values of Contrast defines.
-#define CAMERA_MIN_CONTRAST    0
-#define CAMERA_DEF_CONTRAST    5
-#define CAMERA_MAX_CONTRAST    10
-#define CAMERA_CONTRAST_STEP   1
-
-//TODO: find correct values of Brightness defines.
-#define CAMERA_MIN_BRIGHTNESS  0
-#define CAMERA_DEF_BRIGHTNESS  3
-#define CAMERA_MAX_BRIGHTNESS  6
-#define CAMERA_BRIGHTNESS_STEP 1
-
-//TODO: find correct values of Saturation defines.
-#define CAMERA_MIN_SATURATION  0
-#define CAMERA_DEF_SATURATION  5
-#define CAMERA_MAX_SATURATION  10
-#define CAMERA_SATURATION_STEP 1
-
-#define CAMERA_MIN_SHARPNESS 0
-#define CAMERA_MAX_SHARPNESS 10
-#define CAMERA_DEF_SHARPNESS 5
-#define CAMERA_SHARPNESS_STEP 1
-
-const CAMERA_MAIN_MENU_TBL_T camera_main_menu_tbl[] = {
-  {START_PREVIEW,              "Start preview"},
-  {STOP_PREVIEW,               "Stop preview/video"},
-  {SET_WHITE_BALANCE,          "Set white balance mode"},
-  {SET_TINTLESS_ENABLE,        "Set Tintless Enable"},
-  {SET_TINTLESS_DISABLE,       "Set Tintless Disable"},
-  {SET_EXP_METERING,           "Set exposure metering mode"},
-  {GET_CTRL_VALUE,             "Get control value menu"},
-  {TOGGLE_EZTUNE,              "Toggle EZtune. Default EZTune Off"},
-  {SET_ISO,                    "ISO changes."},
-  {BRIGHTNESS_GOTO_SUBMENU,    "Brightness changes."},
-  {CONTRAST_GOTO_SUBMENU,      "Contrast changes."},
-  {EV_GOTO_SUBMENU,            "EV changes."},
-  {SATURATION_GOTO_SUBMENU,    "Saturation changes."},
-  {SET_ZOOM,                   "Set Digital Zoom."},
-  {SET_SHARPNESS,              "Set Sharpness."},
-  {TAKE_JPEG_SNAPSHOT,         "Take a snapshot"},
-  {START_RECORDING,            "Start RECORDING"},
-  {STOP_RECORDING,             "Stop RECORDING"},
-  {BEST_SHOT,                  "Set best-shot mode"},
-  {LIVE_SHOT,                  "Take a live snapshot"},
-  {FLASH_MODES,                "Set Flash modes"},
-  {TOGGLE_ZSL,                 "Toggle ZSL On/Off"},
-  {TAKE_RAW_SNAPSHOT,          "Take RAW snapshot"},
-  {SWITCH_SNAP_RESOLUTION,     "Select Jpeg resolution"},
-  {TOGGLE_WNR,                 "Toggle Wavelet Denoise"},
-  {EXIT,                       "Exit"}
-};
-
-CAMERA_SENSOR_MENU_TLB_T sensor_tbl[] = {
-        {"Primary Camera",      0},
-        {"Secondary Camera",    0},
-        {"Camera Sensor 3",     0},
-        {"Camera Sensor 4",     0}
-};
-
-const CAMERA_BRIGHTNESS_TBL_T brightness_change_tbl[] = {
-  {INC_BRIGHTNESS, "Increase Brightness by one step."},
-  {DEC_BRIGHTNESS, "Decrease Brightness by one step."},
-};
-
-const CAMERA_CONTRST_TBL_T contrast_change_tbl[] = {
-  {INC_CONTRAST, "Increase Contrast by one step."},
-  {DEC_CONTRAST, "Decrease Contrast by one step."},
-};
-
-const CAMERA_EV_TBL_T camera_EV_tbl[] = {
-  {INCREASE_EV, "Increase EV by one step."},
-  {DECREASE_EV, "Decrease EV by one step."},
-};
-
-const CAMERA_SATURATION_TBL_T camera_saturation_tbl[] = {
-  {INC_SATURATION, "Increase Satuation by one step."},
-  {DEC_SATURATION, "Decrease Satuation by one step."},
-};
-
-const CAMERA_SHARPNESS_TBL_T camera_sharpness_tbl[] = {
-  {INC_SHARPNESS, "Increase Sharpness."},
-  {DEC_SHARPNESS, "Decrease Sharpness."},
-};
-
-const WHITE_BALANCE_TBL_T white_balance_tbl[] = {
-  {   WB_AUTO,               "White Balance - Auto"},
-  {   WB_INCANDESCENT,       "White Balance - Incandescent"},
-  {   WB_FLUORESCENT,        "White Balance - Fluorescent"},
-  {   WB_WARM_FLUORESCENT,   "White Balance - Warm Fluorescent"},
-  {   WB_DAYLIGHT,           "White Balance - Daylight"},
-  {   WB_CLOUDY_DAYLIGHT,    "White Balance - Cloudy Daylight"},
-  {   WB_TWILIGHT,           "White Balance - Twilight"},
-  {   WB_SHADE,              "White Balance - Shade"},
-};
-
-const GET_CTRL_TBL_T get_ctrl_tbl[] = {
-  {     WHITE_BALANCE_STATE,            "Get white balance state (auto/off)"},
-  {     WHITE_BALANCE_TEMPERATURE,      "Get white balance temperature"},
-  {     BRIGHTNESS_CTRL,                "Get brightness value"},
-  {     EV,                             "Get exposure value"},
-  {     CONTRAST_CTRL,                  "Get contrast value"},
-  {     SATURATION_CTRL,                "Get saturation value"},
-  {     SHARPNESS_CTRL,                 "Get sharpness value"},
-};
-
-const EXP_METERING_TBL_T exp_metering_tbl[] = {
-  {   AUTO_EXP_FRAME_AVG,          "Exposure Metering - Frame Average"},
-  {   AUTO_EXP_CENTER_WEIGHTED,    "Exposure Metering - Center Weighted"},
-  {   AUTO_EXP_SPOT_METERING,      "Exposure Metering - Spot Metering"},
-  {   AUTO_EXP_SMART_METERING,     "Exposure Metering - Smart Metering"},
-  {   AUTO_EXP_USER_METERING,      "Exposure Metering - User Metering"},
-  {   AUTO_EXP_SPOT_METERING_ADV,  "Exposure Metering - Spot Metering Adv"},
-  {   AUTO_EXP_CENTER_WEIGHTED_ADV,"Exposure Metering - Center Weighted Adv"},
-};
-
-const ISO_TBL_T iso_tbl[] = {
-  {   ISO_AUTO,   "ISO: Auto"},
-  {   ISO_DEBLUR, "ISO: Deblur"},
-  {   ISO_100,    "ISO: 100"},
-  {   ISO_200,    "ISO: 200"},
-  {   ISO_400,    "ISO: 400"},
-  {   ISO_800,    "ISO: 800"},
-  {   ISO_1600,   "ISO: 1600"},
-};
-
-const ZOOM_TBL_T zoom_tbl[] = {
-  {   ZOOM_IN,  "Zoom In one step"},
-  {   ZOOM_OUT, "Zoom Out one step"},
-};
-
-const BESTSHOT_MODE_TBT_T bestshot_mode_tbl[] = {
-  {BESTSHOT_AUTO,           "Bestshot Mode: Auto"},
-  {BESTSHOT_ACTION,         "Bestshot Mode: Action"},
-  {BESTSHOT_PORTRAIT,       "Bestshot Mode: Portrait"},
-  {BESTSHOT_LANDSCAPE,      "Bestshot Mode: Landscape"},
-  {BESTSHOT_NIGHT,          "Bestshot Mode: Night"},
-  {BESTSHOT_NIGHT_PORTRAIT, "Bestshot Mode: Night Portrait"},
-  {BESTSHOT_THEATRE,        "Bestshot Mode: Theatre"},
-  {BESTSHOT_BEACH,          "Bestshot Mode: Beach"},
-  {BESTSHOT_SNOW,           "Bestshot Mode: Snow"},
-  {BESTSHOT_SUNSET,         "Bestshot Mode: Sunset"},
-  {BESTSHOT_ANTISHAKE,      "Bestshot Mode: Antishake"},
-  {BESTSHOT_FIREWORKS,      "Bestshot Mode: Fireworks"},
-  {BESTSHOT_SPORTS,         "Bestshot Mode: Sports"},
-  {BESTSHOT_PARTY,          "Bestshot Mode: Party"},
-  {BESTSHOT_CANDLELIGHT,    "Bestshot Mode: Candlelight"},
-  {BESTSHOT_ASD,            "Bestshot Mode: ASD"},
-  {BESTSHOT_BACKLIGHT,      "Bestshot Mode: Backlight"},
-  {BESTSHOT_FLOWERS,        "Bestshot Mode: Flowers"},
-  {BESTSHOT_AR,             "Bestshot Mode: Augmented Reality"},
-  {BESTSHOT_HDR,            "Bestshot Mode: HDR"},
-};
-
-const FLASH_MODE_TBL_T flashmodes_tbl[] = {
-  {   FLASH_MODE_OFF,   "Flash Mode Off"},
-  {   FLASH_MODE_AUTO,  "Flash Mode Auto"},
-  {   FLASH_MODE_ON,    "Flash Mode On"},
-  {   FLASH_MODE_TORCH, "Flash Mode Torch"},
-};
-
-DIMENSION_TBL_T dimension_tbl[] = {
-{VGA_WIDTH,      VGA_HEIGHT,      "VGA",   "Size: VGA <640x480>"   , 0},
-{MP1_WIDTH,      MP1_HEIGHT,      "1MP",   "Size: 1MP <1280x960>"  , 0},
-{MP5_WIDTH,      MP5_HEIGHT,      "5MP",   "Size: 5MP <2592x1944>",  0},
-{MP8_WIDTH,      MP8_HEIGHT,      "8MP",   "Size: 8MP <3264x2448>",  0},
-{MP12_WIDTH,     MP12_HEIGHT,     "12MP",  "Size: 12MP <4000x3000>", 0},
-};
-
-/*===========================================================================
- * Forward declarations
- *===========================================================================*/
-//static void system_dimension_set(mm_camera_test_obj_t *test_obj);
-/*===========================================================================
- * Static global variables
- *===========================================================================*/
-USER_INPUT_DISPLAY_T input_display;
-int preview_video_resolution_flag = 0;
-
-//TODO: default values.
-#if 1
-int brightness = CAMERA_DEF_BRIGHTNESS;
-int contrast = CAMERA_DEF_CONTRAST;
-int saturation = CAMERA_DEF_SATURATION;
-int sharpness = CAMERA_DEF_SHARPNESS;
-#else
-int brightness = 0;
-int contrast = 0;
-int saturation = 0;
-int sharpness = 0;
-#endif
-//TODO: find new method to calculate ev.
-//int32_t ev_numerator = EXPOSURE_COMPENSATION_DEFAULT_NUMERATOR;
-
-//TODO:
-//fps_mode_t fps_mode = FPS_MODE_FIXED;
-int zoom_level;
-int zoom_max_value;
-int cam_id;
-int is_rec = 0;
-
-
-static int submain();
-
-/*===========================================================================
- * FUNCTION    - keypress_to_event -
- *
- * DESCRIPTION:
- *==========================================================================*/
-int keypress_to_event(char keypress)
-{
-  int out_buf = INVALID_KEY_PRESS;
-  if ((keypress >= 'A' && keypress <= 'Z') ||
-    (keypress >= 'a' && keypress <= 'z')) {
-    out_buf = tolower(keypress);
-    out_buf = out_buf - 'a';
-  } else if (keypress >= '0' && keypress <= '9') {
-    out_buf = keypress - '0';
-  }
-  return out_buf;
-}
-
-int next_menu(menu_id_change_t current_menu_id, char keypress, camera_action_t * action_id_ptr, int * action_param)
-{
-  int output_to_event;
-  menu_id_change_t next_menu_id = MENU_ID_INVALID;
-  * action_id_ptr = ACTION_NO_ACTION;
-
-  output_to_event = keypress_to_event(keypress);
-  LOGD("current_menu_id=%d\n",current_menu_id);
-  printf("output_to_event=%d\n",output_to_event);
-  switch(current_menu_id) {
-    case MENU_ID_MAIN:
-      switch(output_to_event) {
-        case START_PREVIEW:
-          * action_id_ptr = ACTION_START_PREVIEW;
-          LOGD("START_PREVIEW\n");
-          break;
-        case STOP_PREVIEW:
-          * action_id_ptr = ACTION_STOP_PREVIEW;
-          LOGD("STOP_PREVIEW\n");
-          break;
-
-        case SET_WHITE_BALANCE:
-          next_menu_id = MENU_ID_WHITEBALANCECHANGE;
-          LOGD("next_menu_id = MENU_ID_WHITEBALANCECHANGE = %d\n", next_menu_id);
-          break;
-
-        case SET_TINTLESS_ENABLE:
-          * action_id_ptr = ACTION_SET_TINTLESS_ENABLE;
-          next_menu_id = MENU_ID_MAIN;
-          LOGD("next_menu_id = MENU_ID_TINTLESSENABLE = %d\n", next_menu_id);
-          break;
-
-        case SET_TINTLESS_DISABLE:
-          * action_id_ptr = ACTION_SET_TINTLESS_DISABLE;
-          next_menu_id = MENU_ID_MAIN;
-          LOGD("next_menu_id = MENU_ID_TINTLESSDISABLE = %d\n", next_menu_id);
-          break;
-
-        case SET_EXP_METERING:
-          next_menu_id = MENU_ID_EXPMETERINGCHANGE;
-          LOGD("next_menu_id = MENU_ID_EXPMETERINGCHANGE = %d\n", next_menu_id);
-          break;
-
-        case GET_CTRL_VALUE:
-          next_menu_id = MENU_ID_GET_CTRL_VALUE;
-          LOGD("next_menu_id = MENU_ID_GET_CTRL_VALUE = %d\n", next_menu_id);
-          break;
-
-        case BRIGHTNESS_GOTO_SUBMENU:
-          next_menu_id = MENU_ID_BRIGHTNESSCHANGE;
-          LOGD("next_menu_id = MENU_ID_BRIGHTNESSCHANGE = %d\n", next_menu_id);
-          break;
-
-        case CONTRAST_GOTO_SUBMENU:
-          next_menu_id = MENU_ID_CONTRASTCHANGE;
-          break;
-
-        case EV_GOTO_SUBMENU:
-          next_menu_id = MENU_ID_EVCHANGE;
-          break;
-
-        case SATURATION_GOTO_SUBMENU:
-          next_menu_id = MENU_ID_SATURATIONCHANGE;
-          break;
-
-        case TOGGLE_EZTUNE:
-          * action_id_ptr = ACTION_TOGGLE_EZTUNE;
-          LOGD("next_menu_id = MENU_ID_TOGGLE EZTUNE = %d\n", next_menu_id);
-          break;
-
-        case SET_ISO:
-          next_menu_id = MENU_ID_ISOCHANGE;
-          LOGD("next_menu_id = MENU_ID_ISOCHANGE = %d\n", next_menu_id);
-          break;
-
-        case SET_ZOOM:
-          next_menu_id = MENU_ID_ZOOMCHANGE;
-          LOGD("next_menu_id = MENU_ID_ZOOMCHANGE = %d\n", next_menu_id);
-          break;
-
-        case BEST_SHOT:
-          next_menu_id = MENU_ID_BESTSHOT;
-          LOGD("next_menu_id = MENU_ID_BESTSHOT = %d\n", next_menu_id);
-          break;
-
-        case LIVE_SHOT:
-          * action_id_ptr = ACTION_TAKE_LIVE_SNAPSHOT;
-          LOGD("\nTaking Live snapshot\n");
-          break;
-
-        case FLASH_MODES:
-          next_menu_id = MENU_ID_FLASHMODE;
-          LOGD("next_menu_id = MENU_ID_FLASHMODE = %d\n", next_menu_id);
-          break;
-
-        case SET_SHARPNESS:
-          next_menu_id = MENU_ID_SHARPNESSCHANGE;
-          LOGD("next_menu_id = MENU_ID_SHARPNESSCHANGE = %d\n", next_menu_id);
-          break;
-
-        case SWITCH_SNAP_RESOLUTION:
-          next_menu_id = MENU_ID_SWITCH_RES;
-          LOGD("next_menu_id = MENU_ID_SWITCH_RES = %d\n", next_menu_id);
-          break;
-
-        case TAKE_JPEG_SNAPSHOT:
-          * action_id_ptr = ACTION_TAKE_JPEG_SNAPSHOT;
-          printf("\n Taking JPEG snapshot\n");
-          break;
-
-        case START_RECORDING:
-          * action_id_ptr = ACTION_START_RECORDING;
-          LOGD("Start recording\n");
-          break;
-        case STOP_RECORDING:
-          * action_id_ptr = ACTION_STOP_RECORDING;
-          LOGD("Stop recording\n");
-          break;
-        case TOGGLE_ZSL:
-          * action_id_ptr = ACTION_TOGGLE_ZSL;
-          LOGD("Toggle ZSL\n");
-          break;
-        case TAKE_RAW_SNAPSHOT:
-            * action_id_ptr = ACTION_TAKE_RAW_SNAPSHOT;
-            next_menu_id = MENU_ID_MAIN;
-            LOGD("Capture RAW\n");
-            break;
-        case TOGGLE_WNR:
-            * action_id_ptr = ACTION_TOGGLE_WNR;
-            next_menu_id = MENU_ID_MAIN;
-            LOGD("Toggle WNR");
-            break;
-        case EXIT:
-          * action_id_ptr = ACTION_EXIT;
-          LOGD("Exit \n");
-          break;
-        default:
-          next_menu_id = MENU_ID_MAIN;
-          LOGD("next_menu_id = MENU_ID_MAIN = %d\n", next_menu_id);
-          break;
-      }
-      break;
-
-    case MENU_ID_SWITCH_RES:
-        printf("MENU_ID_SWITCH_RES\n");
-        *action_id_ptr = ACTION_SWITCH_RESOLUTION;
-        *action_param = output_to_event;
-        int available_sizes = sizeof(dimension_tbl)/sizeof(dimension_tbl[0]);
-        if ( ( *action_param >= 0 ) &&
-             ( *action_param < available_sizes ) &&
-             ( dimension_tbl[*action_param].supported )) {
-            next_menu_id = MENU_ID_MAIN;
-        }
-        else {
-          next_menu_id = current_menu_id;
-        }
-        break;
-
-    case MENU_ID_SENSORS:
-        next_menu_id = MENU_ID_MAIN;
-        *action_id_ptr = ACTION_SWITCH_CAMERA;
-        *action_param = output_to_event;
-        break;
-
-    case MENU_ID_WHITEBALANCECHANGE:
-      printf("MENU_ID_WHITEBALANCECHANGE\n");
-      if (output_to_event >= WB_MAX) {
-        next_menu_id = current_menu_id;
-        * action_id_ptr = ACTION_NO_ACTION;
-      } else {
-        next_menu_id = MENU_ID_MAIN;
-        * action_id_ptr = ACTION_SET_WHITE_BALANCE;
-        * action_param = output_to_event;
-      }
-      break;
-
-    case MENU_ID_EXPMETERINGCHANGE:
-      printf("MENU_ID_EXPMETERINGCHANGE\n");
-      if (output_to_event >= AUTO_EXP_MAX) {
-        next_menu_id = current_menu_id;
-        * action_id_ptr = ACTION_NO_ACTION;
-      } else {
-        next_menu_id = MENU_ID_MAIN;
-        * action_id_ptr = ACTION_SET_EXP_METERING;
-        * action_param = output_to_event;
-      }
-      break;
-
-    case MENU_ID_GET_CTRL_VALUE:
-      printf("MENU_ID_GET_CTRL_VALUE\n");
-      * action_id_ptr = ACTION_GET_CTRL_VALUE;
-      if (output_to_event > 0 &&
-        output_to_event <= (int)(sizeof(get_ctrl_tbl)/sizeof(get_ctrl_tbl[0]))) {
-          next_menu_id = MENU_ID_MAIN;
-          * action_param = output_to_event;
-      }
-      else {
-        next_menu_id = current_menu_id;
-      }
-      break;
-
-    case MENU_ID_BRIGHTNESSCHANGE:
-      switch (output_to_event) {
-        case INC_BRIGHTNESS:
-          * action_id_ptr = ACTION_BRIGHTNESS_INCREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        case DEC_BRIGHTNESS:
-          * action_id_ptr = ACTION_BRIGHTNESS_DECREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        default:
-          next_menu_id = MENU_ID_BRIGHTNESSCHANGE;
-          break;
-      }
-      break;
-
-    case MENU_ID_CONTRASTCHANGE:
-      switch (output_to_event) {
-        case INC_CONTRAST:
-          * action_id_ptr = ACTION_CONTRAST_INCREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        case DEC_CONTRAST:
-          * action_id_ptr = ACTION_CONTRAST_DECREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        default:
-          next_menu_id = MENU_ID_CONTRASTCHANGE;
-          break;
-      }
-      break;
-
-    case MENU_ID_EVCHANGE:
-      switch (output_to_event) {
-        case INCREASE_EV:
-          * action_id_ptr = ACTION_EV_INCREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        case DECREASE_EV:
-          * action_id_ptr = ACTION_EV_DECREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        default:
-          next_menu_id = MENU_ID_EVCHANGE;
-          break;
-      }
-      break;
-
-    case MENU_ID_SATURATIONCHANGE:
-      switch (output_to_event) {
-        case INC_SATURATION:
-          * action_id_ptr = ACTION_SATURATION_INCREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        case DEC_SATURATION:
-          * action_id_ptr = ACTION_SATURATION_DECREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-
-        default:
-          next_menu_id = MENU_ID_EVCHANGE;
-          break;
-      }
-      break;
-
-    case MENU_ID_ISOCHANGE:
-      printf("MENU_ID_ISOCHANGE\n");
-      if (output_to_event >= ISO_MAX) {
-        next_menu_id = current_menu_id;
-        * action_id_ptr = ACTION_NO_ACTION;
-      } else {
-        next_menu_id = MENU_ID_MAIN;
-        * action_id_ptr = ACTION_SET_ISO;
-        * action_param = output_to_event;
-      }
-      break;
-
-    case MENU_ID_ZOOMCHANGE:
-      * action_id_ptr = ACTION_SET_ZOOM;
-      if (output_to_event > 0 &&
-        output_to_event <= (int)(sizeof(zoom_tbl)/sizeof(zoom_tbl[0]))) {
-          next_menu_id = MENU_ID_MAIN;
-          * action_param = output_to_event;
-      } else {
-        next_menu_id = current_menu_id;
-      }
-      break;
-
-    case MENU_ID_SHARPNESSCHANGE:
-      switch (output_to_event) {
-        case INC_SHARPNESS:
-          * action_id_ptr = ACTION_SHARPNESS_INCREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-        case DEC_SHARPNESS:
-          * action_id_ptr = ACTION_SHARPNESS_DECREASE;
-          next_menu_id = MENU_ID_MAIN;
-          break;
-        default:
-          next_menu_id = MENU_ID_SHARPNESSCHANGE;
-          break;
-      }
-      break;
-
-    case MENU_ID_BESTSHOT:
-      if (output_to_event >= BESTSHOT_MAX) {
-        next_menu_id = current_menu_id;
-        * action_id_ptr = ACTION_NO_ACTION;
-      } else {
-        next_menu_id = MENU_ID_MAIN;
-        * action_id_ptr = ACTION_SET_BESTSHOT_MODE;
-        * action_param = output_to_event;
-      }
-      break;
-
-    case MENU_ID_FLASHMODE:
-      if (output_to_event >= FLASH_MODE_MAX) {
-        next_menu_id = current_menu_id;
-        * action_id_ptr = ACTION_NO_ACTION;
-      } else {
-        next_menu_id = MENU_ID_MAIN;
-        * action_id_ptr = ACTION_SET_FLASH_MODE;
-        * action_param = output_to_event;
-      }
-      break;
-
-    default:
-      LOGD("menu id is wrong: %d\n", current_menu_id);
-      break;
-  }
-
-  return next_menu_id;
-}
-
-/*===========================================================================
- * FUNCTION    - print_menu_preview_video -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-static void print_menu_preview_video(void) {
-  unsigned int i;
-  if (!is_rec) {
-    printf("\n");
-    printf("===========================================\n");
-    printf("      Camera is in preview/video mode now        \n");
-    printf("===========================================\n\n");
-  } else {
-    printf("\n");
-    printf("===========================================\n");
-    printf("      Camera is in RECORDING mode now       \n");
-    printf("        Press 'Q' To Stop Recording          \n");
-    printf("        Press 'S' To Take Live Snapshot       \n");
-    printf("===========================================\n\n");
-  }
-  char menuNum = 'A';
-  for (i = 0; i < sizeof(camera_main_menu_tbl)/sizeof(camera_main_menu_tbl[0]); i++) {
-    if (i == BASE_OFFSET) {
-      menuNum = '1';
-    }
-
-    printf("%c.  %s\n", menuNum, camera_main_menu_tbl[i].menu_name);
-    menuNum++;
-  }
-
-  printf("\nPlease enter your choice: ");
-
-  return;
-}
-
-static void camera_preview_video_wb_change_tbl(void) {
-  unsigned int i;
-  printf("\n");
-  printf("==========================================================\n");
-  printf("      Camera is in white balance change mode       \n");
-  printf("==========================================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0 ; i < sizeof(white_balance_tbl) /
-                   sizeof(white_balance_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, white_balance_tbl[i].wb_name);
-        submenuNum++;
-  }
-  printf("\nPlease enter your choice for White Balance modes: ");
-  return;
-}
-
-static void camera_preview_video_get_ctrl_value_tbl(void) {
-  unsigned int i;
-  printf("\n");
-  printf("==========================================================\n");
-  printf("      Camera is in get control value mode       \n");
-  printf("==========================================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0 ; i < sizeof(get_ctrl_tbl) /
-                   sizeof(get_ctrl_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, get_ctrl_tbl[i].get_ctrl_name);
-        submenuNum++;
-  }
-  printf("\nPlease enter your choice for control value you want to get: ");
-  return;
-}
-
-static void camera_preview_video_exp_metering_change_tbl(void) {
-  unsigned int i;
-  printf("\n");
-  printf("==========================================================\n");
-  printf("      Camera is in exposure metering change mode       \n");
-  printf("==========================================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0 ; i < sizeof(exp_metering_tbl) /
-                   sizeof(exp_metering_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, exp_metering_tbl[i].exp_metering_name);
-        submenuNum++;
-  }
-  printf("\nPlease enter your choice for exposure metering modes: ");
-  return;
-}
-
-static void camera_contrast_change_tbl(void) {
-    unsigned int i;
-
-    printf("\n");
-    printf("==========================================================\n");
-    printf("      Camera is in change contrast resolution mode       \n");
-    printf("==========================================================\n\n");
-
-    char contrastmenuNum = 'A';
-    for (i = 0; i < sizeof(contrast_change_tbl) /
-                    sizeof(contrast_change_tbl[0]); i++) {
-        printf("%c.  %s\n", contrastmenuNum,
-                            contrast_change_tbl[i].contrast_name);
-        contrastmenuNum++;
-    }
-
-    printf("\nPlease enter your choice for contrast Change: ");
-    return;
-}
-
-static void camera_EV_change_tbl(void) {
-  unsigned int i;
-
-  printf("\n");
-  printf("===========================================\n");
-  printf("      Camera is in EV change mode now       \n");
-  printf("===========================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0; i < sizeof(camera_EV_tbl)/sizeof(camera_EV_tbl[0]); i++) {
-    printf("%c.  %s\n", submenuNum, camera_EV_tbl[i].EV_name);
-    submenuNum++;
-  }
-
-  printf("\nPlease enter your choice for EV changes: ");
-  return;
-}
-
-static void camera_resolution_change_tbl(void) {
-    unsigned int i;
-
-    printf("\n");
-    printf("==========================================================\n");
-    printf("      Camera is in snapshot resolution mode               \n");
-    printf("==========================================================\n\n");
-
-    for (i = 0; i < sizeof(dimension_tbl) /
-      sizeof(dimension_tbl[0]); i++) {
-        if ( dimension_tbl[i].supported ) {
-            printf("%d.  %s\n", i,
-                    dimension_tbl[i].str_name);
-        }
-    }
-
-    printf("\nPlease enter your choice for Resolution: ");
-    return;
-}
-
-static void camera_preview_video_zoom_change_tbl(void) {
-    unsigned int i;
-    zoom_max_value = MAX_ZOOMS_CNT;
-    printf("\nCurrent Zoom Value = %d ,Max Zoom Value = %d\n",zoom_level,zoom_max_value);
-    char submenuNum = 'A';
-    for (i = 0 ; i < sizeof(zoom_tbl) /
-                   sizeof(zoom_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, zoom_tbl[i].zoom_direction_name);
-        submenuNum++;
-    }
-    printf("\nPlease enter your choice for zoom change direction: ");
-    return;
-}
-
-static void camera_brightness_change_tbl(void) {
-    unsigned int i;
-
-    printf("\n");
-    printf("==========================================================\n");
-    printf("      Camera is in change brightness mode       \n");
-    printf("==========================================================\n\n");
-
-    char brightnessmenuNum = 'A';
-    for (i = 0; i < sizeof(brightness_change_tbl) /
-                    sizeof(brightness_change_tbl[0]); i++) {
-        printf("%c.  %s\n", brightnessmenuNum,
-                            brightness_change_tbl[i].brightness_name);
-        brightnessmenuNum++;
-    }
-
-    printf("\nPlease enter your choice for Brightness Change: ");
-    return;
-}
-
-static void camera_saturation_change_tbl(void) {
-    unsigned int i;
-
-    printf("\n");
-    printf("==========================================================\n");
-    printf("      Camera is in change saturation mode       \n");
-    printf("==========================================================\n\n");
-
-    char saturationmenuNum = 'A';
-    for (i = 0; i < sizeof(camera_saturation_tbl) /
-                    sizeof(camera_saturation_tbl[0]); i++) {
-        printf("%c.  %s\n", saturationmenuNum,
-                            camera_saturation_tbl[i].saturation_name);
-        saturationmenuNum++;
-    }
-
-    printf("\nPlease enter your choice for Saturation Change: ");
-    return;
-}
-
-static void camera_preview_video_iso_change_tbl(void) {
-  unsigned int i;
-  printf("\n");
-  printf("==========================================================\n");
-  printf("      Camera is in ISO change mode       \n");
-  printf("==========================================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0 ; i < sizeof(iso_tbl) /
-                   sizeof(iso_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, iso_tbl[i].iso_modes_name);
-        submenuNum++;
-  }
-  printf("\nPlease enter your choice for iso modes: ");
-  return;
-}
-
-static void camera_preview_video_sharpness_change_tbl(void) {
-  unsigned int i;
-  printf("\n");
-  printf("==========================================================\n");
-  printf("      Camera is in sharpness change mode       \n");
-  printf("==========================================================\n\n");
-
-  char submenuNum = 'A';
-  for (i = 0 ; i < sizeof(camera_sharpness_tbl) /
-                   sizeof(camera_sharpness_tbl[0]); i++) {
-        printf("%c.  %s\n", submenuNum, camera_sharpness_tbl[i].sharpness_name);
-        submenuNum++;
-  }
-  printf("\nPlease enter your choice for sharpness modes: ");
-  return;
-}
-
-static void camera_set_bestshot_tbl(void)
-{
-  unsigned int i;
-
-  printf("\n");
-  printf("===========================================\n");
-  printf("      Camera is in set besthot mode now       \n");
-  printf("===========================================\n\n");
-
-
-  char bsmenuNum = 'A';
-  for (i = 0; i < sizeof(bestshot_mode_tbl)/sizeof(bestshot_mode_tbl[0]); i++) {
-    printf("%c.  %s\n", bsmenuNum,
-      bestshot_mode_tbl[i].name);
-    bsmenuNum++;
-  }
-
-  printf("\nPlease enter your choice of Bestshot Mode: ");
-  return;
-}
-
-static void camera_set_flashmode_tbl(void)
-{
-  unsigned int i;
-
-  printf("\n");
-  printf("===========================================\n");
-  printf("      Camera is in set flash mode now       \n");
-  printf("===========================================\n\n");
-
-
-  char bsmenuNum = 'A';
-  for (i = 0; i < sizeof(flashmodes_tbl)/sizeof(flashmodes_tbl[0]); i++) {
-    printf("%c.  %s\n", bsmenuNum,
-      flashmodes_tbl[i].name);
-    bsmenuNum++;
-  }
-
-  printf("\nPlease enter your choice of Bestshot Mode: ");
-  return;
-}
-
-static void camera_sensors_tbl(void)
-{
-  unsigned int i;
-  size_t available_sensors = sizeof(sensor_tbl)/sizeof(sensor_tbl[0]);
-
-  printf("\n");
-  printf("===========================================\n");
-  printf("      Camera Sensor to be used:            \n");
-  printf("===========================================\n\n");
-
-
-  char bsmenuNum = 'A';
-  for (i = 0; ( i < available_sensors ) && ( sensor_tbl[i].present ) ; i++) {
-    printf("%c.  %s\n", bsmenuNum,
-            sensor_tbl[i].menu_name);
-    bsmenuNum++;
-  }
-
-  printf("\nPlease enter your choice for sensor: ");
-  return;
-}
-
-/*===========================================================================
- * FUNCTION     - increase_contrast -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int increase_contrast (mm_camera_lib_handle *lib_handle) {
-        contrast += CAMERA_CONTRAST_STEP;
-        if (contrast > CAMERA_MAX_CONTRAST) {
-                contrast = CAMERA_MAX_CONTRAST;
-                printf("Reached max CONTRAST. \n");
-        }
-        printf("Increase Contrast to %d\n", contrast);
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_CONTRAST,
-                                          &contrast,
-                                          NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - decrease_contrast -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int decrease_contrast (mm_camera_lib_handle *lib_handle) {
-        contrast -= CAMERA_CONTRAST_STEP;
-        if (contrast < CAMERA_MIN_CONTRAST) {
-                contrast = CAMERA_MIN_CONTRAST;
-                printf("Reached min CONTRAST. \n");
-        }
-        printf("Decrease Contrast to %d\n", contrast);
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_CONTRAST,
-                                          &contrast,
-                                          NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - decrease_brightness -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int decrease_brightness (mm_camera_lib_handle *lib_handle) {
-        brightness -= CAMERA_BRIGHTNESS_STEP;
-        if (brightness < CAMERA_MIN_BRIGHTNESS) {
-                brightness = CAMERA_MIN_BRIGHTNESS;
-                printf("Reached min BRIGHTNESS. \n");
-        }
-        printf("Decrease Brightness to %d\n", brightness);
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_BRIGHTNESS,
-                                          &brightness,
-                                          NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - increase_brightness -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int increase_brightness (mm_camera_lib_handle *lib_handle) {
-        brightness += CAMERA_BRIGHTNESS_STEP;
-        if (brightness > CAMERA_MAX_BRIGHTNESS) {
-                brightness = CAMERA_MAX_BRIGHTNESS;
-                printf("Reached max BRIGHTNESS. \n");
-        }
-        printf("Increase Brightness to %d\n", brightness);
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_BRIGHTNESS,
-                                          &brightness,
-                                          NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - increase_EV -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-
-int increase_EV (void) {
-#if 0
-   int rc = 0;
-   int32_t value = 0;
-   rc = cam_config_is_parm_supported(cam_id, MM_CAMERA_PARM_EXPOSURE_COMPENSATION);
-    if(!rc) {
-       printf("MM_CAMERA_PARM_EXPOSURE_COMPENSATION mode is not supported for this sensor");
-       return -1;
-    }
-    ev_numerator += 1;
-    if(ev_numerator >= EXPOSURE_COMPENSATION_MINIMUM_NUMERATOR &&
-            ev_numerator <= EXPOSURE_COMPENSATION_MAXIMUM_NUMERATOR){
-        int16_t  numerator16 = (int16_t)(ev_numerator & 0x0000ffff);
-        uint16_t denominator16 = EXPOSURE_COMPENSATION_DENOMINATOR;
-        value = numerator16 << 16 | denominator16;
-    } else {
-       printf("Reached max EV.\n");
-    }
-    return mm_app_set_config_parm(cam_id, MM_CAMERA_PARM_EXPOSURE_COMPENSATION, value);
-#endif
-  return 0;
-}
-
-/*===========================================================================
- * FUNCTION     - decrease_EV -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int decrease_EV (void) {
-#if 0
-   int rc = 0;
-   int32_t  value = 0;
-   rc = cam_config_is_parm_supported(cam_id, MM_CAMERA_PARM_EXPOSURE_COMPENSATION);
-    if(!rc) {
-       printf("MM_CAMERA_PARM_EXPOSURE_COMPENSATION mode is not supported for this sensor");
-       return -1;
-    }
-    ev_numerator -= 1;
-    if(ev_numerator >= EXPOSURE_COMPENSATION_MINIMUM_NUMERATOR &&
-            ev_numerator <= EXPOSURE_COMPENSATION_MAXIMUM_NUMERATOR){
-        int16_t  numerator16 = (int16_t)(ev_numerator & 0x0000ffff);
-        uint16_t denominator16 = EXPOSURE_COMPENSATION_DENOMINATOR;
-        value = numerator16 << 16 | denominator16;
-    } else {
-       printf("Reached min EV.\n");
-    }
-    return mm_app_set_config_parm(cam_id, MM_CAMERA_PARM_EXPOSURE_COMPENSATION, value);
-#endif
-  return 0;
-}
-
-/*===========================================================================
- * FUNCTION     - increase_saturation -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int increase_saturation (mm_camera_lib_handle *lib_handle) {
-#if 0
-  saturation += CAMERA_SATURATION_STEP;
-  if (saturation > CAMERA_MAX_SATURATION) {
-    saturation = CAMERA_MAX_SATURATION;
-    printf("Reached max saturation. \n");
-  }
-  printf("Increase Saturation to %d\n", saturation);
-  return mm_app_set_config_parm(cam_id, MM_CAMERA_PARM_SATURATION, saturation);
-#endif
-  saturation += CAMERA_SATURATION_STEP;
-  if (saturation > CAMERA_MAX_SATURATION) {
-    saturation = CAMERA_MAX_SATURATION;
-    printf("Reached max saturation. \n");
-  }
-  printf("Increase saturation to %d\n", contrast);
-  return mm_camera_lib_send_command(lib_handle,
-                                       MM_CAMERA_LIB_SATURATION,
-                                       &saturation,
-                                       NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - decrease_saturation -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int decrease_saturation (mm_camera_lib_handle *lib_handle) {
-#if 0
-  saturation -= CAMERA_SATURATION_STEP;
-  if (saturation < CAMERA_MIN_SATURATION) {
-    saturation = CAMERA_MIN_SATURATION;
-    printf("Reached min saturation. \n");
-  }
-  printf("Dcrease Saturation to %d\n", saturation);
-  return mm_app_set_config_parm(cam_id, MM_CAMERA_PARM_SATURATION, saturation);
-#endif
-  saturation -= CAMERA_SATURATION_STEP;
-  if (saturation < CAMERA_MIN_SATURATION) {
-    saturation = CAMERA_MIN_SATURATION;
-    printf("Reached min saturation. \n");
-  }
-  printf("decrease saturation to %d\n", contrast);
-  return mm_camera_lib_send_command(lib_handle,
-                                       MM_CAMERA_LIB_SATURATION,
-                                       &saturation,
-                                       NULL);
-}
-
-
-int take_jpeg_snapshot(mm_camera_test_obj_t *test_obj, int is_burst_mode)
-{
-  LOGH("\nEnter take_jpeg_snapshot!!\n");
-  int rc = mm_app_take_picture (test_obj, (uint8_t)is_burst_mode);
-  if (MM_CAMERA_OK != rc) {
-    LOGE(" mm_app_take_picture() err=%d\n",  rc);
-  }
-  return rc;
-}
-
-/*===========================================================================
- * FUNCTION    - main -
- *
- * DESCRIPTION:
- *==========================================================================*/
-int main()
-{
-    char tc_buf[3];
-    int mode = 0;
-    int rc = 0;
-
-    printf("Please Select Execution Mode:\n");
-    printf("0: Menu Based 1: Regression\n");
-    fgets(tc_buf, 3, stdin);
-    mode = tc_buf[0] - '0';
-    if(mode == 0) {
-      printf("\nStarting Menu based!!\n");
-    } else if(mode == 1) {
-      printf("Starting Regression testing!!\n");
-      if(!mm_app_start_regression_test(1)) {
-         printf("\nRegressiion test passed!!\n");
-         return 0;
-      } else {
-        printf("\nRegression test failed!!\n");
-        exit(-1);
-      }
-    } else {
-       printf("\nPlease Enter 0 or 1\n");
-       printf("\nExisting the App!!\n");
-       exit(-1);
-    }
-
-
-    rc = submain();
-
-    printf("Exiting application\n");
-
-    return rc;
-}
-
-/*===========================================================================
- * FUNCTION     - set_whitebalance -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int set_whitebalance (mm_camera_lib_handle *lib_handle, int wb_action_param) {
-        cam_wb_mode_type type = 0;
-        switch (wb_action_param) {
-                case WB_AUTO:
-                        printf("\n WB_AUTO\n");
-                        type = CAM_WB_MODE_AUTO;
-                        break;
-                case WB_INCANDESCENT:
-                        printf("\n WB_INCANDESCENT\n");
-                        type = CAM_WB_MODE_INCANDESCENT;
-                        break;
-                case WB_FLUORESCENT:
-                        printf("\n WB_FLUORESCENT\n");
-                        type = CAM_WB_MODE_FLUORESCENT;
-                        break;
-                case WB_WARM_FLUORESCENT:
-                        printf("\n WB_WARM_FLUORESCENT\n");
-                        type = CAM_WB_MODE_WARM_FLUORESCENT;
-                        break;
-                case WB_DAYLIGHT:
-                        printf("\n WB_DAYLIGHT\n");
-                        type = CAM_WB_MODE_DAYLIGHT;
-                        break;
-                case WB_CLOUDY_DAYLIGHT:
-                        printf("\n WB_CLOUDY_DAYLIGHT\n");
-                        type = CAM_WB_MODE_CLOUDY_DAYLIGHT;
-                        break;
-               case WB_TWILIGHT:
-                        printf("\n WB_TWILIGHT\n");
-                        type = CAM_WB_MODE_TWILIGHT;
-                        break;
-               case WB_SHADE:
-                        printf("\n WB_SHADE\n");
-                        type = CAM_WB_MODE_SHADE;
-                        break;
-                default:
-                        break;
-        }
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_WB,
-                                          &type,
-                                          NULL);
-}
-
-
-/*===========================================================================
- * FUNCTION     - set_exp_metering -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int set_exp_metering (mm_camera_lib_handle *lib_handle, int exp_metering_action_param) {
-        cam_auto_exposure_mode_type type = 0;
-        switch (exp_metering_action_param) {
-		case AUTO_EXP_FRAME_AVG:
-                        printf("\nAUTO_EXP_FRAME_AVG\n");
-                        type = CAM_AEC_MODE_FRAME_AVERAGE;
-                        break;
-                case AUTO_EXP_CENTER_WEIGHTED:
-                        printf("\n AUTO_EXP_CENTER_WEIGHTED\n");
-                        type = CAM_AEC_MODE_CENTER_WEIGHTED;
-                        break;
-                case AUTO_EXP_SPOT_METERING:
-                        printf("\n AUTO_EXP_SPOT_METERING\n");
-                        type = CAM_AEC_MODE_SPOT_METERING;
-                        break;
-                case AUTO_EXP_SMART_METERING:
-                        printf("\n AUTO_EXP_SMART_METERING\n");
-                        type = CAM_AEC_MODE_SMART_METERING;
-                        break;
-                case AUTO_EXP_USER_METERING:
-                        printf("\n AUTO_EXP_USER_METERING\n");
-                        type = CAM_AEC_MODE_USER_METERING;
-                        break;
-                case AUTO_EXP_SPOT_METERING_ADV:
-                        printf("\n AUTO_EXP_SPOT_METERING_ADV\n");
-                        type = CAM_AEC_MODE_SPOT_METERING_ADV;
-                        break;
-                case AUTO_EXP_CENTER_WEIGHTED_ADV:
-                        printf("\n AUTO_EXP_CENTER_WEIGHTED_ADV\n");
-                        type = CAM_AEC_MODE_CENTER_WEIGHTED_ADV;
-                        break;
-                default:
-                        break;
-        }
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_EXPOSURE_METERING,
-                                          &type,
-                                          NULL);
-}
-
-int get_ctrl_value (int ctrl_value_mode_param){
-#if 0
-    int rc = 0;
-    struct v4l2_control ctrl;
-
-    if (ctrl_value_mode_param == WHITE_BALANCE_STATE) {
-        printf("You chose WHITE_BALANCE_STATE\n");
-        ctrl.id = V4L2_CID_AUTO_WHITE_BALANCE;
-    }
-    else if (ctrl_value_mode_param == WHITE_BALANCE_TEMPERATURE) {
-        printf("You chose WHITE_BALANCE_TEMPERATURE\n");
-        ctrl.id = V4L2_CID_WHITE_BALANCE_TEMPERATURE;
-    }
-    else if (ctrl_value_mode_param == BRIGHTNESS_CTRL) {
-        printf("You chose brightness value\n");
-        ctrl.id = V4L2_CID_BRIGHTNESS;
-    }
-    else if (ctrl_value_mode_param == EV) {
-        printf("You chose exposure value\n");
-        ctrl.id = V4L2_CID_EXPOSURE;
-    }
-    else if (ctrl_value_mode_param == CONTRAST_CTRL) {
-        printf("You chose contrast value\n");
-        ctrl.id = V4L2_CID_CONTRAST;
-    }
-    else if (ctrl_value_mode_param == SATURATION_CTRL) {
-        printf("You chose saturation value\n");
-        ctrl.id = V4L2_CID_SATURATION;
-    } else if (ctrl_value_mode_param == SHARPNESS_CTRL) {
-        printf("You chose sharpness value\n");
-        ctrl.id = V4L2_CID_SHARPNESS;
-    }
-
-  //  rc = ioctl(camfd, VIDIOC_G_CTRL, &ctrl);
-    return rc;
-#endif
-  return ctrl_value_mode_param;
-}
-
-/*===========================================================================
- * FUNCTION     - toggle_afr -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int toggle_afr () {
-#if 0
-    if (fps_mode == FPS_MODE_AUTO) {
-        printf("\nSetting FPS_MODE_FIXED\n");
-        fps_mode = FPS_MODE_FIXED;
-    } else {
-        printf("\nSetting FPS_MODE_AUTO\n");
-        fps_mode = FPS_MODE_AUTO;
-    }
-    return mm_app_set_config_parm(cam_id, MM_CAMERA_PARM_FPS_MODE, fps_mode);
-#endif
-  return 0;
-}
-int set_zoom (mm_camera_lib_handle *lib_handle, int zoom_action_param) {
-
-    if (zoom_action_param == ZOOM_IN) {
-        zoom_level += ZOOM_STEP;
-        if (zoom_level > zoom_max_value)
-            zoom_level = zoom_max_value;
-    } else if (zoom_action_param == ZOOM_OUT) {
-        zoom_level -= ZOOM_STEP;
-        if (zoom_level < ZOOM_MIN_VALUE)
-            zoom_level = ZOOM_MIN_VALUE;
-    } else {
-        LOGD(" Invalid zoom_action_param value\n");
-        return -EINVAL;
-    }
-    return mm_camera_lib_send_command(lib_handle,
-                                      MM_CAMERA_LIB_ZOOM,
-                                      &zoom_level,
-                                      NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - set_iso -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int set_iso (mm_camera_lib_handle *lib_handle, int iso_action_param) {
-    cam_iso_mode_type type = 0;
-    switch (iso_action_param) {
-        case ISO_AUTO:
-            printf("\n ISO_AUTO\n");
-            type = CAM_ISO_MODE_AUTO;
-            break;
-        case ISO_DEBLUR:
-            printf("\n ISO_DEBLUR\n");
-            type = CAM_ISO_MODE_DEBLUR;
-            break;
-        case ISO_100:
-            printf("\n ISO_100\n");
-            type = CAM_ISO_MODE_100;
-            break;
-        case ISO_200:
-            printf("\n ISO_200\n");
-            type = CAM_ISO_MODE_200;
-            break;
-        case ISO_400:
-            printf("\n ISO_400\n");
-            type = CAM_ISO_MODE_400;
-            break;
-        case ISO_800:
-            printf("\n ISO_800\n");
-            type = CAM_ISO_MODE_800;
-            break;
-        case ISO_1600:
-            printf("\n ISO_1600\n");
-            type = CAM_ISO_MODE_1600;
-            break;
-        default:
-            break;
-    }
-    return mm_camera_lib_send_command(lib_handle,
-                                      MM_CAMERA_LIB_ISO,
-                                      &type,
-                                      NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - increase_sharpness -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int increase_sharpness (mm_camera_lib_handle *lib_handle) {
-    sharpness += CAMERA_SHARPNESS_STEP;
-    if (sharpness > CAMERA_MAX_SHARPNESS) {
-        sharpness = CAMERA_MAX_SHARPNESS;
-        printf("Reached max SHARPNESS. \n");
-    }
-    printf("Increase Sharpness to %d\n", sharpness);
-    return mm_camera_lib_send_command(lib_handle,
-                                      MM_CAMERA_LIB_SHARPNESS,
-                                      &sharpness,
-                                      NULL);
-}
-
-/*===========================================================================
- * FUNCTION     - decrease_sharpness -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int decrease_sharpness (mm_camera_lib_handle *lib_handle) {
-    sharpness -= CAMERA_SHARPNESS_STEP;
-    if (sharpness < CAMERA_MIN_SHARPNESS) {
-        sharpness = CAMERA_MIN_SHARPNESS;
-        printf("Reached min SHARPNESS. \n");
-    }
-    printf("Decrease Sharpness to %d\n", sharpness);
-    return mm_camera_lib_send_command(lib_handle,
-                                      MM_CAMERA_LIB_SHARPNESS,
-                                      &sharpness,
-                                      NULL);
-}
-
-int set_flash_mode (mm_camera_lib_handle *lib_handle, int action_param) {
-    cam_flash_mode_t type = 0;
-    switch (action_param) {
-        case FLASH_MODE_OFF:
-            printf("\n FLASH_MODE_OFF\n");
-            type = CAM_FLASH_MODE_OFF;
-            break;
-        case FLASH_MODE_AUTO:
-            printf("\n FLASH_MODE_AUTO\n");
-            type = CAM_FLASH_MODE_AUTO;
-            break;
-        case FLASH_MODE_ON:
-            printf("\n FLASH_MODE_ON\n");
-            type = CAM_FLASH_MODE_ON;
-            break;
-        case FLASH_MODE_TORCH:
-            printf("\n FLASH_MODE_TORCH\n");
-            type = CAM_FLASH_MODE_TORCH;
-            break;
-        default:
-            break;
-    }
-    return mm_camera_lib_send_command(lib_handle,
-                                      MM_CAMERA_LIB_FLASH,
-                                      &type,
-                                      NULL);
-}
-
-int set_bestshot_mode(mm_camera_lib_handle *lib_handle, int action_param) {
-    cam_scene_mode_type type = 0;
-    switch (action_param) {
-       case BESTSHOT_AUTO:
-            printf("\n BEST SHOT AUTO\n");
-            type = CAM_SCENE_MODE_OFF;
-            break;
-        case BESTSHOT_ACTION:
-            printf("\n BEST SHOT ACTION\n");
-            type = CAM_SCENE_MODE_ACTION;
-            break;
-        case BESTSHOT_PORTRAIT:
-            printf("\n BEST SHOT PORTRAIT\n");
-            type = CAM_SCENE_MODE_PORTRAIT;
-            break;
-        case BESTSHOT_LANDSCAPE:
-            printf("\n BEST SHOT LANDSCAPE\n");
-            type = CAM_SCENE_MODE_LANDSCAPE;
-            break;
-        case BESTSHOT_NIGHT:
-            printf("\n BEST SHOT NIGHT\n");
-            type = CAM_SCENE_MODE_NIGHT;
-            break;
-        case BESTSHOT_NIGHT_PORTRAIT:
-            printf("\n BEST SHOT NIGHT PORTRAIT\n");
-            type = CAM_SCENE_MODE_NIGHT_PORTRAIT;
-            break;
-        case BESTSHOT_THEATRE:
-            printf("\n BEST SHOT THREATRE\n");
-            type = CAM_SCENE_MODE_THEATRE;
-            break;
-        case BESTSHOT_BEACH:
-            printf("\n BEST SHOT BEACH\n");
-            type = CAM_SCENE_MODE_BEACH;
-            break;
-        case BESTSHOT_SNOW:
-            printf("\n BEST SHOT SNOW\n");
-            type = CAM_SCENE_MODE_SNOW;
-            break;
-        case BESTSHOT_SUNSET:
-            printf("\n BEST SHOT SUNSET\n");
-            type = CAM_SCENE_MODE_SUNSET;
-            break;
-        case BESTSHOT_ANTISHAKE:
-            printf("\n BEST SHOT ANTISHAKE\n");
-            type = CAM_SCENE_MODE_ANTISHAKE;
-            break;
-        case BESTSHOT_FIREWORKS:
-            printf("\n BEST SHOT FIREWORKS\n");
-            type = CAM_SCENE_MODE_FIREWORKS;
-            break;
-        case BESTSHOT_SPORTS:
-            printf("\n BEST SHOT SPORTS\n");
-            type = CAM_SCENE_MODE_SPORTS;
-            break;
-        case BESTSHOT_PARTY:
-            printf("\n BEST SHOT PARTY\n");
-            type = CAM_SCENE_MODE_PARTY;
-            break;
-        case BESTSHOT_CANDLELIGHT:
-            printf("\n BEST SHOT CANDLELIGHT\n");
-            type = CAM_SCENE_MODE_CANDLELIGHT;
-            break;
-        case BESTSHOT_ASD:
-            printf("\n BEST SHOT ASD\n");
-            type = CAM_SCENE_MODE_AUTO;
-            break;
-        case BESTSHOT_BACKLIGHT:
-            printf("\n BEST SHOT BACKLIGHT\n");
-            type = CAM_SCENE_MODE_BACKLIGHT;
-            break;
-        case BESTSHOT_FLOWERS:
-            printf("\n BEST SHOT FLOWERS\n");
-            type = CAM_SCENE_MODE_FLOWERS;
-            break;
-        case BESTSHOT_AR:
-            printf("\n BEST SHOT AR\n");
-            type = CAM_SCENE_MODE_AR;
-            break;
-        case BESTSHOT_HDR:
-            printf("\n BEST SHOT HDR\n");
-            type = CAM_SCENE_MODE_OFF;
-            break;
-        default:
-            break;
-        }
-        return mm_camera_lib_send_command(lib_handle,
-                                          MM_CAMERA_LIB_BESTSHOT,
-                                          &type,
-                                          NULL);
-}
-/*===========================================================================
- * FUNCTION     - print_current_menu -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-int print_current_menu (menu_id_change_t current_menu_id) {
-  if (current_menu_id == MENU_ID_MAIN) {
-    print_menu_preview_video ();
-  } else if (current_menu_id == MENU_ID_WHITEBALANCECHANGE) {
-    camera_preview_video_wb_change_tbl();
-  } else if (current_menu_id == MENU_ID_EXPMETERINGCHANGE) {
-    camera_preview_video_exp_metering_change_tbl();
-  } else if (current_menu_id == MENU_ID_GET_CTRL_VALUE) {
-    camera_preview_video_get_ctrl_value_tbl();
-  } else if (current_menu_id == MENU_ID_ISOCHANGE) {
-    camera_preview_video_iso_change_tbl();
-  } else if (current_menu_id == MENU_ID_BRIGHTNESSCHANGE) {
-    camera_brightness_change_tbl ();
-  } else if (current_menu_id == MENU_ID_CONTRASTCHANGE) {
-    camera_contrast_change_tbl ();
-  } else if (current_menu_id == MENU_ID_EVCHANGE) {
-    camera_EV_change_tbl ();
-  } else if (current_menu_id == MENU_ID_SATURATIONCHANGE) {
-    camera_saturation_change_tbl ();
-  } else if (current_menu_id == MENU_ID_ZOOMCHANGE) {
-    camera_preview_video_zoom_change_tbl();
-  } else if (current_menu_id == MENU_ID_SHARPNESSCHANGE) {
-    camera_preview_video_sharpness_change_tbl();
-  } else if (current_menu_id == MENU_ID_BESTSHOT) {
-    camera_set_bestshot_tbl();
-  } else if (current_menu_id == MENU_ID_FLASHMODE) {
-    camera_set_flashmode_tbl();
-  } else if (current_menu_id == MENU_ID_SENSORS ) {
-    camera_sensors_tbl();
-  } else if (current_menu_id == MENU_ID_SWITCH_RES ) {
-    camera_resolution_change_tbl();
-  }
-
-  return 0;
-}
-
-int filter_resolutions(mm_camera_lib_handle *lib_handle,
-                       DIMENSION_TBL_T *tbl,
-                       size_t tbl_size)
-{
-    size_t i, j;
-    cam_capability_t camera_cap;
-    int rc = 0;
-
-    if ( ( NULL == lib_handle ) || ( NULL == tbl ) ) {
-        return -1;
-    }
-
-    rc = mm_camera_lib_get_caps(lib_handle, &camera_cap);
-    if ( MM_CAMERA_OK != rc ) {
-        LOGE("mm_camera_lib_get_caps() err=%d\n",  rc);
-        return -1;
-    }
-
-    for( i = 0 ; i < tbl_size ; i++ ) {
-        for( j = 0; j < camera_cap.picture_sizes_tbl_cnt; j++ ) {
-            if ( ( tbl[i].width == camera_cap.picture_sizes_tbl[j].width ) &&
-                 ( tbl[i].height == camera_cap.picture_sizes_tbl[j].height ) ) {
-                tbl[i].supported = 1;
-                rc = (int)i;
-                break;
-            }
-        }
-    }
-
-    return rc;
-}
-
-/*===========================================================================
- * FUNCTION   : enableAFR
- *
- * DESCRIPTION: This function will go through the list
- *              of supported FPS ranges and select the
- *              one which has maximum range
- *
- * PARAMETERS :
- *   @lib_handle   : camera test library handle
- *
- * RETURN     : uint32_t type of stream handle
- *              MM_CAMERA_OK  -- Success
- *              !=MM_CAMERA_OK -- Error status
- *==========================================================================*/
-int enableAFR(mm_camera_lib_handle *lib_handle)
-{
-    size_t i, j;
-    float max_range = 0.0f;
-    cam_capability_t cap;
-    int rc = MM_CAMERA_OK;
-
-    if ( NULL == lib_handle ) {
-        return MM_CAMERA_E_INVALID_INPUT;
-    }
-
-    rc = mm_camera_lib_get_caps(lib_handle, &cap);
-    if ( MM_CAMERA_OK != rc ) {
-        LOGE("mm_camera_lib_get_caps() err=%d\n",  rc);
-        return rc;
-    }
-
-    for( i = 0, j = 0 ; i < cap.fps_ranges_tbl_cnt ; i++ ) {
-        if ( max_range < (cap.fps_ranges_tbl[i].max_fps - cap.fps_ranges_tbl[i].min_fps) ) {
-            j = i;
-        }
-    }
-
-    rc = mm_camera_lib_send_command(lib_handle,
-                                    MM_CAMERA_LIB_FPS_RANGE,
-                                    &cap.fps_ranges_tbl[j],
-                                    NULL);
-
-    LOGE("FPS range [%5.2f:%5.2f] rc = %d",
-              cap.fps_ranges_tbl[j].min_fps,
-              cap.fps_ranges_tbl[j].max_fps,
-              rc);
-
-    return rc;
-}
-
-/*===========================================================================
- * FUNCTION     - submain -
- *
- * DESCRIPTION:
- * ===========================================================================*/
-static int submain()
-{
-    int rc = 0;
-    char tc_buf[3];
-    menu_id_change_t current_menu_id = MENU_ID_MAIN, next_menu_id;
-    camera_action_t action_id;
-    int action_param;
-    uint8_t previewing = 0;
-    int isZSL = 0;
-    int isezTune = 0;
-    uint8_t wnr_enabled = 0;
-    mm_camera_lib_handle lib_handle;
-    int num_cameras;
-    int available_sensors =
-        (int)(sizeof(sensor_tbl) / sizeof(sensor_tbl[0]));
-    int available_snap_sizes =
-        (int)(sizeof(dimension_tbl)/sizeof(dimension_tbl[0]));
-    int i,c;
-    mm_camera_lib_snapshot_params snap_dim;
-    snap_dim.width = DEFAULT_SNAPSHOT_WIDTH;
-    snap_dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    cam_scene_mode_type default_scene= CAM_SCENE_MODE_OFF;
-    int set_tintless= 0;
-
-    mm_camera_test_obj_t test_obj;
-    memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-
-    rc = mm_camera_lib_open(&lib_handle, 0);
-    if (rc != MM_CAMERA_OK) {
-        LOGE("mm_camera_lib_open() err=%d\n",  rc);
-        return -1;
-    }
-
-    num_cameras = mm_camera_lib_number_of_cameras(&lib_handle);
-    if ( 0 >= num_cameras ) {
-        LOGE(" No camera sensors reported!");
-        rc = -1;
-        goto ERROR;
-    } else if ( 1 <= num_cameras ) {
-        c = MIN(num_cameras, available_sensors);
-        for ( i = 0 ; i < c ; i++ ) {
-            sensor_tbl[i].present = 1;
-        }
-        current_menu_id = MENU_ID_SENSORS;
-    } else {
-        i = filter_resolutions(&lib_handle,
-                                dimension_tbl,
-                                (size_t)available_snap_sizes);
-        if ( ( i < 0 ) || ( i >= available_snap_sizes ) ) {
-            LOGE("filter_resolutions()\n");
-            goto ERROR;
-        }
-        snap_dim.width = dimension_tbl[i].width;
-        snap_dim.height = dimension_tbl[i].height;
-
-        rc = enableAFR(&lib_handle);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("enableAFR() err=%d\n",  rc);
-            goto ERROR;
-        }
-
-        rc =  mm_camera_lib_send_command(&lib_handle,
-                                         MM_CAMERA_LIB_BESTSHOT,
-                                         &default_scene,
-                                         NULL);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-            goto ERROR;
-        }
-    }
-
-    do {
-        print_current_menu (current_menu_id);
-        fgets(tc_buf, 3, stdin);
-
-        next_menu_id = next_menu(current_menu_id, tc_buf[0], & action_id, & action_param);
-
-        if (next_menu_id != MENU_ID_INVALID) {
-          current_menu_id = next_menu_id;
-        }
-        if (action_id == ACTION_NO_ACTION) {
-          continue;
-        }
-
-        switch(action_id) {
-            case ACTION_START_PREVIEW:
-                LOGE("ACTION_START_PREVIEW \n");
-                rc = mm_camera_lib_start_stream(&lib_handle);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_start_stream() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                previewing = 1;
-                break;
-
-            case ACTION_STOP_PREVIEW:
-                LOGD("ACTION_STOP_PREVIEW \n");
-                rc = mm_camera_lib_stop_stream(&lib_handle);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_stop_stream() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                previewing = 0;
-                break;
-
-            case ACTION_SET_WHITE_BALANCE:
-                LOGD("Selection for the White Balance changes\n");
-                set_whitebalance(&lib_handle, action_param);
-                break;
-
-            case ACTION_SET_TINTLESS_ENABLE:
-                LOGD("Selection for the Tintless enable changes\n");
-                set_tintless = 1;
-                rc =  mm_camera_lib_send_command(&lib_handle,
-                                                 MM_CAMERA_LIB_SET_TINTLESS,
-                                                 &set_tintless,
-                                                 NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_SET_TINTLESS_DISABLE:
-                LOGD("Selection for the Tintless disable changes\n");
-                set_tintless = 0;
-                rc =  mm_camera_lib_send_command(&lib_handle,
-                                                 MM_CAMERA_LIB_SET_TINTLESS,
-                                                 &set_tintless,
-                                                 NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_SET_EXP_METERING:
-                LOGD("Selection for the Exposure Metering changes\n");
-                set_exp_metering(&lib_handle, action_param);
-                break;
-
-            case ACTION_GET_CTRL_VALUE:
-                LOGD("Selection for getting control value\n");
-                get_ctrl_value(action_param);
-                break;
-
-            case ACTION_BRIGHTNESS_INCREASE:
-                printf("Increase brightness\n");
-                increase_brightness(&lib_handle);
-                break;
-
-            case ACTION_BRIGHTNESS_DECREASE:
-                printf("Decrease brightness\n");
-                decrease_brightness(&lib_handle);
-                break;
-
-            case ACTION_CONTRAST_INCREASE:
-                LOGD("Selection for the contrast increase\n");
-                increase_contrast (&lib_handle);
-                break;
-
-            case ACTION_CONTRAST_DECREASE:
-                LOGD("Selection for the contrast decrease\n");
-                decrease_contrast (&lib_handle);
-                break;
-
-            case ACTION_EV_INCREASE:
-                LOGD("Selection for the EV increase\n");
-                increase_EV ();
-                break;
-
-            case ACTION_EV_DECREASE:
-                LOGD("Selection for the EV decrease\n");
-                decrease_EV ();
-                break;
-
-            case ACTION_SATURATION_INCREASE:
-                LOGD("Selection for the EV increase\n");
-                increase_saturation (&lib_handle);
-                break;
-
-            case ACTION_SATURATION_DECREASE:
-                LOGD("Selection for the EV decrease\n");
-                decrease_saturation (&lib_handle);
-                break;
-
-            case ACTION_TOGGLE_AFR:
-                LOGD("Select for auto frame rate toggling\n");
-                toggle_afr();
-                break;
-
-            case ACTION_TOGGLE_EZTUNE:
-                LOGE("Select for EzTune");
-                printf("EZTUNE Toggle\n");
-                isezTune = !isezTune;
-                if (isezTune) {
-                    printf("EZ TUNE On !!!");
-                } else {
-                    printf("EZ TUNE Off !!!");
-                }
-
-                rc = mm_camera_lib_send_command(&lib_handle,
-                                      MM_CAMERA_LIB_EZTUNE_ENABLE,
-                                      &isezTune,
-                                      NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_SET_ISO:
-                LOGD("Select for ISO changes\n");
-                set_iso(&lib_handle, action_param);
-                break;
-
-            case ACTION_SET_ZOOM:
-                LOGD("Selection for the zoom direction changes\n");
-                set_zoom(&lib_handle, action_param);
-                break;
-
-            case ACTION_SHARPNESS_INCREASE:
-                LOGD("Selection for sharpness increase\n");
-                increase_sharpness(&lib_handle);
-                break;
-
-            case ACTION_SHARPNESS_DECREASE:
-                LOGD("Selection for sharpness decrease\n");
-                decrease_sharpness(&lib_handle);
-                break;
-
-            case ACTION_SET_BESTSHOT_MODE:
-                LOGD("Selection for bestshot\n");
-                set_bestshot_mode(&lib_handle, action_param);
-                break;
-
-            case ACTION_SET_FLASH_MODE:
-                printf("\n Selection for flashmode\n");
-                set_flash_mode(&lib_handle, action_param);
-                break;
-
-            case ACTION_SWITCH_CAMERA:
-                rc = mm_camera_lib_close(&lib_handle);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_close() err=%d\n",  rc);
-                    goto ERROR;
-                }
-
-                rc = mm_camera_lib_open(&lib_handle, action_param);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_open() err=%d\n",  rc);
-                    goto ERROR;
-                }
-
-                i = filter_resolutions(&lib_handle,
-                                        dimension_tbl,
-                                        sizeof(dimension_tbl)/sizeof(dimension_tbl[0]));
-                if ( ( i < 0 ) || ( i >=  available_snap_sizes ) ) {
-                    LOGE("filter_resolutions()\n");
-                    goto ERROR;
-                }
-                snap_dim.width = dimension_tbl[i].width;
-                snap_dim.height = dimension_tbl[i].height;
-
-                rc = enableAFR(&lib_handle);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("enableAFR() err=%d\n",  rc);
-                    goto ERROR;
-                }
-
-                rc =  mm_camera_lib_send_command(&lib_handle,
-                                                 MM_CAMERA_LIB_BESTSHOT,
-                                                 &default_scene,
-                                                 NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_TOGGLE_ZSL:
-                printf("ZSL Toggle !!!\n");
-                isZSL = !isZSL;
-                if ( isZSL ) {
-                    printf("ZSL on !!!\n");
-                } else {
-                    printf("ZSL off !!!\n");
-                }
-                rc = mm_camera_lib_send_command(&lib_handle,
-                                                MM_CAMERA_LIB_ZSL_ENABLE,
-                                                &isZSL,
-                                                NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_TAKE_RAW_SNAPSHOT:
-                LOGH("\n Take RAW snapshot\n");
-
-                rc = mm_camera_lib_send_command(&lib_handle,
-                                                MM_CAMERA_LIB_DO_AF,
-                                                NULL,
-                                                NULL);
-
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-
-                rc = mm_camera_lib_send_command(&lib_handle,
-                                                MM_CAMERA_LIB_RAW_CAPTURE,
-                                                NULL,
-                                                NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-
-            case ACTION_TAKE_JPEG_SNAPSHOT:
-                LOGH("\n Take JPEG snapshot\n");
-
-                rc = mm_camera_lib_send_command(&lib_handle,
-                                                MM_CAMERA_LIB_JPEG_CAPTURE,
-                                                &snap_dim,
-                                                NULL);
-                if (rc != MM_CAMERA_OK) {
-                    LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-                    goto ERROR;
-                }
-                break;
-            case ACTION_SWITCH_RESOLUTION:
-                printf("\n Switch snapshot resolution to %dx%d\n",
-                       dimension_tbl[action_param].width,
-                       dimension_tbl[action_param].height);
-                snap_dim.width = dimension_tbl[action_param].width;
-                snap_dim.height = dimension_tbl[action_param].height;
-                break;
-
-           case ACTION_START_RECORDING:
-             LOGD("Start recording action\n");
-             mm_app_start_record_preview(&lib_handle.test_obj);
-             is_rec = 1;
-             break;
-
-           case ACTION_STOP_RECORDING:
-             LOGD("Stop recording action\n");
-             if(is_rec) {
-                 mm_app_stop_record_preview(&lib_handle.test_obj);
-                 is_rec = 0;
-             }
-
-             break;
-      case ACTION_TAKE_LIVE_SNAPSHOT:
-        printf("Selection for live shot\n");
-#if 0
-        if(is_rec)
-           mm_app_take_live_snapshot(cam_id);
-        else
-           printf("\n !!! Use live snapshot option while recording only !!!\n");
-#endif
-        break;
-
-        case ACTION_TOGGLE_WNR:
-          wnr_enabled = !wnr_enabled;
-          printf("WNR Enabled = %d\n", wnr_enabled);
-          rc = mm_camera_lib_send_command(&lib_handle,
-                                          MM_CAMERA_LIB_WNR_ENABLE,
-                                          &wnr_enabled,
-                                          NULL);
-          if (rc != MM_CAMERA_OK) {
-              LOGE("mm_camera_lib_send_command() err=%d\n",  rc);
-              goto ERROR;
-          }
-          break;
-
-        case ACTION_EXIT:
-            printf("Exiting....\n");
-            break;
-        case ACTION_NO_ACTION:
-            printf("Go back to main menu");
-            break;
-
-        default:
-            printf("\n\n!!!!!WRONG INPUT: %d!!!!\n", action_id);
-            break;
-    }
-
-    usleep(1000 * 1000);
-    LOGD("action_id = %d\n", action_id);
-
-  } while (action_id != ACTION_EXIT);
-  action_id = ACTION_NO_ACTION;
-
-    mm_camera_lib_close(&lib_handle);
-    return 0;
-
-ERROR:
-
-    mm_camera_lib_close(&lib_handle);
-
-    return rc;
-}
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
deleted file mode 100644
index 63b4ce2..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_preview.c
+++ /dev/null
@@ -1,1477 +0,0 @@
-/*
-Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// System dependencies
-#include <assert.h>
-#include <errno.h>
-#include <fcntl.h>
-#define MMAN_H <SYSTEM_HEADER_PREFIX/mman.h>
-#include MMAN_H
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-#include "mm_qcamera_app.h"
-#include <assert.h>
-#include <sys/mman.h>
-#include <semaphore.h>
-
-static void mm_app_metadata_notify_cb(mm_camera_super_buf_t *bufs,
-                                     void *user_data)
-{
-  uint32_t i = 0;
-  mm_camera_channel_t *channel = NULL;
-  mm_camera_stream_t *p_stream = NULL;
-  mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-  mm_camera_buf_def_t *frame;
-  metadata_buffer_t *pMetadata;
-
-  if (NULL == bufs || NULL == user_data) {
-      LOGE("bufs or user_data are not valid ");
-      return;
-  }
-  frame = bufs->bufs[0];
-
-  /* find channel */
-  for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-      if (pme->channels[i].ch_id == bufs->ch_id) {
-          channel = &pme->channels[i];
-          break;
-      }
-  }
-
-  if (NULL == channel) {
-      LOGE("Channel object is NULL ");
-      return;
-  }
-
-  /* find preview stream */
-  for (i = 0; i < channel->num_streams; i++) {
-      if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_METADATA) {
-          p_stream = &channel->streams[i];
-          break;
-      }
-  }
-
-  if (NULL == p_stream) {
-      LOGE("cannot find metadata stream");
-      return;
-  }
-
-  /* find preview frame */
-  for (i = 0; i < bufs->num_bufs; i++) {
-      if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-          frame = bufs->bufs[i];
-          break;
-      }
-  }
-
-  if (pme->metadata == NULL) {
-    /* The app will free the meta data, we don't need to bother here */
-    pme->metadata = malloc(sizeof(metadata_buffer_t));
-    if (NULL == pme->metadata) {
-        LOGE("Canot allocate metadata memory\n");
-        return;
-    }
-  }
-  memcpy(pme->metadata, frame->buffer, sizeof(metadata_buffer_t));
-
-  pMetadata = (metadata_buffer_t *)frame->buffer;
-  IF_META_AVAILABLE(uint32_t, afState, CAM_INTF_META_AF_STATE, pMetadata) {
-    if ((cam_af_state_t)(*afState) == CAM_AF_STATE_FOCUSED_LOCKED ||
-            (cam_af_state_t)(*afState) == CAM_AF_STATE_NOT_FOCUSED_LOCKED) {
-        LOGE("AutoFocus Done Call Back Received\n");
-        mm_camera_app_done();
-    } else if ((cam_af_state_t)(*afState) == CAM_AF_STATE_NOT_FOCUSED_LOCKED) {
-        LOGE("AutoFocus failed\n");
-        mm_camera_app_done();
-    }
-  }
-
-  if (pme->user_metadata_cb) {
-      LOGD("[DBG] %s, user defined own metadata cb. calling it...");
-      pme->user_metadata_cb(frame);
-  }
-
-  if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                          bufs->ch_id,
-                                          frame)) {
-      LOGE("Failed in Preview Qbuf\n");
-  }
-  mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                   ION_IOC_INV_CACHES);
-}
-
-static void mm_app_snapshot_notify_cb(mm_camera_super_buf_t *bufs,
-                                      void *user_data)
-{
-
-    int rc = 0;
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_buf_def_t *p_frame = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE("Wrong channel id (%d)",  bufs->ch_id);
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_SNAPSHOT) {
-            m_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == m_stream) {
-        LOGE("cannot find snapshot stream");
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == m_stream->s_id) {
-            m_frame = bufs->bufs[i];
-            break;
-        }
-    }
-    if (NULL == m_frame) {
-        LOGE("main frame is NULL");
-        rc = -1;
-        goto error;
-    }
-
-    mm_app_dump_frame(m_frame, "main", "yuv", m_frame->frame_idx);
-
-    /* find postview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_POSTVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL != p_stream) {
-        /* find preview frame */
-        for (i = 0; i < bufs->num_bufs; i++) {
-            if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-                p_frame = bufs->bufs[i];
-                break;
-            }
-        }
-        if (NULL != p_frame) {
-            mm_app_dump_frame(p_frame, "postview", "yuv", p_frame->frame_idx);
-        }
-    }
-
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)m_frame->mem_info,
-                     ION_IOC_CLEAN_INV_CACHES);
-
-    pme->jpeg_buf.buf.buffer = (uint8_t *)malloc(m_frame->frame_len);
-    if ( NULL == pme->jpeg_buf.buf.buffer ) {
-        LOGE("error allocating jpeg output buffer");
-        goto error;
-    }
-
-    pme->jpeg_buf.buf.frame_len = m_frame->frame_len;
-    /* create a new jpeg encoding session */
-    rc = createEncodingSession(pme, m_stream, m_frame);
-    if (0 != rc) {
-        LOGE("error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-    /* start jpeg encoding job */
-    rc = encodeData(pme, bufs, m_stream);
-    if (0 != rc) {
-        LOGE("error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-error:
-    /* buf done rcvd frames in error case */
-    if ( 0 != rc ) {
-        for (i=0; i<bufs->num_bufs; i++) {
-            if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                    bufs->ch_id,
-                                                    bufs->bufs[i])) {
-                LOGE("Failed in Qbuf\n");
-            }
-            mm_app_cache_ops((mm_camera_app_meminfo_t *)bufs->bufs[i]->mem_info,
-                             ION_IOC_INV_CACHES);
-        }
-    }
-
-    LOGD(" END\n");
-}
-
-static void mm_app_preview_notify_cb(mm_camera_super_buf_t *bufs,
-                                     void *user_data)
-{
-    uint32_t i = 0;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_buf_def_t *frame = NULL;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-
-    if (NULL == bufs || NULL == user_data) {
-        LOGE("bufs or user_data are not valid ");
-        return;
-    }
-
-    frame = bufs->bufs[0];
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE("Channel object is NULL ");
-        return;
-    }
-    /* find preview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_PREVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-
-    if (NULL == p_stream) {
-        LOGE("cannot find preview stream");
-        return;
-    }
-
-    /* find preview frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-            frame = bufs->bufs[i];
-            break;
-        }
-    }
-
-    if ( 0 < pme->fb_fd ) {
-        mm_app_overlay_display(pme, frame->fd);
-    }
-#ifdef DUMP_PRV_IN_FILE
-    {
-        char file_name[64];
-        snprintf(file_name, sizeof(file_name), "P_C%d", pme->cam->camera_handle);
-        mm_app_dump_frame(frame, file_name, "yuv", frame->frame_idx);
-    }
-#endif
-    if (pme->user_preview_cb) {
-        LOGE("[DBG] %s, user defined own preview cb. calling it...");
-        pme->user_preview_cb(frame);
-    }
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                bufs->ch_id,
-                frame)) {
-        LOGE("Failed in Preview Qbuf\n");
-    }
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-            ION_IOC_INV_CACHES);
-
-    LOGD(" END\n");
-}
-
-static void mm_app_zsl_notify_cb(mm_camera_super_buf_t *bufs,
-                                 void *user_data)
-{
-    int rc = MM_CAMERA_OK;
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_stream_t *md_stream = NULL;
-    mm_camera_buf_def_t *p_frame = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-    mm_camera_buf_def_t *md_frame = NULL;
-
-    LOGD(" BEGIN\n");
-
-    if (NULL == bufs || NULL == user_data) {
-        LOGE("bufs or user_data are not valid ");
-        return;
-    }
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE("Wrong channel id (%d)",  bufs->ch_id);
-        return;
-    }
-
-    /* find preview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_PREVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == p_stream) {
-        LOGE("cannot find preview stream");
-        return;
-    }
-
-    /* find snapshot stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_SNAPSHOT) {
-            m_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == m_stream) {
-        LOGE("cannot find snapshot stream");
-        return;
-    }
-
-    /* find metadata stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_METADATA) {
-            md_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == md_stream) {
-        LOGE("cannot find metadata stream");
-    }
-
-    /* find preview frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-            p_frame = bufs->bufs[i];
-            break;
-        }
-    }
-
-    if(md_stream) {
-      /* find metadata frame */
-      for (i = 0; i < bufs->num_bufs; i++) {
-          if (bufs->bufs[i]->stream_id == md_stream->s_id) {
-              md_frame = bufs->bufs[i];
-              break;
-          }
-      }
-      if (!md_frame) {
-          LOGE("md_frame is null\n");
-          return;
-      }
-      if (!pme->metadata) {
-          /* App will free the metadata */
-          pme->metadata = malloc(sizeof(metadata_buffer_t));
-          if (!pme->metadata) {
-              LOGE("not enough memory\n");
-              return;
-          }
-      }
-
-      memcpy(pme->metadata , md_frame->buffer, sizeof(metadata_buffer_t));
-    }
-    /* find snapshot frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == m_stream->s_id) {
-            m_frame = bufs->bufs[i];
-            break;
-        }
-    }
-
-    if (!m_frame || !p_frame) {
-        LOGE("cannot find preview/snapshot frame");
-        return;
-    }
-
-    LOGD(" ZSL CB with fb_fd = %d, m_frame = %p, p_frame = %p \n",
-         pme->fb_fd,
-         m_frame,
-         p_frame);
-
-    if ( 0 < pme->fb_fd ) {
-        mm_app_overlay_display(pme, p_frame->fd);
-    }/* else {
-        mm_app_dump_frame(p_frame, "zsl_preview", "yuv", p_frame->frame_idx);
-        mm_app_dump_frame(m_frame, "zsl_main", "yuv", m_frame->frame_idx);
-    }*/
-
-    if ( pme->enable_reproc && ( NULL != pme->reproc_stream ) ) {
-
-        if (NULL != md_frame) {
-            rc = mm_app_do_reprocess(pme,
-                    m_frame,
-                    md_frame->buf_idx,
-                    bufs,
-                    md_stream);
-
-            if (MM_CAMERA_OK != rc ) {
-                LOGE("reprocess failed rc = %d",  rc);
-            }
-        } else {
-            LOGE("md_frame is null\n");
-        }
-
-      return;
-    }
-
-    if ( pme->encodeJpeg ) {
-        pme->jpeg_buf.buf.buffer = (uint8_t *)malloc(m_frame->frame_len);
-        if ( NULL == pme->jpeg_buf.buf.buffer ) {
-            LOGE("error allocating jpeg output buffer");
-            goto exit;
-        }
-
-        pme->jpeg_buf.buf.frame_len = m_frame->frame_len;
-        /* create a new jpeg encoding session */
-        rc = createEncodingSession(pme, m_stream, m_frame);
-        if (0 != rc) {
-            LOGE("error creating jpeg session");
-            free(pme->jpeg_buf.buf.buffer);
-            goto exit;
-        }
-
-        /* start jpeg encoding job */
-        rc = encodeData(pme, bufs, m_stream);
-        pme->encodeJpeg = 0;
-    } else {
-        if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                bufs->ch_id,
-                                                m_frame)) {
-            LOGE("Failed in main Qbuf\n");
-        }
-        mm_app_cache_ops((mm_camera_app_meminfo_t *)m_frame->mem_info,
-                         ION_IOC_INV_CACHES);
-    }
-
-exit:
-
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                            bufs->ch_id,
-                                            p_frame)) {
-        LOGE("Failed in preview Qbuf\n");
-    }
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)p_frame->mem_info,
-                     ION_IOC_INV_CACHES);
-
-    if(md_frame) {
-      if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                              bufs->ch_id,
-                                              md_frame)) {
-          LOGE("Failed in metadata Qbuf\n");
-      }
-      mm_app_cache_ops((mm_camera_app_meminfo_t *)md_frame->mem_info,
-                       ION_IOC_INV_CACHES);
-    }
-
-    LOGD(" END\n");
-}
-
-mm_camera_stream_t * mm_app_add_metadata_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_METADATA;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-    stream->s_config.stream_info->dim.width = sizeof(metadata_buffer_t);
-    stream->s_config.stream_info->dim.height = 1;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-cam_dimension_t mm_app_get_analysis_stream_dim(
-                                               const mm_camera_test_obj_t *test_obj,
-                                               const cam_dimension_t* preview_dim)
-{
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_dimension_t max_analysis_dim =
-        cam_cap->analysis_info[CAM_ANALYSIS_INFO_FD_STILL].analysis_max_res;
-    cam_dimension_t analysis_dim = {0, 0};
-
-    if (preview_dim->width > max_analysis_dim.width ||
-            preview_dim->height > max_analysis_dim.height) {
-        double max_ratio, requested_ratio;
-
-        max_ratio = (double)max_analysis_dim.width / (double)max_analysis_dim.height;
-        requested_ratio = (double)preview_dim->width / (double)preview_dim->height;
-
-        if (max_ratio < requested_ratio) {
-            analysis_dim.width = max_analysis_dim.width;
-            analysis_dim.height = (int32_t)((double)max_analysis_dim.width / requested_ratio);
-        } else {
-            analysis_dim.height = max_analysis_dim.height;
-            analysis_dim.width = (int32_t)((double)max_analysis_dim.height * requested_ratio);
-        }
-        analysis_dim.width &= ~0x1;
-        analysis_dim.height &= ~0x1;
-    } else {
-        analysis_dim = *preview_dim;
-    }
-
-    LOGI("analysis stream dim (%d x %d)\n",  analysis_dim.width, analysis_dim.height);
-    return analysis_dim;
-}
-
-mm_camera_stream_t * mm_app_add_analysis_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_dimension_t preview_dim = {0, 0};
-    cam_dimension_t analysis_dim = {0, 0};
-
-    if ((test_obj->preview_resolution.user_input_display_width == 0) ||
-           ( test_obj->preview_resolution.user_input_display_height == 0)) {
-        preview_dim.width = DEFAULT_PREVIEW_WIDTH;
-        preview_dim.height = DEFAULT_PREVIEW_HEIGHT;
-    } else {
-        preview_dim.width = test_obj->preview_resolution.user_input_display_width;
-        preview_dim.height = test_obj->preview_resolution.user_input_display_height;
-    }
-
-    analysis_dim = mm_app_get_analysis_stream_dim(test_obj, &preview_dim);
-    LOGI("analysis stream dimesion: %d x %d\n",
-            analysis_dim.width, analysis_dim.height);
-    if (analysis_dim.width == 0 || analysis_dim.height == 0) {
-        /* FD or PAAF might not be enabled , use preview dim */
-        return NULL;
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_ANALYSIS;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-    stream->s_config.stream_info->dim = analysis_dim;
-    stream->s_config.padding_info =
-        cam_cap->analysis_info[CAM_ANALYSIS_INFO_FD_STILL].analysis_padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-mm_camera_stream_t * mm_app_add_ZSL_preview_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_dimension_t preview_dim = {0, 0};
-    cam_dimension_t analysis_dim = {0, 0};
-
-    if ((test_obj->preview_resolution.user_input_display_width == 0) ||
-           ( test_obj->preview_resolution.user_input_display_height == 0)) {
-        preview_dim.width = DEFAULT_PREVIEW_WIDTH;
-        preview_dim.height = DEFAULT_PREVIEW_HEIGHT;
-    } else {
-        preview_dim.width = test_obj->preview_resolution.user_input_display_width;
-        preview_dim.height = test_obj->preview_resolution.user_input_display_height;
-    }
-    LOGI("preview dimesion: %d x %d\n",  preview_dim.width, preview_dim.height);
-
-    analysis_dim = mm_app_get_analysis_stream_dim(test_obj, &preview_dim);
-    LOGI("analysis stream dimesion: %d x %d\n",
-            analysis_dim.width, analysis_dim.height);
-
-    uint32_t analysis_pp_mask = cam_cap->qcom_supported_feature_mask &
-                                        (CAM_QCOM_FEATURE_SHARPNESS |
-                                         CAM_QCOM_FEATURE_EFFECT |
-                                         CAM_QCOM_FEATURE_DENOISE2D);
-    LOGI("analysis stream pp mask:%x\n",  analysis_pp_mask);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_PREVIEW;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-
-    stream->s_config.stream_info->dim.width = preview_dim.width;
-    stream->s_config.stream_info->dim.height = preview_dim.height;
-
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-
-mm_camera_stream_t * mm_app_add_preview_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_dimension_t preview_dim = {0, 0};
-    cam_dimension_t analysis_dim = {0, 0};
-
-    if ((test_obj->preview_resolution.user_input_display_width == 0) ||
-           ( test_obj->preview_resolution.user_input_display_height == 0)) {
-        preview_dim.width = DEFAULT_PREVIEW_WIDTH;
-        preview_dim.height = DEFAULT_PREVIEW_HEIGHT;
-    } else {
-        preview_dim.width = test_obj->preview_resolution.user_input_display_width;
-        preview_dim.height = test_obj->preview_resolution.user_input_display_height;
-    }
-    LOGI("preview dimesion: %d x %d\n",  preview_dim.width, preview_dim.height);
-
-    analysis_dim = mm_app_get_analysis_stream_dim(test_obj, &preview_dim);
-    LOGI("analysis stream dimesion: %d x %d\n",
-            analysis_dim.width, analysis_dim.height);
-
-    uint32_t analysis_pp_mask = cam_cap->qcom_supported_feature_mask &
-                                        (CAM_QCOM_FEATURE_SHARPNESS |
-                                         CAM_QCOM_FEATURE_EFFECT |
-                                         CAM_QCOM_FEATURE_DENOISE2D);
-    LOGI("analysis stream pp mask:%x\n",  analysis_pp_mask);
-
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-    if (analysis_dim.width != 0 && analysis_dim.height != 0) {
-      abc.num_streams = 2;
-    } else {
-      abc.num_streams = 1;
-    }
-    abc.postprocess_mask[0] = 2178;
-    abc.stream_sizes[0].width = preview_dim.width;
-    abc.stream_sizes[0].height = preview_dim.height;
-    abc.type[0] = CAM_STREAM_TYPE_PREVIEW;
-
-    if (analysis_dim.width != 0 && analysis_dim.height != 0) {
-      abc.postprocess_mask[1] = analysis_pp_mask;
-      abc.stream_sizes[1].width = analysis_dim.width;
-      abc.stream_sizes[1].height = analysis_dim.height;
-      abc.type[1] = CAM_STREAM_TYPE_ANALYSIS;
-    }
-
-    abc.buffer_info.min_buffers = 10;
-    abc.buffer_info.max_buffers = 10;
-    abc.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_PREVIEW;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-
-    if (test_obj->enable_EZTune) {
-        stream->s_config.stream_info->pp_config.feature_mask = CAM_QCOM_FEATURE_EZTUNE;
-    }
-
-    stream->s_config.stream_info->dim.width = preview_dim.width;
-    stream->s_config.stream_info->dim.height = preview_dim.height;
-
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_stream_t * mm_app_add_raw_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-    abc.num_streams = 1;
-    abc.postprocess_mask[0] = 0;
-
-    if ( test_obj->buffer_width == 0 || test_obj->buffer_height == 0 ) {
-        abc.stream_sizes[0].width = DEFAULT_SNAPSHOT_WIDTH;
-        abc.stream_sizes[0].height = DEFAULT_SNAPSHOT_HEIGHT;
-    } else {
-        abc.stream_sizes[0].width = (int32_t)test_obj->buffer_width;
-        abc.stream_sizes[0].height = (int32_t)test_obj->buffer_height;
-    }
-    abc.type[0] = CAM_STREAM_TYPE_RAW;
-
-    abc.buffer_info.min_buffers = num_bufs;
-    abc.buffer_info.max_buffers = num_bufs;
-    abc.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_RAW;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = test_obj->buffer_format;
-    if ( test_obj->buffer_width == 0 || test_obj->buffer_height == 0 ) {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    } else {
-        stream->s_config.stream_info->dim.width = (int32_t)test_obj->buffer_width;
-        stream->s_config.stream_info->dim.height = (int32_t)test_obj->buffer_height;
-    }
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_stream_t * mm_app_add_ZSL_snapshot_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-  int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_stream_size_info_t abc_snap ;
-    memset (&abc_snap , 0, sizeof (cam_stream_size_info_t));
-
-    abc_snap.num_streams = 2;
-    abc_snap.postprocess_mask[1] = 2178;
-    abc_snap.stream_sizes[1].width = DEFAULT_PREVIEW_WIDTH;
-    abc_snap.stream_sizes[1].height = DEFAULT_PREVIEW_HEIGHT;
-    abc_snap.type[1] = CAM_STREAM_TYPE_PREVIEW;
-
-    abc_snap.postprocess_mask[0] = 0;
-    abc_snap.stream_sizes[0].width = DEFAULT_SNAPSHOT_WIDTH;
-    abc_snap.stream_sizes[0].height = DEFAULT_SNAPSHOT_HEIGHT;
-    abc_snap.type[0] = CAM_STREAM_TYPE_SNAPSHOT;
-
-    abc_snap.buffer_info.min_buffers = 7;
-    abc_snap.buffer_info.max_buffers = 7;
-    abc_snap.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc_snap);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command snapshot failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_SNAPSHOT;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_SNAPSHOT_FORMAT;
-    if ( test_obj->buffer_width == 0 || test_obj->buffer_height == 0 ) {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    } else {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    }
-    stream->s_config.padding_info = cam_cap->padding_info;
-    /* Make offset as zero as CPP will not be used  */
-    stream->s_config.padding_info.offset_info.offset_x = 0;
-    stream->s_config.padding_info.offset_info.offset_y = 0;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-
-mm_camera_stream_t * mm_app_add_snapshot_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_stream_size_info_t abc_snap ;
-    memset (&abc_snap , 0, sizeof (cam_stream_size_info_t));
-
-    abc_snap.num_streams = 2;
-    abc_snap.postprocess_mask[1] = 2178;
-    abc_snap.stream_sizes[1].width = DEFAULT_PREVIEW_WIDTH;
-    abc_snap.stream_sizes[1].height = DEFAULT_PREVIEW_HEIGHT;
-    abc_snap.type[1] = CAM_STREAM_TYPE_POSTVIEW;
-
-    abc_snap.postprocess_mask[0] = 0;
-    abc_snap.stream_sizes[0].width = DEFAULT_SNAPSHOT_WIDTH;
-    abc_snap.stream_sizes[0].height = DEFAULT_SNAPSHOT_HEIGHT;
-    abc_snap.type[0] = CAM_STREAM_TYPE_SNAPSHOT;
-
-    abc_snap.buffer_info.min_buffers = 7;
-    abc_snap.buffer_info.max_buffers = 7;
-    abc_snap.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc_snap);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command snapshot failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_SNAPSHOT;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_SNAPSHOT_FORMAT;
-    if ( test_obj->buffer_width == 0 || test_obj->buffer_height == 0 ) {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    } else {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    }
-    stream->s_config.padding_info = cam_cap->padding_info;
-    /* Make offset as zero as CPP will not be used  */
-    stream->s_config.padding_info.offset_info.offset_x = 0;
-    stream->s_config.padding_info.offset_info.offset_y = 0;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_channel_t * mm_app_add_preview_channel(mm_camera_test_obj_t *test_obj)
-{
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_PREVIEW,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    if (NULL == channel) {
-        LOGE("add channel failed");
-        return NULL;
-    }
-
-    stream = mm_app_add_preview_stream(test_obj,
-                                       channel,
-                                       mm_app_preview_notify_cb,
-                                       (void *)test_obj,
-                                       PREVIEW_BUF_NUM);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return NULL;
-    }
-
-    return channel;
-}
-
-int mm_app_stop_and_del_channel(mm_camera_test_obj_t *test_obj,
-                                mm_camera_channel_t *channel)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    uint8_t i;
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-    rc = mm_app_stop_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n",  rc);
-    }
-
-    if (channel->num_streams <= MAX_STREAM_NUM_IN_BUNDLE) {
-        for (i = 0; i < channel->num_streams; i++) {
-            stream = &channel->streams[i];
-            rc = mm_app_del_stream(test_obj, channel, stream);
-            if (MM_CAMERA_OK != rc) {
-                LOGE("del stream(%d) failed rc=%d\n",  i, rc);
-            }
-        }
-    } else {
-        LOGE("num_streams = %d. Should not be more than %d\n",
-             channel->num_streams, MAX_STREAM_NUM_IN_BUNDLE);
-    }
-
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command failed\n");
-    }
-
-    rc = mm_app_del_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("delete channel failed rc=%d\n",  rc);
-    }
-
-    return rc;
-}
-
-int mm_app_start_preview(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-    mm_camera_stream_t *s_metadata = NULL;
-    mm_camera_stream_t *s_analysis = NULL;
-    uint8_t i;
-
-    channel =  mm_app_add_preview_channel(test_obj);
-    if (NULL == channel) {
-        LOGE("add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    s_metadata = mm_app_add_metadata_stream(test_obj,
-                                            channel,
-                                            mm_app_metadata_notify_cb,
-                                            (void *)test_obj,
-                                            PREVIEW_BUF_NUM);
-    if (NULL == s_metadata) {
-        LOGE("add metadata stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    s_analysis = mm_app_add_analysis_stream(test_obj,
-                                            channel,
-                                            NULL,
-                                            (void *)test_obj,
-                                            PREVIEW_BUF_NUM);
-    if (NULL == s_analysis) {
-        LOGE("Analysis Stream could not be added\n");
-    }
-
-    rc = mm_app_start_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start preview failed rc=%d\n",  rc);
-        if (channel->num_streams <= MAX_STREAM_NUM_IN_BUNDLE) {
-            for (i = 0; i < channel->num_streams; i++) {
-                stream = &channel->streams[i];
-                mm_app_del_stream(test_obj, channel, stream);
-            }
-        }
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_preview(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel =
-        mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_PREVIEW);
-
-    rc = mm_app_stop_and_del_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n",  rc);
-    }
-
-    return rc;
-}
-
-int mm_app_start_preview_zsl(mm_camera_test_obj_t *test_obj)
-{
-    int32_t rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *s_preview = NULL;
-    mm_camera_stream_t *s_metadata = NULL;
-    mm_camera_stream_t *s_main = NULL;
-    mm_camera_channel_attr_t attr;
-    memset(&attr, 0, sizeof(mm_camera_channel_attr_t));
-    attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_CONTINUOUS;
-    attr.look_back = 2;
-    attr.post_frame_skip = 0;
-    attr.water_mark = 2;
-    attr.max_unmatched_frames = 3;
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_ZSL,
-                                 &attr,
-                                 mm_app_zsl_notify_cb,
-                                 test_obj);
-    if (NULL == channel) {
-        LOGE("add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-
-    s_main = mm_app_add_ZSL_snapshot_stream(test_obj,
-                                        channel,
-                                        mm_app_snapshot_notify_cb,
-                                        (void *)test_obj,
-                                        PREVIEW_BUF_NUM,
-                                        0);
-    if (NULL == s_main) {
-        LOGE("add main snapshot stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-    s_preview = mm_app_add_ZSL_preview_stream(test_obj,
-                                          channel,
-                                          mm_app_preview_notify_cb,
-                                          (void *)test_obj,
-                                          PREVIEW_BUF_NUM);
-    if (NULL == s_preview) {
-        LOGE("add preview stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-
-    s_metadata = mm_app_add_metadata_stream(test_obj,
-                                            channel,
-                                            mm_app_metadata_notify_cb,
-                                            (void *)test_obj,
-                                            PREVIEW_BUF_NUM);
-    if (NULL == s_metadata) {
-        LOGE("add metadata stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    rc = mm_app_start_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start zsl failed rc=%d\n",  rc);
-        mm_app_del_stream(test_obj, channel, s_preview);
-        mm_app_del_stream(test_obj, channel, s_metadata);
-        mm_app_del_stream(test_obj, channel, s_main);
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    if ( test_obj->enable_reproc ) {
-        if ( NULL == mm_app_add_reprocess_channel(test_obj, s_main) ) {
-            LOGE("Reprocess channel failed to initialize \n");
-            mm_app_del_stream(test_obj, channel, s_preview);
-#ifdef USE_METADATA_STREAM
-            mm_app_del_stream(test_obj, channel, s_metadata);
-#endif
-            mm_app_del_stream(test_obj, channel, s_main);
-            mm_app_del_channel(test_obj, channel);
-            return rc;
-        }
-        rc = mm_app_start_reprocess(test_obj);
-        if (MM_CAMERA_OK != rc) {
-            LOGE("reprocess start failed rc=%d\n",  rc);
-            mm_app_del_stream(test_obj, channel, s_preview);
-#ifdef USE_METADATA_STREAM
-            mm_app_del_stream(test_obj, channel, s_metadata);
-#endif
-            mm_app_del_stream(test_obj, channel, s_main);
-            mm_app_del_channel(test_obj, channel);
-            return rc;
-        }
-    }
-
-    return rc;
-}
-
-int mm_app_stop_preview_zsl(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-
-    mm_camera_channel_t *channel =
-        mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_ZSL);
-
-    rc = mm_app_stop_and_del_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n",  rc);
-    }
-
-    if ( test_obj->enable_reproc ) {
-        rc |= mm_app_stop_reprocess(test_obj);
-    }
-
-    return rc;
-}
-
-int mm_app_initialize_fb(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    int brightness_fd;
-    const char brightness_level[] = BACKLIGHT_LEVEL;
-    void *fb_base = NULL;
-
-    assert( ( NULL != test_obj ) && ( 0 == test_obj->fb_fd ) );
-
-    test_obj->fb_fd = open(FB_PATH, O_RDWR);
-    if ( 0 > test_obj->fb_fd ) {
-        LOGE("FB device open failed rc=%d, %s\n",
-                   -errno,
-                   strerror(errno));
-        rc = -errno;
-        goto FAIL;
-    }
-
-    rc = ioctl(test_obj->fb_fd, FBIOGET_VSCREENINFO, &test_obj->vinfo);
-    if ( MM_CAMERA_OK != rc ) {
-        LOGE("Can not retrieve screen info rc=%d, %s\n",
-                   -errno,
-                   strerror(errno));
-        rc = -errno;
-        goto FAIL;
-    }
-
-    if ( ( 0 == test_obj->vinfo.yres_virtual ) ||
-         ( 0 == test_obj->vinfo.yres ) ||
-         ( test_obj->vinfo.yres > test_obj->vinfo.yres_virtual ) ) {
-        LOGE("Invalid FB virtual yres: %d, yres: %d\n",
-                   test_obj->vinfo.yres_virtual,
-                   test_obj->vinfo.yres);
-        rc = MM_CAMERA_E_GENERAL;
-        goto FAIL;
-    }
-
-    if ( ( 0 == test_obj->vinfo.xres_virtual ) ||
-         ( 0 == test_obj->vinfo.xres ) ||
-         ( test_obj->vinfo.xres > test_obj->vinfo.xres_virtual ) ) {
-        LOGE("Invalid FB virtual xres: %d, xres: %d\n",
-                   test_obj->vinfo.xres_virtual,
-                   test_obj->vinfo.xres);
-        rc = MM_CAMERA_E_GENERAL;
-        goto FAIL;
-    }
-
-    brightness_fd = open(BACKLIGHT_CONTROL, O_RDWR);
-    if ( brightness_fd >= 0 ) {
-        write(brightness_fd, brightness_level, strlen(brightness_level));
-        close(brightness_fd);
-    }
-
-    test_obj->slice_size = test_obj->vinfo.xres * ( test_obj->vinfo.yres - 1 ) * DEFAULT_OV_FORMAT_BPP;
-    memset(&test_obj->data_overlay, 0, sizeof(struct mdp_overlay));
-    test_obj->data_overlay.src.width  = test_obj->buffer_width;
-    test_obj->data_overlay.src.height = test_obj->buffer_height;
-    test_obj->data_overlay.src_rect.w = test_obj->buffer_width;
-    test_obj->data_overlay.src_rect.h = test_obj->buffer_height;
-    test_obj->data_overlay.dst_rect.w = test_obj->buffer_width;
-    test_obj->data_overlay.dst_rect.h = test_obj->buffer_height;
-    test_obj->data_overlay.src.format = DEFAULT_OV_FORMAT;
-    test_obj->data_overlay.src_rect.x = 0;
-    test_obj->data_overlay.src_rect.y = 0;
-    test_obj->data_overlay.dst_rect.x = 0;
-    test_obj->data_overlay.dst_rect.y = 0;
-    test_obj->data_overlay.z_order = 2;
-    test_obj->data_overlay.alpha = 0x80;
-    test_obj->data_overlay.transp_mask = 0xffe0;
-    test_obj->data_overlay.flags = MDP_FLIP_LR | MDP_FLIP_UD;
-
-    // Map and clear FB portion
-    fb_base = mmap(0,
-                   test_obj->slice_size,
-                   PROT_WRITE,
-                   MAP_SHARED,
-                   test_obj->fb_fd,
-                   0);
-    if ( MAP_FAILED  == fb_base ) {
-            LOGE("( Error while memory mapping frame buffer %s",
-                       strerror(errno));
-            rc = -errno;
-            goto FAIL;
-    }
-
-    memset(fb_base, 0, test_obj->slice_size);
-
-    if (ioctl(test_obj->fb_fd, FBIOPAN_DISPLAY, &test_obj->vinfo) < 0) {
-        LOGE("FBIOPAN_DISPLAY failed!");
-        rc = -errno;
-        goto FAIL;
-    }
-
-    munmap(fb_base, test_obj->slice_size);
-    test_obj->data_overlay.id = (uint32_t)MSMFB_NEW_REQUEST;
-    rc = ioctl(test_obj->fb_fd, MSMFB_OVERLAY_SET, &test_obj->data_overlay);
-    if (rc < 0) {
-        LOGE("MSMFB_OVERLAY_SET failed! err=%d\n",
-               test_obj->data_overlay.id);
-        return MM_CAMERA_E_GENERAL;
-    }
-    LOGE("Overlay set with overlay id: %d",  test_obj->data_overlay.id);
-
-    return rc;
-
-FAIL:
-
-    if ( 0 < test_obj->fb_fd ) {
-        close(test_obj->fb_fd);
-    }
-
-    return rc;
-}
-
-int mm_app_close_fb(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-
-    assert( ( NULL != test_obj ) && ( 0 < test_obj->fb_fd ) );
-
-    if (ioctl(test_obj->fb_fd, MSMFB_OVERLAY_UNSET, &test_obj->data_overlay.id)) {
-        LOGE("\nERROR! MSMFB_OVERLAY_UNSET failed! (Line %d)\n");
-    }
-
-    if (ioctl(test_obj->fb_fd, FBIOPAN_DISPLAY, &test_obj->vinfo) < 0) {
-        LOGE("ERROR: FBIOPAN_DISPLAY failed! line=%d\n");
-    }
-
-    close(test_obj->fb_fd);
-    test_obj->fb_fd = -1;
-
-    return rc;
-}
-
-void memset16(void *pDst, uint16_t value, int count)
-{
-    uint16_t *ptr = pDst;
-    while (count--)
-        *ptr++ = value;
-}
-
-int mm_app_overlay_display(mm_camera_test_obj_t *test_obj, int bufferFd)
-{
-    int rc = MM_CAMERA_OK;
-    struct msmfb_overlay_data ovdata;
-
-
-    memset(&ovdata, 0, sizeof(struct msmfb_overlay_data));
-    ovdata.id = test_obj->data_overlay.id;
-    ovdata.data.memory_id = bufferFd;
-
-    if (ioctl(test_obj->fb_fd, MSMFB_OVERLAY_PLAY, &ovdata)) {
-        LOGE("MSMFB_OVERLAY_PLAY failed!");
-        return MM_CAMERA_E_GENERAL;
-    }
-
-    if (ioctl(test_obj->fb_fd, FBIOPAN_DISPLAY, &test_obj->vinfo) < 0) {
-        LOGE("FBIOPAN_DISPLAY failed!");
-        return MM_CAMERA_E_GENERAL;
-    }
-
-    return rc;
-}
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_queue.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_queue.c
deleted file mode 100644
index 61176be..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_queue.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/* Copyright (c) 2012, 2016, The Linux Foundation. All rights reserved.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are
-* met:
-*     * Redistributions of source code must retain the above copyright
-*       notice, this list of conditions and the following disclaimer.
-*     * Redistributions in binary form must reproduce the above
-*       copyright notice, this list of conditions and the following
-*       disclaimer in the documentation and/or other materials provided
-*       with the distribution.
-*     * Neither the name of The Linux Foundation nor the names of its
-*       contributors may be used to endorse or promote products derived
-*       from this software without specific prior written permission.
-*
-* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-* IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*/
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-int mm_camera_queue_init(mm_camera_queue_t *queue,
-                         release_data_fn data_rel_fn,
-                         void *user_data)
-{
-    if ( NULL == queue ) {
-        return -1;
-    }
-
-    pthread_mutex_init(&queue->m_lock, NULL);
-    cam_list_init(&queue->m_head.list);
-    queue->m_size = 0;
-    queue->m_dataFn = data_rel_fn;
-    queue->m_userData = user_data;
-
-    return MM_CAMERA_OK;
-}
-
-int mm_qcamera_queue_release(mm_camera_queue_t *queue)
-{
-    if ( NULL == queue ) {
-        return -1;
-    }
-
-    mm_qcamera_queue_flush(queue);
-    pthread_mutex_destroy(&queue->m_lock);
-
-    return MM_CAMERA_OK;
-}
-
-int mm_qcamera_queue_isempty(mm_camera_queue_t *queue)
-{
-    if ( NULL == queue ) {
-        return 0;
-    }
-
-    int flag = 1;
-    pthread_mutex_lock(&queue->m_lock);
-    if (queue->m_size > 0) {
-        flag = 0;
-    }
-    pthread_mutex_unlock(&queue->m_lock);
-
-    return flag;
-}
-
-int mm_qcamera_queue_enqueue(mm_camera_queue_t *queue, void *data)
-{
-    if ( NULL == queue ) {
-        return -1;
-    }
-
-    camera_q_node *node =
-        (camera_q_node *)malloc(sizeof(camera_q_node));
-    if (NULL == node) {
-        LOGE(" No memory for camera_q_node");
-        return 0;
-    }
-
-    memset(node, 0, sizeof(camera_q_node));
-    node->data = data;
-
-    pthread_mutex_lock(&queue->m_lock);
-    cam_list_add_tail_node(&node->list, &queue->m_head.list);
-    queue->m_size++;
-    pthread_mutex_unlock(&queue->m_lock);
-
-    return 1;
-}
-
-void* mm_qcamera_queue_dequeue(mm_camera_queue_t *queue, int bFromHead)
-{
-    if ( NULL == queue ) {
-        return NULL;
-    }
-
-    camera_q_node* node = NULL;
-    void* data = NULL;
-    struct cam_list *head = NULL;
-    struct cam_list *pos = NULL;
-
-    pthread_mutex_lock(&queue->m_lock);
-    head = &queue->m_head.list;
-    if (bFromHead) {
-        pos = head->next;
-    } else {
-        pos = head->prev;
-    }
-    if (pos != head) {
-        node = member_of(pos, camera_q_node, list);
-        cam_list_del_node(&node->list);
-        queue->m_size--;
-    }
-    pthread_mutex_unlock(&queue->m_lock);
-
-    if (NULL != node) {
-        data = node->data;
-        free(node);
-    }
-
-    return data;
-}
-
-void mm_qcamera_queue_flush(mm_camera_queue_t *queue)
-{
-    camera_q_node* node = NULL;
-    struct cam_list *head = NULL;
-    struct cam_list *pos = NULL;
-
-    if ( NULL == queue ) {
-        return;
-    }
-
-    pthread_mutex_lock(&queue->m_lock);
-    head = &queue->m_head.list;
-    pos = head->next;
-
-    while(pos != head) {
-        node = member_of(pos, camera_q_node, list);
-        pos = pos->next;
-        cam_list_del_node(&node->list);
-        queue->m_size--;
-
-        if (NULL != node->data) {
-            if (queue->m_dataFn) {
-                queue->m_dataFn(node->data, queue->m_userData);
-            }
-            free(node->data);
-        }
-        free(node);
-
-    }
-    queue->m_size = 0;
-    pthread_mutex_unlock(&queue->m_lock);
-}
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_rdi.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_rdi.c
deleted file mode 100644
index 4c07f6a..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_rdi.c
+++ /dev/null
@@ -1,346 +0,0 @@
-/*
-Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// System dependencies
-#include <fcntl.h>
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-static uint32_t rdi_len = 0;
-
-static void mm_app_rdi_dump_frame(mm_camera_buf_def_t *frame,
-                                  char *name,
-                                  char *ext,
-                                  uint32_t frame_idx)
-{
-    char file_name[FILENAME_MAX];
-    int file_fd;
-    int i;
-
-    if (frame != NULL) {
-        snprintf(file_name, sizeof(file_name),
-            QCAMERA_DUMP_FRM_LOCATION"%s_%03u.%s", name, frame_idx, ext);
-        file_fd = open(file_name, O_RDWR | O_CREAT, 0777);
-        if (file_fd < 0) {
-            LOGE(" cannot open file %s \n",  file_name);
-        } else {
-            for (i = 0; i < frame->planes_buf.num_planes; i++) {
-                write(file_fd,
-                      (uint8_t *)frame->buffer + frame->planes_buf.planes[i].data_offset,
-                      rdi_len);
-            }
-
-            close(file_fd);
-            LOGD(" dump rdi frame %s", file_name);
-        }
-    }
-}
-
-static void mm_app_rdi_notify_cb(mm_camera_super_buf_t *bufs,
-                                 void *user_data)
-{
-    char file_name[FILENAME_MAX];
-    mm_camera_buf_def_t *frame = bufs->bufs[0];
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-
-    LOGD(" BEGIN - length=%zu, frame idx = %d stream_id=%d\n",
-          frame->frame_len, frame->frame_idx, frame->stream_id);
-    snprintf(file_name, sizeof(file_name), "RDI_dump_%d", pme->cam->camera_handle);
-    mm_app_rdi_dump_frame(frame, file_name, "raw", frame->frame_idx);
-
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                            bufs->ch_id,
-                                            frame)) {
-        LOGE(" Failed in RDI Qbuf\n");
-    }
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                     ION_IOC_INV_CACHES);
-
-    LOGD(" END\n");
-}
-
-mm_camera_stream_t * mm_app_add_rdi_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs,
-                                               uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    size_t i;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_format_t fmt = CAM_FORMAT_MAX;
-    cam_stream_buf_plane_info_t *buf_planes;
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-
-
-    LOGE(" raw_dim w:%d height:%d\n",  cam_cap->raw_dim[0].width, cam_cap->raw_dim[0].height);
-    for (i = 0;i < cam_cap->supported_raw_fmt_cnt;i++) {
-        LOGE(" supported_raw_fmts[%zd]=%d\n",
-            i, (int)cam_cap->supported_raw_fmts[i]);
-        if (((CAM_FORMAT_BAYER_MIPI_RAW_8BPP_GBRG <= cam_cap->supported_raw_fmts[i]) &&
-            (CAM_FORMAT_BAYER_MIPI_RAW_12BPP_BGGR >= cam_cap->supported_raw_fmts[i])) ||
-            (cam_cap->supported_raw_fmts[i] == CAM_FORMAT_META_RAW_8BIT) ||
-            (cam_cap->supported_raw_fmts[i] == CAM_FORMAT_JPEG_RAW_8BIT) ||
-            (cam_cap->supported_raw_fmts[i] == CAM_FORMAT_BAYER_MIPI_RAW_14BPP_BGGR))
-        {
-            fmt = cam_cap->supported_raw_fmts[i];
-            LOGE(" fmt=%d\n",  fmt);
-        }
-    }
-
-    if (CAM_FORMAT_MAX == fmt) {
-        LOGE(" rdi format not supported\n");
-        return NULL;
-    }
-
-    abc.num_streams = 1;
-    abc.postprocess_mask[0] = 0;
-    abc.stream_sizes[0].width = cam_cap->raw_dim[0].width;
-    abc.stream_sizes[0].height = cam_cap->raw_dim[0].height;
-    abc.type[0] = CAM_STREAM_TYPE_RAW;
-    abc.buffer_info.min_buffers = num_bufs;
-    abc.buffer_info.max_buffers = num_bufs;
-    abc.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE(" meta info command failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE(" add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_RAW;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_RAW_FORMAT;
-    LOGD(" RAW: w: %d, h: %d ",
-       cam_cap->raw_dim[0].width, cam_cap->raw_dim[0].height);
-
-    stream->s_config.stream_info->dim.width = cam_cap->raw_dim[0].width;
-    stream->s_config.stream_info->dim.height = cam_cap->raw_dim[0].height;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config rdi stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    buf_planes = &stream->s_config.stream_info->buf_planes;
-    rdi_len = buf_planes->plane_info.mp[0].len;
-    LOGD(" plane_info %dx%d len:%d frame_len:%d\n",
-        buf_planes->plane_info.mp[0].stride, buf_planes->plane_info.mp[0].scanline,
-        buf_planes->plane_info.mp[0].len, buf_planes->plane_info.frame_len);
-
-    return stream;
-}
-
-mm_camera_stream_t * mm_app_add_rdi_snapshot_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE(" add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_SNAPSHOT;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_SNAPSHOT_FORMAT;
-    stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-    stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config rdi stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_channel_t * mm_app_add_rdi_channel(mm_camera_test_obj_t *test_obj, uint8_t num_burst)
-{
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_RDI,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return NULL;
-    }
-
-    stream = mm_app_add_rdi_stream(test_obj,
-                                       channel,
-                                       mm_app_rdi_notify_cb,
-                                       (void *)test_obj,
-                                       RDI_BUF_NUM,
-                                       num_burst);
-    if (NULL == stream) {
-        LOGE(" add stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return NULL;
-    }
-
-    LOGD(" channel=%d stream=%d\n",  channel->ch_id, stream->s_id);
-    return channel;
-}
-
-int mm_app_stop_and_del_rdi_channel(mm_camera_test_obj_t *test_obj,
-                                mm_camera_channel_t *channel)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    uint8_t i;
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-    rc = mm_app_stop_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop RDI failed rc=%d\n",  rc);
-    }
-
-    if (channel->num_streams <= MAX_STREAM_NUM_IN_BUNDLE) {
-        for (i = 0; i < channel->num_streams; i++) {
-            stream = &channel->streams[i];
-            rc = mm_app_del_stream(test_obj, channel, stream);
-            if (MM_CAMERA_OK != rc) {
-                LOGE("del stream(%d) failed rc=%d\n",  i, rc);
-            }
-        }
-    } else {
-        LOGE(" num_streams = %d. Should not be more than %d\n",
-             channel->num_streams, MAX_STREAM_NUM_IN_BUNDLE);
-    }
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE(" meta info command failed\n");
-    }
-    rc = mm_app_del_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("delete channel failed rc=%d\n",  rc);
-    }
-
-    return rc;
-}
-
-int mm_app_start_rdi(mm_camera_test_obj_t *test_obj, uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel = NULL;
-
-    channel = mm_app_add_rdi_channel(test_obj, num_burst);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    rc = mm_app_start_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start rdi failed rc=%d\n",  rc);
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_rdi(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-
-    mm_camera_channel_t *channel =
-        mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_RDI);
-
-    rc = mm_app_stop_and_del_rdi_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop RDI failed rc=%d\n",  rc);
-    }
-
-    return rc;
-}
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_reprocess.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_reprocess.c
deleted file mode 100644
index 4ed4c5d..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_reprocess.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
-Copyright (c) 2012-2014, 2016, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-static void mm_app_reprocess_notify_cb(mm_camera_super_buf_t *bufs,
-                                   void *user_data)
-{
-    mm_camera_buf_def_t *frame = bufs->bufs[0];
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-    mm_camera_super_buf_t *src_frame;
-    int i = 0;
-    int rc = 0;
-
-    LOGE(" BEGIN - length=%zu, frame idx = %d\n",
-          frame->frame_len, frame->frame_idx);
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE(" Wrong channel id (%d)",  bufs->ch_id);
-        return;
-    }
-
-    // We have only one stream and buffer
-    // in the reprocess channel.
-    m_stream = &channel->streams[0];
-    m_frame = bufs->bufs[0];
-
-    if ( pme->encodeJpeg ) {
-        pme->jpeg_buf.buf.buffer = (uint8_t *)malloc(m_frame->frame_len);
-        if ( NULL == pme->jpeg_buf.buf.buffer ) {
-            LOGE(" error allocating jpeg output buffer");
-            goto exit;
-        }
-
-        pme->jpeg_buf.buf.frame_len = m_frame->frame_len;
-        /* create a new jpeg encoding session */
-        rc = createEncodingSession(pme, m_stream, m_frame);
-        if (0 != rc) {
-            LOGE(" error creating jpeg session");
-            free(pme->jpeg_buf.buf.buffer);
-            goto exit;
-        }
-
-        /* start jpeg encoding job */
-        LOGE("Encoding reprocessed frame!!");
-        rc = encodeData(pme, bufs, m_stream);
-        pme->encodeJpeg = 0;
-    } else {
-        if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                bufs->ch_id,
-                                                frame)) {
-            LOGE(" Failed in Reprocess Qbuf\n");
-        }
-        mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                         ION_IOC_INV_CACHES);
-    }
-
-exit:
-
-// Release source frame
-    src_frame = ( mm_camera_super_buf_t * ) mm_qcamera_queue_dequeue(&pme->pp_frames, 1);
-    if ( NULL != src_frame ) {
-        mm_app_release_ppinput((void *) src_frame, (void *) pme);
-    }
-
-    LOGE(" END\n");
-}
-
-mm_camera_stream_t * mm_app_add_reprocess_stream_from_source(mm_camera_test_obj_t *test_obj,
-                                                             mm_camera_channel_t *channel,
-                                                             mm_camera_stream_t *source,
-                                                             mm_camera_buf_notify_t stream_cb,
-                                                             cam_pp_feature_config_t pp_config,
-                                                             void *userdata,
-                                                             uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = NULL;
-    cam_stream_info_t *source_stream_info;
-
-    if ( ( NULL == test_obj ) ||
-         ( NULL == channel ) ||
-         ( NULL == source ) ) {
-        LOGE(" Invalid input\n");
-        return NULL;
-    }
-
-    cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE(" add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    source_stream_info = (cam_stream_info_t *) source->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_OFFLINE_PROC;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = source_stream_info->fmt;
-    stream->s_config.stream_info->dim = source_stream_info->dim;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-
-    stream->s_config.stream_info->reprocess_config.pp_type = CAM_ONLINE_REPROCESS_TYPE;
-    stream->s_config.stream_info->reprocess_config.online.input_stream_id = source->s_config.stream_info->stream_svr_id;
-    stream->s_config.stream_info->reprocess_config.online.input_stream_type = source->s_config.stream_info->stream_type;
-    stream->s_config.stream_info->reprocess_config.pp_feature_config = pp_config;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_channel_t * mm_app_add_reprocess_channel(mm_camera_test_obj_t *test_obj,
-                                                   mm_camera_stream_t *source_stream)
-{
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-
-    if ( NULL == source_stream ) {
-        LOGE(" add reprocess stream failed\n");
-        return NULL;
-    }
-
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_REPROCESS,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return NULL;
-    }
-
-    // pp feature config
-    cam_pp_feature_config_t pp_config;
-    memset(&pp_config, 0, sizeof(cam_pp_feature_config_t));
-
-    cam_capability_t *caps = ( cam_capability_t * ) ( test_obj->cap_buf.buf.buffer );
-    if (caps->qcom_supported_feature_mask & CAM_QCOM_FEATURE_SHARPNESS) {
-        pp_config.feature_mask |= CAM_QCOM_FEATURE_SHARPNESS;
-        pp_config.sharpness = test_obj->reproc_sharpness;
-    }
-
-    if (test_obj->reproc_wnr.denoise_enable) {
-        pp_config.feature_mask |= CAM_QCOM_FEATURE_DENOISE2D;
-        pp_config.denoise2d = test_obj->reproc_wnr;
-    }
-
-    if (test_obj->enable_CAC) {
-        pp_config.feature_mask |= CAM_QCOM_FEATURE_CAC;
-    }
-
-    uint8_t minStreamBufNum = source_stream->num_of_bufs;
-    stream = mm_app_add_reprocess_stream_from_source(test_obj,
-                                     channel,
-                                     source_stream,
-                                     mm_app_reprocess_notify_cb,
-                                     pp_config,
-                                     (void *)test_obj,
-                                     minStreamBufNum);
-    if (NULL == stream) {
-        LOGE(" add reprocess stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return NULL;
-    }
-    test_obj->reproc_stream = stream;
-
-    return channel;
-}
-
-int mm_app_start_reprocess(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *r_ch = NULL;
-
-    mm_camera_queue_init(&test_obj->pp_frames,
-                         mm_app_release_ppinput,
-                         ( void * ) test_obj);
-
-    r_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_REPROCESS);
-    if (MM_CAMERA_OK != rc) {
-        LOGE(" No initialized reprocess channel d rc=%d\n", rc);
-        return rc;
-    }
-
-    rc = mm_app_start_channel(test_obj, r_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start reprocess failed rc=%d\n",  rc);
-        mm_app_del_channel(test_obj, r_ch);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_reprocess(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *r_ch = NULL;
-
-    r_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_REPROCESS);
-    if (MM_CAMERA_OK != rc) {
-        LOGE(" No initialized reprocess channel d rc=%d\n", rc);
-        return rc;
-    }
-
-    rc = mm_app_stop_and_del_channel(test_obj, r_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n",  rc);
-    }
-
-    mm_qcamera_queue_release(&test_obj->pp_frames);
-    test_obj->reproc_stream = NULL;
-
-    return rc;
-}
-
-int mm_app_do_reprocess(mm_camera_test_obj_t *test_obj,
-                        mm_camera_buf_def_t *frame,
-                        uint32_t meta_idx,
-                        mm_camera_super_buf_t *super_buf,
-                        mm_camera_stream_t *src_meta)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *r_ch = NULL;
-    mm_camera_super_buf_t *src_buf = NULL;
-
-    if ( ( NULL == test_obj ) ||
-         ( NULL == frame ) ||
-         ( NULL == super_buf )) {
-        LOGE(" Invalid input rc=%d\n", rc);
-        return rc;
-    }
-
-    if ( NULL == test_obj->reproc_stream ) {
-        LOGE(" No reprocess stream rc=%d\n", rc);
-        return rc;
-    }
-
-    r_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_REPROCESS);
-    if (MM_CAMERA_OK != rc) {
-        LOGE(" No reprocess channel rc=%d\n", rc);
-        return rc;
-    }
-
-    src_buf = ( mm_camera_super_buf_t * ) malloc(sizeof(mm_camera_super_buf_t));
-    if ( NULL == src_buf ) {
-        LOGE(" No resources for src frame rc=%d\n", rc);
-        return -1;
-    }
-    memcpy(src_buf, super_buf, sizeof(mm_camera_super_buf_t));
-    mm_qcamera_queue_enqueue(&test_obj->pp_frames, src_buf);
-
-    cam_stream_parm_buffer_t param;
-    memset(&param, 0, sizeof(cam_stream_parm_buffer_t));
-    param.type = CAM_STREAM_PARAM_TYPE_DO_REPROCESS;
-    param.reprocess.buf_index = frame->buf_idx;
-    param.reprocess.frame_idx = frame->frame_idx;
-    if (src_meta != NULL) {
-        param.reprocess.meta_present = 1;
-        param.reprocess.meta_stream_handle = src_meta->s_config.stream_info->stream_svr_id;
-        param.reprocess.meta_buf_index = meta_idx;
-    } else {
-        LOGE(" No metadata source stream rc=%d\n", rc);
-    }
-
-    test_obj->reproc_stream->s_config.stream_info->parm_buf = param;
-    rc = test_obj->cam->ops->set_stream_parms(test_obj->cam->camera_handle,
-                                              r_ch->ch_id,
-                                              test_obj->reproc_stream->s_id,
-                                              &test_obj->reproc_stream->s_config.stream_info->parm_buf);
-
-    return rc;
-}
-
-void mm_app_release_ppinput(void *data, void *user_data)
-{
-    uint32_t i = 0;
-    mm_camera_super_buf_t *recvd_frame  = ( mm_camera_super_buf_t * ) data;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-
-    for ( i = 0 ; i < recvd_frame->num_bufs ; i++) {
-        if (MM_CAMERA_OK != pme->cam->ops->qbuf(pme->cam->camera_handle,
-                                                recvd_frame->ch_id,
-                                                recvd_frame->bufs[i])) {
-            LOGE(" Failed in Qbuf\n");
-        }
-        mm_app_cache_ops((mm_camera_app_meminfo_t *) recvd_frame->bufs[i]->mem_info,
-                         ION_IOC_INV_CACHES);
-    }
-}
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_snapshot.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_snapshot.c
deleted file mode 100644
index 69c09d0..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_snapshot.c
+++ /dev/null
@@ -1,707 +0,0 @@
-/* Copyright (c) 2012-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-/* This callback is received once the complete JPEG encoding is done */
-static void jpeg_encode_cb(jpeg_job_status_t status,
-                           uint32_t client_hdl,
-                           uint32_t jobId,
-                           mm_jpeg_output_t *p_buf,
-                           void *userData)
-{
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = NULL;
-    LOGD(" BEGIN\n");
-
-    pme = (mm_camera_test_obj_t *)userData;
-    if (pme->jpeg_hdl != client_hdl ||
-        jobId != pme->current_job_id ||
-        !pme->current_job_frames) {
-        LOGE(" NULL current job frames or not matching job ID (%d, %d)",
-                    jobId, pme->current_job_id);
-        return;
-    }
-
-    /* dump jpeg img */
-    LOGE(" job %d, status=%d",  jobId, status);
-    if (status == JPEG_JOB_STATUS_DONE && p_buf != NULL) {
-        mm_app_dump_jpeg_frame(p_buf->buf_vaddr, p_buf->buf_filled_len, "jpeg", "jpg", jobId);
-    }
-
-    /* buf done current encoding frames */
-    pme->current_job_id = 0;
-    for (i = 0; i < pme->current_job_frames->num_bufs; i++) {
-        if (MM_CAMERA_OK != pme->cam->ops->qbuf(pme->current_job_frames->camera_handle,
-                                                pme->current_job_frames->ch_id,
-                                                pme->current_job_frames->bufs[i])) {
-            LOGE(" Failed in Qbuf\n");
-        }
-        mm_app_cache_ops((mm_camera_app_meminfo_t *) pme->current_job_frames->bufs[i]->mem_info,
-                         ION_IOC_INV_CACHES);
-    }
-
-    free(pme->jpeg_buf.buf.buffer);
-    free(pme->current_job_frames);
-    pme->current_job_frames = NULL;
-
-    /* signal snapshot is done */
-    mm_camera_app_done();
-}
-
-int encodeData(mm_camera_test_obj_t *test_obj, mm_camera_super_buf_t* recvd_frame,
-               mm_camera_stream_t *m_stream)
-{
-
-    int rc = -MM_CAMERA_E_GENERAL;
-    mm_jpeg_job_t job;
-
-    /* remember current frames being encoded */
-    test_obj->current_job_frames =
-        (mm_camera_super_buf_t *)malloc(sizeof(mm_camera_super_buf_t));
-    if (!test_obj->current_job_frames) {
-        LOGE(" No memory for current_job_frames");
-        return rc;
-    }
-    *(test_obj->current_job_frames) = *recvd_frame;
-
-    memset(&job, 0, sizeof(job));
-    job.job_type = JPEG_JOB_TYPE_ENCODE;
-    job.encode_job.session_id = test_obj->current_jpeg_sess_id;
-
-    // TODO: Rotation should be set according to
-    //       sensor&device orientation
-    job.encode_job.rotation = 0;
-
-    /* fill in main src img encode param */
-    job.encode_job.main_dim.src_dim = m_stream->s_config.stream_info->dim;
-    job.encode_job.main_dim.dst_dim = m_stream->s_config.stream_info->dim;
-    job.encode_job.src_index = 0;
-
-    job.encode_job.thumb_dim.src_dim = m_stream->s_config.stream_info->dim;
-    job.encode_job.thumb_dim.dst_dim.width = DEFAULT_PREVIEW_WIDTH;
-    job.encode_job.thumb_dim.dst_dim.height = DEFAULT_PREVIEW_HEIGHT;
-
-    /* fill in sink img param */
-    job.encode_job.dst_index = 0;
-
-    if (test_obj->metadata != NULL) {
-        job.encode_job.p_metadata = test_obj->metadata;
-    } else {
-        LOGE(" Metadata null, not set for jpeg encoding");
-    }
-
-    rc = test_obj->jpeg_ops.start_job(&job, &test_obj->current_job_id);
-    if ( 0 != rc ) {
-        free(test_obj->current_job_frames);
-        test_obj->current_job_frames = NULL;
-    }
-
-    return rc;
-}
-
-int createEncodingSession(mm_camera_test_obj_t *test_obj,
-                          mm_camera_stream_t *m_stream,
-                          mm_camera_buf_def_t *m_frame)
-{
-    mm_jpeg_encode_params_t encode_param;
-
-    memset(&encode_param, 0, sizeof(mm_jpeg_encode_params_t));
-    encode_param.jpeg_cb = jpeg_encode_cb;
-    encode_param.userdata = (void*)test_obj;
-    encode_param.encode_thumbnail = 0;
-    encode_param.quality = 85;
-    encode_param.color_format = MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
-    encode_param.thumb_color_format = MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2;
-
-    /* fill in main src img encode param */
-    encode_param.num_src_bufs = 1;
-    encode_param.src_main_buf[0].index = 0;
-    encode_param.src_main_buf[0].buf_size = m_frame->frame_len;
-    encode_param.src_main_buf[0].buf_vaddr = (uint8_t *)m_frame->buffer;
-    encode_param.src_main_buf[0].fd = m_frame->fd;
-    encode_param.src_main_buf[0].format = MM_JPEG_FMT_YUV;
-    encode_param.src_main_buf[0].offset = m_stream->offset;
-
-    /* fill in sink img param */
-    encode_param.num_dst_bufs = 1;
-    encode_param.dest_buf[0].index = 0;
-    encode_param.dest_buf[0].buf_size = test_obj->jpeg_buf.buf.frame_len;
-    encode_param.dest_buf[0].buf_vaddr = (uint8_t *)test_obj->jpeg_buf.buf.buffer;
-    encode_param.dest_buf[0].fd = test_obj->jpeg_buf.buf.fd;
-    encode_param.dest_buf[0].format = MM_JPEG_FMT_YUV;
-
-    /* main dimension */
-    encode_param.main_dim.src_dim = m_stream->s_config.stream_info->dim;
-    encode_param.main_dim.dst_dim = m_stream->s_config.stream_info->dim;
-
-    return test_obj->jpeg_ops.create_session(test_obj->jpeg_hdl,
-                                             &encode_param,
-                                             &test_obj->current_jpeg_sess_id);
-}
-
-/** mm_app_snapshot_metadata_notify_cb
- *  @bufs: Pointer to super buffer
- *  @user_data: Pointer to user data
- *
- *
- **/
-__unused
-static void mm_app_snapshot_metadata_notify_cb(mm_camera_super_buf_t *bufs,
-  void *user_data)
-{
-  uint32_t i = 0;
-  mm_camera_channel_t *channel = NULL;
-  mm_camera_stream_t *p_stream = NULL;
-  mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-  mm_camera_buf_def_t *frame;
-  metadata_buffer_t *pMetadata;
-
-  if (NULL == bufs || NULL == user_data) {
-    LOGE(" bufs or user_data are not valid ");
-    return;
-  }
-  frame = bufs->bufs[0];
-
-  /* find channel */
-  for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-    if (pme->channels[i].ch_id == bufs->ch_id) {
-      channel = &pme->channels[i];
-      break;
-    }
-  }
-
-  if (NULL == channel) {
-    LOGE(" Channel object is null");
-    return;
-  }
-
-  /* find meta stream */
-  for (i = 0; i < channel->num_streams; i++) {
-    if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_METADATA) {
-      p_stream = &channel->streams[i];
-      break;
-    }
-  }
-
-  if (NULL == p_stream) {
-    LOGE(" cannot find metadata stream");
-    return;
-  }
-
-  /* find meta frame */
-  for (i = 0; i < bufs->num_bufs; i++) {
-    if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-      frame = bufs->bufs[i];
-      break;
-    }
-  }
-
-  if (!pme->metadata) {
-    /* The app will free the metadata, we don't need to bother here */
-    pme->metadata = malloc(sizeof(metadata_buffer_t));
-    if (NULL == pme->metadata) {
-        LOGE(" malloc failed");
-        return;
-    }
-  }
-
-  memcpy(pme->metadata , frame->buffer, sizeof(metadata_buffer_t));
-
-  pMetadata = (metadata_buffer_t *)frame->buffer;
-
-  IF_META_AVAILABLE(cam_auto_focus_data_t, focus_data,
-        CAM_INTF_META_AUTOFOCUS_DATA, pMetadata) {
-    if (focus_data->focus_state == CAM_AF_STATE_FOCUSED_LOCKED) {
-      LOGE(" AutoFocus Done Call Back Received\n");
-      mm_camera_app_done();
-    } else if (focus_data->focus_state == CAM_AF_STATE_NOT_FOCUSED_LOCKED) {
-      LOGE(" AutoFocus failed\n");
-      mm_camera_app_done();
-    }
-  }
-
-  if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                          bufs->ch_id,
-                                          frame)) {
-    LOGE(" Failed in Preview Qbuf\n");
-  }
-  mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                   ION_IOC_INV_CACHES);
-}
-
-static void mm_app_snapshot_notify_cb_raw(mm_camera_super_buf_t *bufs,
-                                          void *user_data)
-{
-
-    int rc;
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-
-    LOGD(" BEGIN\n");
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE(" Wrong channel id (%d)",  bufs->ch_id);
-        rc = -1;
-        goto EXIT;
-    }
-
-    /* find snapshot stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_RAW) {
-            m_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == m_stream) {
-        LOGE(" cannot find snapshot stream");
-        rc = -1;
-        goto EXIT;
-    }
-
-    /* find snapshot frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == m_stream->s_id) {
-            m_frame = bufs->bufs[i];
-            break;
-        }
-    }
-    if (NULL == m_frame) {
-        LOGE(" main frame is NULL");
-        rc = -1;
-        goto EXIT;
-    }
-
-    mm_app_dump_frame(m_frame, "main", "raw", m_frame->frame_idx);
-
-EXIT:
-    for (i=0; i<bufs->num_bufs; i++) {
-        if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                bufs->ch_id,
-                                                bufs->bufs[i])) {
-            LOGE(" Failed in Qbuf\n");
-        }
-    }
-
-    mm_camera_app_done();
-
-    LOGD(" END\n");
-}
-
-static void mm_app_snapshot_notify_cb(mm_camera_super_buf_t *bufs,
-                                      void *user_data)
-{
-
-    int rc = 0;
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_buf_def_t *p_frame = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE(" Wrong channel id (%d)",  bufs->ch_id);
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_SNAPSHOT) {
-            m_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == m_stream) {
-        LOGE(" cannot find snapshot stream");
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == m_stream->s_id) {
-            m_frame = bufs->bufs[i];
-            break;
-        }
-    }
-    if (NULL == m_frame) {
-        LOGE(" main frame is NULL");
-        rc = -1;
-        goto error;
-    }
-
-    mm_app_dump_frame(m_frame, "main", "yuv", m_frame->frame_idx);
-
-    /* find postview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_POSTVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL != p_stream) {
-        /* find preview frame */
-        for (i = 0; i < bufs->num_bufs; i++) {
-            if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-                p_frame = bufs->bufs[i];
-                break;
-            }
-        }
-        if (NULL != p_frame) {
-            mm_app_dump_frame(p_frame, "postview", "yuv", p_frame->frame_idx);
-        }
-    }
-
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)m_frame->mem_info,
-                     ION_IOC_CLEAN_INV_CACHES);
-
-    pme->jpeg_buf.buf.buffer = (uint8_t *)malloc(m_frame->frame_len);
-    if ( NULL == pme->jpeg_buf.buf.buffer ) {
-        LOGE(" error allocating jpeg output buffer");
-        goto error;
-    }
-
-    pme->jpeg_buf.buf.frame_len = m_frame->frame_len;
-    /* create a new jpeg encoding session */
-    rc = createEncodingSession(pme, m_stream, m_frame);
-    if (0 != rc) {
-        LOGE(" error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-    /* start jpeg encoding job */
-    rc = encodeData(pme, bufs, m_stream);
-    if (0 != rc) {
-        LOGE(" error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-error:
-    /* buf done rcvd frames in error case */
-    if ( 0 != rc ) {
-        for (i=0; i<bufs->num_bufs; i++) {
-            if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                    bufs->ch_id,
-                                                    bufs->bufs[i])) {
-                LOGE(" Failed in Qbuf\n");
-            }
-            mm_app_cache_ops((mm_camera_app_meminfo_t *)bufs->bufs[i]->mem_info,
-                             ION_IOC_INV_CACHES);
-        }
-    }
-
-    LOGD(" END\n");
-}
-
-mm_camera_channel_t * mm_app_add_snapshot_channel(mm_camera_test_obj_t *test_obj)
-{
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_SNAPSHOT,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return NULL;
-    }
-
-    stream = mm_app_add_snapshot_stream(test_obj,
-                                        channel,
-                                        mm_app_snapshot_notify_cb,
-                                        (void *)test_obj,
-                                        1,
-                                        1);
-    if (NULL == stream) {
-        LOGE(" add snapshot stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return NULL;
-    }
-
-    return channel;
-}
-
-mm_camera_stream_t * mm_app_add_postview_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE(" add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_POSTVIEW;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-    stream->s_config.stream_info->dim.width = DEFAULT_PREVIEW_WIDTH;
-    stream->s_config.stream_info->dim.height = DEFAULT_PREVIEW_HEIGHT;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config postview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-int mm_app_start_capture_raw(mm_camera_test_obj_t *test_obj, uint8_t num_snapshots)
-{
-    int32_t rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *s_main = NULL;
-    mm_camera_channel_attr_t attr;
-
-    memset(&attr, 0, sizeof(mm_camera_channel_attr_t));
-    attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_BURST;
-    attr.max_unmatched_frames = 3;
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_CAPTURE,
-                                 &attr,
-                                 mm_app_snapshot_notify_cb_raw,
-                                 test_obj);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    test_obj->buffer_format = DEFAULT_RAW_FORMAT;
-    s_main = mm_app_add_raw_stream(test_obj,
-                                   channel,
-                                   mm_app_snapshot_notify_cb_raw,
-                                   test_obj,
-                                   num_snapshots,
-                                   num_snapshots);
-    if (NULL == s_main) {
-        LOGE(" add main snapshot stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    rc = mm_app_start_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start zsl failed rc=%d\n",  rc);
-        mm_app_del_stream(test_obj, channel, s_main);
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_capture_raw(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *ch = NULL;
-    int i;
-    cam_stream_size_info_t abc ;
-    memset (&abc , 0, sizeof (cam_stream_size_info_t));
-
-    ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_CAPTURE);
-
-    rc = mm_app_stop_channel(test_obj, ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("stop recording failed rc=%d\n",  rc);
-    }
-
-    for ( i = 0 ; i < ch->num_streams ; i++ ) {
-        mm_app_del_stream(test_obj, ch, &ch->streams[i]);
-    }
-    rc = setmetainfoCommand(test_obj, &abc);
-    if (rc != MM_CAMERA_OK) {
-       LOGE(" meta info command failed\n");
-    }
-    mm_app_del_channel(test_obj, ch);
-
-    return rc;
-}
-
-int mm_app_start_capture(mm_camera_test_obj_t *test_obj,
-                         uint8_t num_snapshots)
-{
-    int32_t rc = MM_CAMERA_OK;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *s_main = NULL;
-    mm_camera_stream_t *s_post = NULL;
-    mm_camera_channel_attr_t attr;
-    memset(&attr, 0, sizeof(mm_camera_channel_attr_t));
-    attr.notify_mode = MM_CAMERA_SUPER_BUF_NOTIFY_CONTINUOUS;
-    attr.max_unmatched_frames = 3;
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_CAPTURE,
-                                 &attr,
-                                 mm_app_snapshot_notify_cb,
-                                 test_obj);
-    if (NULL == channel) {
-        LOGE(" add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    s_main = mm_app_add_snapshot_stream(test_obj,
-                                        channel,
-                                        mm_app_snapshot_notify_cb,
-                                        (void *)test_obj,
-                                        CAPTURE_BUF_NUM,
-                                        num_snapshots);
-    if (NULL == s_main) {
-        LOGE(" add main snapshot stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    s_post = mm_app_add_postview_stream(test_obj,
-                                        channel,
-                                        NULL,
-                                        NULL,
-                                        CAPTURE_BUF_NUM,
-                                        num_snapshots);
-    if (NULL == s_main) {
-        LOGE(" add main postview stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    rc = mm_app_start_channel(test_obj, channel);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start zsl failed rc=%d\n",  rc);
-        mm_app_del_stream(test_obj, channel, s_main);
-        mm_app_del_channel(test_obj, channel);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_capture(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *ch = NULL;
-
-    ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_CAPTURE);
-
-    rc = mm_app_stop_and_del_channel(test_obj, ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("stop capture channel failed rc=%d\n",  rc);
-    }
-
-    return rc;
-}
-
-int mm_app_take_picture(mm_camera_test_obj_t *test_obj, uint8_t is_burst_mode)
-{
-    LOGH("\nEnter %s!!\n");
-    int rc = MM_CAMERA_OK;
-    uint8_t num_snapshot = 1;
-    int num_rcvd_snapshot = 0;
-
-    if (is_burst_mode)
-       num_snapshot = 6;
-
-    //stop preview before starting capture.
-    rc = mm_app_stop_preview(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE(" stop preview failed before capture!!, err=%d\n", rc);
-        return rc;
-    }
-
-    rc = mm_app_start_capture(test_obj, num_snapshot);
-    if (rc != MM_CAMERA_OK) {
-        LOGE(" mm_app_start_capture(), err=%d\n", rc);
-        return rc;
-    }
-    while (num_rcvd_snapshot < num_snapshot) {
-        LOGH("\nWaiting mm_camera_app_wait !!\n");
-        mm_camera_app_wait();
-        num_rcvd_snapshot++;
-    }
-    rc = mm_app_stop_capture(test_obj);
-    if (rc != MM_CAMERA_OK) {
-       LOGE(" mm_app_stop_capture(), err=%d\n", rc);
-       return rc;
-    }
-    //start preview after capture.
-    rc = mm_app_start_preview(test_obj);
-    if (rc != MM_CAMERA_OK) {
-        LOGE(" start preview failed after capture!!, err=%d\n",rc);
-    }
-    return rc;
-}
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
deleted file mode 100644
index 81c377f..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_socket.c
+++ /dev/null
@@ -1,881 +0,0 @@
-/* Copyright (c) 2012-2014, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// System dependencies
-#include <errno.h>
-#include <sys/socket.h>
-#include <fcntl.h>
-
-// Camera dependencies
-#include "mm_qcamera_socket.h"
-#include "mm_qcamera_commands.h"
-#include "mm_qcamera_dbg.h"
-
-#define IP_ADDR                  "127.0.0.1"
-#define TUNING_CHROMATIX_PORT     55555
-#define TUNING_PREVIEW_PORT       55556
-
-#define CURRENT_COMMAND_ACK_SUCCESS 1
-#define CURRENT_COMMAND_ACK_FAILURE 2
-
-pthread_t eztune_thread_id;
-
-static ssize_t tuneserver_send_command_rsp(tuningserver_t *tsctrl,
-  char *send_buf, uint32_t send_len)
-{
-  ssize_t rc;
-
-  /* send ack back to client upon req */
-  if (send_len <= 0) {
-    LOGE("Invalid send len \n");
-    return -1;
-  }
-  if (send_buf == NULL) {
-    LOGE("Invalid send buf \n");
-    return -1;
-  }
-
-  rc = send(tsctrl->clientsocket_id, send_buf, send_len, 0);
-  if (rc < 0) {
-    LOGE("RSP send returns error %s\n",  strerror(errno));
-  } else {
-    rc = 0;
-  }
-
-  if (send_buf != NULL) {
-    free(send_buf);
-    send_buf = NULL;
-  }
-  return rc;
-}
-
-static void release_eztune_prevcmd_rsp(eztune_prevcmd_rsp *pHead)
-{
-  if (pHead != NULL ) {
-    release_eztune_prevcmd_rsp((eztune_prevcmd_rsp *)pHead->next);
-    free(pHead);
-  }
-}
-
-static ssize_t tuneserver_ack(uint16_t a, uint32_t b, tuningserver_t *tsctrl)
-{
-  ssize_t rc;
-  char ack_1[6];
-  /*Ack the command here*/
-  memcpy(ack_1, &a, 2);
-  memcpy(ack_1+2, &b, 4);
-  /* send echo back to client upon accept */
-  rc = send(tsctrl->clientsocket_id, &ack_1, sizeof(ack_1), 0);
-  if (rc < 0) {
-    LOGE(" eztune_server_run: send returns error %s\n",
-      strerror(errno));
-    return rc;
-  } else if (rc < (int32_t)sizeof(ack_1)) {
-    /*Shouldn't hit this for packets <1K; need to re-send if we do*/
-  }
-  return 0;
-}
-
-static ssize_t tuneserver_send_command_ack( uint8_t ack,
-    tuningserver_t *tsctrl)
-{
-  ssize_t rc;
-  /* send ack back to client upon req */
-  rc = send(tsctrl->clientsocket_id, &ack, sizeof(ack), 0);
-  if (rc < 0) {
-    LOGE("ACK send returns error %s\n",  strerror(errno));
-    return rc;
-  }
-  return 0;
-}
-
-/** tuneserver_process_command
- *    @tsctrl: the server control object
- *
- *  Processes the command that the client sent
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-static int32_t tuneserver_process_command(tuningserver_t *tsctrl,
-  char *send_buf, uint32_t send_len)
-{
-  tuneserver_protocol_t *p = tsctrl->proto;
-  int result = 0;
-
-  LOGD(" Current command is %d\n",  p->current_cmd);
-  switch (p->current_cmd) {
-  case TUNESERVER_GET_LIST:
-    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
-      LOGE(" Ack Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    result = tuneserver_process_get_list_cmd(tsctrl, p->recv_buf,
-      send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
-      LOGE(" RSP Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    break;
-
-  case TUNESERVER_GET_PARMS:
-    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
-      LOGE(" Ack Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    result = tuneserver_process_get_params_cmd(tsctrl, p->recv_buf,
-      send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
-      LOGE(" RSP Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    break;
-
-  case TUNESERVER_SET_PARMS:
-    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
-      LOGE(" Ack Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    result = tuneserver_process_set_params_cmd(tsctrl, p->recv_buf,
-      send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
-      LOGE(" RSP Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    break;
-
-  case TUNESERVER_MISC_CMDS: {
-    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
-      LOGE(" Ack Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    result = tuneserver_process_misc_cmd(tsctrl, p->recv_buf,
-      send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if(tuneserver_send_command_rsp(tsctrl, send_buf, send_len)) {
-      LOGE(" RSP Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    break;
-  }
-
-  default:
-    if(tuneserver_send_command_ack(CURRENT_COMMAND_ACK_SUCCESS, tsctrl)) {
-      LOGE(" Ack Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    LOGE(" p->current_cmd: default\n");
-    result = -1;
-    break;
-  }
-
-  return result;
-}
-
-/** tuneserver_process_client_message
- *    @recv_buffer: received message from the client
- *    @tsctrl: the server control object
- *
- *  Processes the message from client and prepares for next
- *  message.
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-static int32_t tuneserver_process_client_message(void *recv_buffer,
-  tuningserver_t *tsctrl)
-{
-  int rc = 0;
-  tuneserver_protocol_t *p = tsctrl->proto;
-
-  switch (tsctrl->proto->next_recv_code) {
-  case TUNESERVER_RECV_COMMAND:
-    p->current_cmd = *(uint16_t *)recv_buffer;
-    p->next_recv_code = TUNESERVER_RECV_PAYLOAD_SIZE;
-    p->next_recv_len = sizeof(uint32_t);
-    break;
-
-  case TUNESERVER_RECV_PAYLOAD_SIZE:
-    p->next_recv_code = TUNESERVER_RECV_PAYLOAD;
-    p->next_recv_len = *(uint32_t *)recv_buffer;
-    p->recv_len = p->next_recv_len;
-    if (p->next_recv_len > TUNESERVER_MAX_RECV)
-      return -1;
-    if (p->next_recv_len == 0) {
-      p->next_recv_code = TUNESERVER_RECV_RESPONSE;
-      p->next_recv_len = sizeof(uint32_t);
-    }
-    break;
-
-  case TUNESERVER_RECV_PAYLOAD:
-    p->recv_buf = malloc(p->next_recv_len);
-    if (!p->recv_buf) {
-      LOGE("Error allocating memory for recv_buf %s\n",
-        strerror(errno));
-      return -1;
-    }
-    memcpy(p->recv_buf, recv_buffer, p->next_recv_len);
-    p->next_recv_code = TUNESERVER_RECV_RESPONSE;
-    p->next_recv_len = sizeof(uint32_t);
-    /*Process current command at this point*/
-    break;
-
-  case TUNESERVER_RECV_RESPONSE:
-    p->next_recv_code = TUNESERVER_RECV_COMMAND;
-    p->next_recv_len = 2;
-    p->send_len = *(uint32_t *)recv_buffer;
-    p->send_buf =  (char *)calloc(p->send_len, sizeof(char *));
-    if (!p->send_buf) {
-      LOGE("Error allocating memory for send_buf %s\n",
-        strerror(errno));
-      return -1;
-    }
-    rc = tuneserver_process_command(tsctrl, p->send_buf, p->send_len);
-    free(p->recv_buf);
-    p->recv_buf = NULL;
-    p->recv_len = 0;
-    break;
-
-  default:
-    LOGE(" p->next_recv_code: default\n");
-    rc = -1;
-    break;
-  }
-
-  return rc;
-}
-
-/** tuneserver_ack_onaccept_initprotocol
- *    @tsctrl: the server control object
- *
- *  Acks a connection from the cient and sets up the
- *  protocol object to start receiving commands.
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-static ssize_t tuneserver_ack_onaccept_initprotocol(tuningserver_t *tsctrl)
-{
-  ssize_t rc = 0;
-  uint32_t ack_status;
-
-  LOGE("starts\n");
-/*
-  if(tsctrl->camera_running) {
-    ack_status = 1;
-  } else {
-    ack_status = 2;
-  }
-*/
-  ack_status = 1;
-
-  rc = tuneserver_ack(1, ack_status, tsctrl);
-
-  tsctrl->proto = malloc(sizeof(tuneserver_protocol_t));
-  if (!tsctrl->proto) {
-    LOGE(" malloc returns NULL with error %s\n",  strerror(errno));
-    return -1;
-  }
-
-  tsctrl->proto->current_cmd    = 0xFFFF;
-  tsctrl->proto->next_recv_code = TUNESERVER_RECV_COMMAND;
-  tsctrl->proto->next_recv_len  = 2;
-  tsctrl->proto->recv_buf       = NULL;
-  tsctrl->proto->send_buf       = NULL;
-
-  LOGD("X\n");
-
-  return rc;
-}
-
-/** tuneserver_check_status
- *    @tsctrl: the server control object
- *
- *  Checks if camera is running and stops it.
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-#if 0
-static void tuneserver_check_status(tuningserver_t *tsctrl)
-{
-  if (tsctrl->camera_running == 1) {
-    /*TODO: Stop camera here*/
-    tuneserver_stop_cam(&tsctrl->lib_handle);
-  }
-  tsctrl->camera_running = 0;
-
-  tuneserver_close_cam(&tsctrl->lib_handle);
-}
-#endif
-
-static ssize_t prevserver_send_command_rsp(tuningserver_t *tsctrl,
-  char *send_buf, uint32_t send_len)
-{
-  ssize_t rc;
-
-  /* send ack back to client upon req */
-  if (send_len <= 0) {
-    LOGE("Invalid send len \n");
-    return -1;
-  }
-  if (send_buf == NULL) {
-    LOGE("Invalid send buf \n");
-    return -1;
-  }
-
-  rc = send(tsctrl->pr_clientsocket_id, send_buf, send_len, 0);
-  if (rc < 0) {
-    LOGE("RSP send returns error %s\n",  strerror(errno));
-  } else {
-    rc = 0;
-  }
-  if (send_buf != NULL) {
-    free(send_buf);
-    send_buf = NULL;
-  }
-  return rc;
-}
-
-static void prevserver_init_protocol(tuningserver_t *tsctrl)
-{
-  tsctrl->pr_proto = malloc(sizeof(prserver_protocol_t));
-  if (!tsctrl->pr_proto) {
-    LOGE(" malloc returns NULL with error %s\n",
-      strerror(errno));
-    return;
-  }
-
-  tsctrl->pr_proto->current_cmd    = 0xFFFF;
-  tsctrl->pr_proto->next_recv_code = TUNE_PREV_RECV_COMMAND;
-  tsctrl->pr_proto->next_recv_len  = 2;
-}
-
-static int32_t prevserver_process_command(
-  tuningserver_t *tsctrl, char **send_buf, uint32_t *send_len)
-{
-  prserver_protocol_t *p = tsctrl->pr_proto;
-  int result = 0;
-  eztune_prevcmd_rsp *rsp_ptr=NULL, *rspn_ptr=NULL, *head_ptr=NULL;
-
-  LOGD(" Current command is %d\n",  p->current_cmd);
-  switch (p->current_cmd) {
-  case TUNE_PREV_GET_INFO:
-    result = tuneserver_preview_getinfo(tsctrl, send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",
-        p->current_cmd);
-      return -1;
-    }
-    rsp_ptr = (eztune_prevcmd_rsp *)*send_buf;
-    if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
-      LOGE(" RSP ptr is NULL %d\n",  p->current_cmd);
-      return -1;
-    }
-    if (prevserver_send_command_rsp(tsctrl,
-      rsp_ptr->send_buf, rsp_ptr->send_len)) {
-      LOGE(" RSP Failed for TUNE_PREV_GET_INFO ver cmd %d\n",
-        p->current_cmd);
-      return -1;
-    }
-    rspn_ptr = (eztune_prevcmd_rsp *)rsp_ptr->next;
-    if ((!rspn_ptr) || (!rspn_ptr->send_buf)) {
-      LOGE(" RSP1 ptr is NULL %d\n",  p->current_cmd);
-      return -1;
-    }
-    if (prevserver_send_command_rsp(tsctrl,
-        rspn_ptr->send_buf, rspn_ptr->send_len)) {
-      LOGE(" RSP Failed for TUNE_PREV_GET_INFO caps cmd %d\n",
-        p->current_cmd);
-      return -1;
-    }
-    free(rspn_ptr);
-    free(rsp_ptr);
-    break;
-
-  case TUNE_PREV_CH_CNK_SIZE:
-    result = tuneserver_preview_getchunksize(tsctrl, send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if (prevserver_send_command_rsp(tsctrl, *send_buf, *send_len)) {
-      LOGE(" RSP Failed for TUNE_PREV_CH_CNK_SIZE cmd %d\n",
-        p->current_cmd);
-      return -1;
-    }
-    break;
-
-  case TUNE_PREV_GET_PREV_FRAME:
-    result = tuneserver_preview_getframe(tsctrl, send_buf, send_len);
-    if (result < 0) {
-      LOGE(" RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    rsp_ptr = (eztune_prevcmd_rsp *)*send_buf;
-    if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
-      LOGE(" RSP ptr is NULL %d\n",  p->current_cmd);
-      return -1;
-    }
-    head_ptr = rsp_ptr;
-
-    while (rsp_ptr != NULL) {
-      if ((!rsp_ptr) || (!rsp_ptr->send_buf)) {
-        LOGE(" RSP ptr is NULL %d\n",  p->current_cmd);
-        return -1;
-      }
-      if (prevserver_send_command_rsp(tsctrl,
-        rsp_ptr->send_buf, rsp_ptr->send_len)) {
-        LOGE(" RSP Failed for TUNE_PREV_GET_INFO ver cmd %d\n",
-          p->current_cmd);
-        return -1;
-      }
-      rsp_ptr = (eztune_prevcmd_rsp *)rsp_ptr->next;
-    }
-    release_eztune_prevcmd_rsp(head_ptr);
-    break;
-
-  case TUNE_PREV_GET_JPG_SNAP:
-  case TUNE_PREV_GET_RAW_SNAP:
-  case TUNE_PREV_GET_RAW_PREV:
-    result = tuneserver_preview_unsupported(tsctrl, send_buf, send_len);
-    if (result < 0) {
-       LOGE("RSP processing Failed for cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    if (prevserver_send_command_rsp(tsctrl, *send_buf, *send_len)) {
-      LOGE("RSP Failed for UNSUPPORTED cmd %d\n",  p->current_cmd);
-      return -1;
-    }
-    break;
-
-  default:
-    LOGE(" p->current_cmd: default\n");
-    result = -1;
-    break;
-  }
-
-  return result;
-}
-
-/** previewserver_process_client_message
- *    @recv_buffer: received message from the client
- *    @tsctrl: the server control object
- *
- *  Processes the message from client and prepares for next
- *  message.
- *
- *  Return: >=0 on success, -1 on failure.
- **/
-static int32_t prevserver_process_client_message(void *recv_buffer,
-  tuningserver_t *tsctrl)
-{
-  int rc = 0;
-  prserver_protocol_t *p = tsctrl->pr_proto;
-
-  LOGD("command = %d", p->next_recv_code);
-
-  switch (p->next_recv_code) {
-  case TUNE_PREV_RECV_COMMAND:
-    p->current_cmd = *(uint16_t *)recv_buffer;
-    if(p->current_cmd != TUNE_PREV_CH_CNK_SIZE) {
-      rc = prevserver_process_command(tsctrl,
-        &p->send_buf, (uint32_t *)&p->send_len);
-      break;
-    }
-    p->next_recv_code = TUNE_PREV_RECV_NEWCNKSIZE;
-    p->next_recv_len = sizeof(uint32_t);
-    LOGD("TUNE_PREV_COMMAND X\n");
-    break;
-  case TUNE_PREV_RECV_NEWCNKSIZE:
-    p->new_cnk_size = *(uint32_t *)recv_buffer;
-    p->next_recv_code = TUNE_PREV_RECV_COMMAND;
-    p->next_recv_len  = 2;
-    rc = prevserver_process_command(tsctrl,
-      &p->send_buf, (uint32_t *)&p->send_len);
-    break;
-  default:
-    LOGE("prev_proc->next_recv_code: default\n");
-    rc = -1;
-    break;
-  }
-
-  return rc;
-}
-
-/** tunning_server_socket_listen
- *    @ip_addr: the ip addr to listen
- *    @port: the port to listen
- *
- *  Setup a listen socket for eztune.
- *
- *  Return: >0 on success, <=0 on failure.
- **/
-int tunning_server_socket_listen(const char* ip_addr, uint16_t port)
-{
-  int sock_fd = -1;
-  mm_qcamera_sock_addr_t server_addr;
-  int result;
-  int option;
-  int socket_flag;
-
-  memset(&server_addr, 0, sizeof(server_addr));
-  server_addr.addr_in.sin_family = AF_INET;
-  server_addr.addr_in.sin_port = (__be16) htons(port);
-  server_addr.addr_in.sin_addr.s_addr = inet_addr(ip_addr);
-
-  if (server_addr.addr_in.sin_addr.s_addr == INADDR_NONE) {
-    LOGE(" invalid address.\n");
-    return -1;
-  }
-
-  /* Create an AF_INET stream socket to receive incoming connection ON */
-  sock_fd = socket(AF_INET, SOCK_STREAM, 0);
-  if (sock_fd < 0) {
-    LOGE(" socket failed\n");
-    return sock_fd;
-  }
-
-  // set listen socket to non-block, but why??
-  socket_flag = fcntl(sock_fd, F_GETFL, 0);
-  fcntl(sock_fd, F_SETFL, socket_flag | O_NONBLOCK);
-
-  /* reuse in case it is in timeout */
-  option = 1;
-  result = setsockopt(sock_fd, SOL_SOCKET, SO_REUSEADDR,
-    &option, sizeof(option));
-
-  if (result < 0) {
-    LOGE("eztune setsockopt failed");
-    close(sock_fd);
-    sock_fd = -1;
-    return sock_fd;
-  }
-
-  result = bind(sock_fd, &server_addr.addr, sizeof(server_addr.addr_in));
-  if (result < 0) {
-    LOGE("eztune socket bind failed");
-    close(sock_fd);
-    sock_fd = -1;
-    return sock_fd;
-  }
-
-  result = listen(sock_fd, 1);
-  if (result < 0) {
-    LOGE("eztune socket listen failed");
-    close(sock_fd);
-    sock_fd = -1;
-    return sock_fd;
-  }
-
-  LOGH("sock_fd: %d, listen at port: %d\n",  sock_fd, port);
-
-  return sock_fd;
-}
-
-/** main
- *
- *  Creates the server, and starts waiting for
- *  connections/messages from a prospective
- *  client
- *
- **/
-void *eztune_proc(void *data)
-{
-  int server_socket = -1, client_socket = -1;
-  int prev_server_socket = -1, prev_client_socket = -1;
-
-  mm_qcamera_sock_addr_t addr_client_inet;
-  socklen_t addr_client_len = sizeof(addr_client_inet.addr_in);
-  int result;
-  fd_set tsfds;
-  int num_fds = 0;
-  ssize_t recv_bytes;
-  char buf[TUNESERVER_MAX_RECV];
-
-  mm_camera_lib_handle *lib_handle = (mm_camera_lib_handle *)data;
-
-  LOGE(">>> Starting tune server <<< \n");
-
-  // for eztune chromatix params
-  server_socket = tunning_server_socket_listen(IP_ADDR, TUNING_CHROMATIX_PORT);
-  if (server_socket <= 0) {
-    LOGE("[ERR] fail to setup listen socket for eztune chromatix parms...");
-    return NULL;
-  }
-  prev_server_socket = tunning_server_socket_listen(IP_ADDR, TUNING_PREVIEW_PORT);
-  if (prev_server_socket <= 0) {
-    LOGE("[ERR] fail to setup listen socket for eztune preview...\n");
-    return NULL;
-  }
-  num_fds = TUNESERVER_MAX(server_socket, prev_server_socket);
-  LOGH("num_fds = %d\n", num_fds);
-
-  do {
-    FD_ZERO(&tsfds);
-    FD_SET(server_socket, &tsfds);
-    FD_SET(prev_server_socket, &tsfds);
-    if (client_socket > 0) {
-      FD_SET(client_socket, &tsfds);
-    }
-    if (prev_client_socket > 0) {
-      FD_SET( prev_client_socket, &tsfds);
-    }
-
-    /* no timeout */
-    result = select(num_fds + 1, &tsfds, NULL, NULL, NULL);
-    if (result < 0) {
-      LOGE("select failed: %s\n", strerror(errno));
-      continue;
-    }
-
-    /*
-     ** (1) CHROMATIX SERVER
-     */
-    if (FD_ISSET(server_socket, &tsfds)) {
-      LOGD("Receiving New client connection\n");
-
-      client_socket = accept(server_socket,
-        &addr_client_inet.addr, &addr_client_len);
-      if (client_socket == -1) {
-        LOGE("accept failed %s", strerror(errno));
-        continue;
-      }
-
-      if (client_socket >= FD_SETSIZE) {
-        LOGE("client_socket is out of range. client_socket=%d",client_socket);
-        continue;
-      }
-
-      LOGE("accept a new connect on 55555, sd(%d)\n", client_socket);
-      num_fds = TUNESERVER_MAX(num_fds, client_socket);
-
-      // open camera and get handle - this is needed to
-      // be able to set parameters without starting
-      // preview stream
-      /*if (!tsctrl.camera_running) {
-        result = tuneserver_open_cam(&tsctrl.lib_handle, &tsctrl);
-        if(result) {
-          printf("\n Camera Open Fail !!! \n");
-          close(server_socket);
-          return EXIT_FAILURE;
-        }
-      }*/
-      result = tuneserver_open_cam(lib_handle);
-      if(result) {
-        LOGE("\n Tuning Library open failed!!!\n");
-        close(server_socket);
-        return NULL;
-      }
-      lib_handle->tsctrl.clientsocket_id = client_socket;
-      if (tuneserver_ack_onaccept_initprotocol(&lib_handle->tsctrl) < 0) {
-        LOGE(" Error while acking\n");
-        close(client_socket);
-        continue;
-      }
-      tuneserver_initialize_tuningp(lib_handle, client_socket,
-        lib_handle->tsctrl.proto->send_buf, lib_handle->tsctrl.proto->send_len);
-    }
-
-    if ((client_socket < FD_SETSIZE) && (FD_ISSET(client_socket, &tsfds))) {
-      if (lib_handle->tsctrl.proto == NULL) {
-        LOGE(" Cannot receive msg without connect\n");
-        continue;
-      }
-
-      /*Receive message and process it*/
-      recv_bytes = recv(client_socket, (void *)buf,
-        lib_handle->tsctrl.proto->next_recv_len, 0);
-      LOGD("Receive %lld bytes \n", (long long int) recv_bytes);
-
-      if (recv_bytes == -1) {
-        LOGE(" Receive failed with error %s\n",  strerror(errno));
-        //tuneserver_check_status(&tsctrl);
-        continue;
-      } else if (recv_bytes == 0) {
-        LOGE("connection has been terminated\n");
-
-        tuneserver_deinitialize_tuningp(&lib_handle->tsctrl, client_socket,
-          lib_handle->tsctrl.proto->send_buf,
-          lib_handle->tsctrl.proto->send_len);
-        free(lib_handle->tsctrl.proto);
-        lib_handle->tsctrl.proto = NULL;
-
-        close(client_socket);
-        client_socket = -1;
-        //tuneserver_check_status(&tsctrl);
-      } else {
-        LOGD(" Processing socket command\n");
-
-        result = tuneserver_process_client_message(buf, &lib_handle->tsctrl);
-
-        if (result < 0) {
-          LOGE("Protocol violated\n");
-
-          free(lib_handle->tsctrl.proto);
-          lib_handle->tsctrl.proto = NULL;
-
-          close(client_socket);
-          client_socket = -1;
-          //tuneserver_check_status(&tsctrl);
-          continue;
-        }
-      }
-    }
-
-    /*
-     ** (2) PREVIEW SERVER
-     */
-    if (FD_ISSET(prev_server_socket, &tsfds)) {
-      LOGD("Receiving New Preview client connection\n");
-
-      prev_client_socket = accept(prev_server_socket,
-        &addr_client_inet.addr, &addr_client_len);
-      if (prev_client_socket == -1) {
-        LOGE("accept failed %s", strerror(errno));
-        continue;
-      }
-      if (prev_client_socket >= FD_SETSIZE) {
-        LOGE("prev_client_socket is out of range. prev_client_socket=%d",prev_client_socket);
-        continue;
-      }
-
-      lib_handle->tsctrl.pr_clientsocket_id = prev_client_socket;
-
-      LOGD("Accepted a new connection, fd(%d)\n", prev_client_socket);
-      num_fds = TUNESERVER_MAX(num_fds, prev_client_socket);
-
-      // start camera
-      /*if (!tsctrl.camera_running) {
-        result = 0;
-        result = tuneserver_open_cam(&tsctrl.lib_handle, &tsctrl);
-        if(result) {
-          printf("\n Camera Open Fail !!! \n");
-          return EXIT_FAILURE;
-        }
-      }*/
-      cam_dimension_t dim;
-      //dim.width = lib_handle->test_obj.buffer_width;
-      //dim.height = lib_handle->test_obj.buffer_height;
-      dim.width = DEFAULT_PREVIEW_WIDTH;
-      dim.height = DEFAULT_PREVIEW_HEIGHT;
-
-      LOGD("preview dimension info: w(%d), h(%d)\n", dim.width, dim.height);
-      // we have to make sure that camera is running, before init connection,
-      // because we need to know the frame size for allocating the memory.
-      prevserver_init_protocol(&lib_handle->tsctrl);
-
-      result = tuneserver_initialize_prevtuningp(lib_handle, prev_client_socket,
-        dim, (char **)&lib_handle->tsctrl.proto->send_buf,
-        &lib_handle->tsctrl.proto->send_len);
-      if (result < 0) {
-        LOGE("tuneserver_initialize_prevtuningp error!");
-        close(prev_client_socket);
-        prev_client_socket = -1;
-      }
-    }
-
-    if ((prev_client_socket < FD_SETSIZE) && (FD_ISSET(prev_client_socket, &tsfds))) {
-      recv_bytes = recv(prev_client_socket, (void *)buf,
-        lib_handle->tsctrl.pr_proto->next_recv_len, 0);
-
-      LOGD("prev_client_socket=%d\n",  prev_client_socket);
-      LOGD("next_recv_len=%d\n",  buf[0]+buf[1]*256);
-
-      if (recv_bytes <= 0) {
-        if (recv_bytes == 0) {
-          LOGE("client close the connection.\n");
-        } else {
-          LOGE("receive error: %s\n", strerror(errno));
-        }
-
-        //tuneserver_check_status(&tsctrl);
-        // if recv error, we should close the connection, free the proto data,
-        // AND wait for a new connecton..
-        // close_connection();
-        // stop_camera()
-        // cleanup_proto_data();
-        tuneserver_deinitialize_prevtuningp(&lib_handle->tsctrl,
-          (char **)&lib_handle->tsctrl.proto->send_buf,
-          &lib_handle->tsctrl.proto->send_len);
-        close(prev_client_socket);
-        prev_client_socket = -1;
-      } else {
-        result = prevserver_process_client_message((void *)buf,
-          &lib_handle->tsctrl);
-        if (result < 0) {
-          LOGE("Protocol violated\n");
-
-          //free(tsctrl->preivew_proto);
-          //free(tsctrl);
-          //max_fd = ezt_parms_listen_sd + 1;
-          tuneserver_deinitialize_prevtuningp(&lib_handle->tsctrl,
-            (char **)&lib_handle->tsctrl.proto->send_buf,
-            &lib_handle->tsctrl.proto->send_len);
-          close(prev_client_socket);
-          prev_client_socket = -1;
-          //tuneserver_check_status(&tsctrl);
-        }
-        //sleep(1);
-      }
-    }
-  } while (1);
-
-  if (server_socket >= 0) {
-    close(server_socket);
-  }
-  if (client_socket >= 0) {
-    close(client_socket);
-  }
-  if (prev_server_socket >= 0) {
-    close(prev_server_socket);
-  }
-  if (prev_client_socket >= 0) {
-    close(prev_client_socket);
-  }
-
-  return EXIT_SUCCESS;
-}
-
-int eztune_server_start (void *lib_handle)
-{
-  return pthread_create(&eztune_thread_id, NULL,  eztune_proc, lib_handle);
-}
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_unit_test.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_unit_test.c
deleted file mode 100644
index c6eaab7..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_unit_test.c
+++ /dev/null
@@ -1,695 +0,0 @@
-/* Copyright (c) 2013, 2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-#define MM_QCAMERA_APP_UTEST_MAX_MAIN_LOOP 1
-#define MM_QCAMERA_APP_UTEST_OUTER_LOOP 1
-#define MM_QCAMERA_APP_UTEST_INNER_LOOP 1
-#define MM_QCAM_APP_TEST_NUM 128
-
-static mm_app_tc_t mm_app_tc[MM_QCAM_APP_TEST_NUM];
-
-int mm_app_tc_open_close(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying open/close cameras...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-        sleep(1);
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_start_stop_preview(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying start/stop preview...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_preview(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            sleep(1);
-            rc = mm_app_stop_preview(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc |= mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_start_stop_zsl(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying start/stop preview...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < 1; j++) {
-            rc = mm_app_start_preview_zsl(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_preview_zsl() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            sleep(1);
-            rc = mm_app_stop_preview_zsl(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_preview_zsl() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_start_stop_video_preview(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying start/stop video preview...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_record_preview(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_start_record_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            sleep(1);
-            rc = mm_app_stop_record_preview(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_stop_record_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_start_stop_video_record(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying start/stop recording...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        rc = mm_app_start_record_preview(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_start_record_preview() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        sleep(1);
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_record(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_start_record() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-
-            sleep(1);
-
-            rc = mm_app_stop_record(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_stop_record() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-        if (rc != MM_CAMERA_OK) {
-            LOGE("start/stop record cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_stop_record_preview(&test_obj);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        rc = mm_app_stop_record_preview(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_stop_record_preview() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_start_stop_live_snapshot(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying start/stop live snapshot...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        rc = mm_app_start_record_preview(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_start_record_preview() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        sleep(1);
-
-        rc = mm_app_start_record(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_start_record() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_stop_record_preview(&test_obj);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        sleep(1);
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_live_snapshot(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_start_live_snapshot() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-
-            /* wait for jpeg is done */
-            mm_camera_app_wait();
-
-            rc = mm_app_stop_live_snapshot(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE("mm_app_stop_live_snapshot() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-        if (rc != MM_CAMERA_OK) {
-            LOGE("start/stop live snapshot cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_stop_record(&test_obj);
-            mm_app_stop_record_preview(&test_obj);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        rc = mm_app_stop_record(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_stop_record() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_stop_record_preview(&test_obj);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        sleep(1);
-
-        rc = mm_app_stop_record_preview(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_stop_record_preview() cam_idx=%d, err=%d\n",
-                        i, rc);
-            mm_app_close(&test_obj);
-            break;
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_capture_raw(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-    uint8_t num_snapshot = 1;
-    uint8_t num_rcvd_snapshot = 0;
-
-    printf("\n Verifying raw capture...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_capture_raw(&test_obj, num_snapshot);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            while (num_rcvd_snapshot < num_snapshot) {
-                mm_camera_app_wait();
-                num_rcvd_snapshot++;
-            }
-            rc = mm_app_stop_capture_raw(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc |= mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_capture_regular(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-    uint8_t num_snapshot = 1;
-    uint8_t num_rcvd_snapshot = 0;
-
-    printf("\n Verifying capture...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_capture(&test_obj, num_snapshot);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            while (num_rcvd_snapshot < num_snapshot) {
-                mm_camera_app_wait();
-                num_rcvd_snapshot++;
-            }
-            rc = mm_app_stop_capture(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_capture_burst(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-    uint8_t num_snapshot = 3;
-    uint8_t num_rcvd_snapshot = 0;
-
-    printf("\n Verifying capture...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_capture(&test_obj, num_snapshot);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            while (num_rcvd_snapshot < num_snapshot) {
-                mm_camera_app_wait();
-                num_rcvd_snapshot++;
-            }
-            rc = mm_app_stop_capture(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_capture() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc = mm_app_close(&test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_rdi_burst(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK, rc2 = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying rdi burst (3) capture...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_rdi(&test_obj, 3);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            sleep(1);
-            rc = mm_app_stop_rdi(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc2 = mm_app_close(&test_obj);
-        if (rc2 != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc2);
-            if (rc == MM_CAMERA_OK) {
-                rc = rc2;
-            }
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_tc_rdi_cont(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK, rc2 = MM_CAMERA_OK;
-    int i, j;
-    mm_camera_test_obj_t test_obj;
-
-    printf("\n Verifying rdi continuous capture...\n");
-    for (i = 0; i < cam_app->num_cameras; i++) {
-        memset(&test_obj, 0, sizeof(mm_camera_test_obj_t));
-        rc = mm_app_open(cam_app, i, &test_obj);
-        if (rc != MM_CAMERA_OK) {
-            LOGE("mm_app_open() cam_idx=%d, err=%d\n",
-                        i, rc);
-            break;
-        }
-
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_INNER_LOOP; j++) {
-            rc = mm_app_start_rdi(&test_obj, 0);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_start_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-            sleep(1);
-            rc = mm_app_stop_rdi(&test_obj);
-            if (rc != MM_CAMERA_OK) {
-                LOGE(" mm_app_stop_preview() cam_idx=%d, err=%d\n",
-                            i, rc);
-                break;
-            }
-        }
-
-        rc2 = mm_app_close(&test_obj);
-        if (rc2 != MM_CAMERA_OK) {
-            LOGE("mm_app_close() cam_idx=%d, err=%d\n",
-                        i, rc2);
-            if (rc == MM_CAMERA_OK) {
-                rc = rc2;
-            }
-            break;
-        }
-    }
-    if (rc == MM_CAMERA_OK) {
-        printf("\nPassed\n");
-    } else {
-        printf("\nFailed\n");
-    }
-    LOGD("END, rc = %d\n",  rc);
-    return rc;
-}
-
-int mm_app_gen_test_cases()
-{
-    int tc = 0;
-    memset(mm_app_tc, 0, sizeof(mm_app_tc));
-    if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_open_close;
-    if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_start_stop_preview;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_start_stop_zsl;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_start_stop_video_preview;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_start_stop_video_record;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_start_stop_live_snapshot;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_capture_regular;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_capture_burst;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_rdi_cont;
-    //if (tc < MM_QCAM_APP_TEST_NUM) mm_app_tc[tc++].f = mm_app_tc_rdi_burst;
-
-    return tc;
-}
-
-int mm_app_unit_test_entry(mm_camera_app_t *cam_app)
-{
-    int rc = MM_CAMERA_OK;
-    int i, j, tc = 0;
-
-    tc = mm_app_gen_test_cases();
-    LOGD("Running %d test cases\n",tc);
-    for (i = 0; i < tc; i++) {
-        for (j = 0; j < MM_QCAMERA_APP_UTEST_OUTER_LOOP; j++) {
-            mm_app_tc[i].r = mm_app_tc[i].f(cam_app);
-            if (mm_app_tc[i].r != MM_CAMERA_OK) {
-                printf(" test case %d (iteration %d) error = %d, abort unit testing engine!!!!\n",
-                        i, j, mm_app_tc[i].r);
-                rc = mm_app_tc[i].r;
-                goto end;
-            }
-        }
-    }
-end:
-    printf("nTOTAL_TSET_CASE = %d, NUM_TEST_RAN = %d, rc=%d\n", tc, i, rc);
-    return rc;
-}
-
-
-
-
diff --git a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c b/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
deleted file mode 100644
index bf07877..0000000
--- a/camera/QCamera2/stack/mm-camera-test/src/mm_qcamera_video.c
+++ /dev/null
@@ -1,763 +0,0 @@
-/*
-Copyright (c) 2012-2014, 2016, The Linux Foundation. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions are
-met:
-    * Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-    * Redistributions in binary form must reproduce the above
-      copyright notice, this list of conditions and the following
-      disclaimer in the documentation and/or other materials provided
-      with the distribution.
-    * Neither the name of The Linux Foundation nor the names of its
-      contributors may be used to endorse or promote products derived
-      from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
-WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
-ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
-BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
-BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
-WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
-OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
-IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-// Camera dependencies
-#include "mm_qcamera_app.h"
-#include "mm_qcamera_dbg.h"
-
-static void mm_app_metadata_notify_cb(mm_camera_super_buf_t *bufs,
-                                     void *user_data)
-{
-  uint32_t i = 0;
-  mm_camera_channel_t *channel = NULL;
-  mm_camera_stream_t *p_stream = NULL;
-  mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-  mm_camera_buf_def_t *frame;
-  metadata_buffer_t *pMetadata;
-
-  if (NULL == bufs || NULL == user_data) {
-      LOGE("bufs or user_data are not valid ");
-      return;
-  }
-  frame = bufs->bufs[0];
-
-  /* find channel */
-  for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-      if (pme->channels[i].ch_id == bufs->ch_id) {
-          channel = &pme->channels[i];
-          break;
-      }
-  }
-
-  if (NULL == channel) {
-      LOGE("Channel object is NULL ");
-      return;
-  }
-
-  /* find preview stream */
-  for (i = 0; i < channel->num_streams; i++) {
-      if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_METADATA) {
-          p_stream = &channel->streams[i];
-          break;
-      }
-  }
-
-  if (NULL == p_stream) {
-      LOGE("cannot find metadata stream");
-      return;
-  }
-
-  /* find preview frame */
-  for (i = 0; i < bufs->num_bufs; i++) {
-      if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-          frame = bufs->bufs[i];
-          break;
-      }
-  }
-
-  if (pme->metadata == NULL) {
-    /* The app will free the meta data, we don't need to bother here */
-    pme->metadata = malloc(sizeof(metadata_buffer_t));
-    if (NULL == pme->metadata) {
-        LOGE("Canot allocate metadata memory\n");
-        return;
-    }
-  }
-  memcpy(pme->metadata, frame->buffer, sizeof(metadata_buffer_t));
-
-  pMetadata = (metadata_buffer_t *)frame->buffer;
-  IF_META_AVAILABLE(uint32_t, afState, CAM_INTF_META_AF_STATE, pMetadata) {
-    if ((cam_af_state_t)(*afState) == CAM_AF_STATE_FOCUSED_LOCKED ||
-            (cam_af_state_t)(*afState) == CAM_AF_STATE_NOT_FOCUSED_LOCKED) {
-        LOGE("AutoFocus Done Call Back Received\n");
-        mm_camera_app_done();
-    } else if ((cam_af_state_t)(*afState) == CAM_AF_STATE_NOT_FOCUSED_LOCKED) {
-        LOGE("AutoFocus failed\n");
-        mm_camera_app_done();
-    }
-  }
-
-  if (pme->user_metadata_cb) {
-      LOGD("[DBG] %s, user defined own metadata cb. calling it...");
-      pme->user_metadata_cb(frame);
-  }
-
-  if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                          bufs->ch_id,
-                                          frame)) {
-      LOGE("Failed in Preview Qbuf\n");
-  }
-  mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                   ION_IOC_INV_CACHES);
-}
-
-
-static void mm_app_snapshot_notify_cb(mm_camera_super_buf_t *bufs,
-                                      void *user_data)
-{
-
-    int rc = 0;
-    uint32_t i = 0;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_stream_t *m_stream = NULL;
-    mm_camera_buf_def_t *p_frame = NULL;
-    mm_camera_buf_def_t *m_frame = NULL;
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE("Wrong channel id (%d)",  bufs->ch_id);
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_SNAPSHOT) {
-            m_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL == m_stream) {
-        LOGE("cannot find snapshot stream");
-        rc = -1;
-        goto error;
-    }
-
-    /* find snapshot frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == m_stream->s_id) {
-            m_frame = bufs->bufs[i];
-            break;
-        }
-    }
-    if (NULL == m_frame) {
-        LOGE("main frame is NULL");
-        rc = -1;
-        goto error;
-    }
-
-    mm_app_dump_frame(m_frame, "main", "yuv", m_frame->frame_idx);
-
-    /* find postview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_POSTVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-    if (NULL != p_stream) {
-        /* find preview frame */
-        for (i = 0; i < bufs->num_bufs; i++) {
-            if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-                p_frame = bufs->bufs[i];
-                break;
-            }
-        }
-        if (NULL != p_frame) {
-            mm_app_dump_frame(p_frame, "postview", "yuv", p_frame->frame_idx);
-        }
-    }
-
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)m_frame->mem_info,
-                     ION_IOC_CLEAN_INV_CACHES);
-
-    pme->jpeg_buf.buf.buffer = (uint8_t *)malloc(m_frame->frame_len);
-    if ( NULL == pme->jpeg_buf.buf.buffer ) {
-        LOGE("error allocating jpeg output buffer");
-        goto error;
-    }
-
-    pme->jpeg_buf.buf.frame_len = m_frame->frame_len;
-    /* create a new jpeg encoding session */
-    rc = createEncodingSession(pme, m_stream, m_frame);
-    if (0 != rc) {
-        LOGE("error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-    /* start jpeg encoding job */
-    rc = encodeData(pme, bufs, m_stream);
-    if (0 != rc) {
-        LOGE("error creating jpeg session");
-        free(pme->jpeg_buf.buf.buffer);
-        goto error;
-    }
-
-error:
-    /* buf done rcvd frames in error case */
-    if ( 0 != rc ) {
-        for (i=0; i<bufs->num_bufs; i++) {
-            if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                                    bufs->ch_id,
-                                                    bufs->bufs[i])) {
-                LOGE("Failed in Qbuf\n");
-            }
-            mm_app_cache_ops((mm_camera_app_meminfo_t *)bufs->bufs[i]->mem_info,
-                             ION_IOC_INV_CACHES);
-        }
-    }
-
-    LOGD(" END\n");
-}
-
-static void mm_app_preview_notify_cb(mm_camera_super_buf_t *bufs,
-                                     void *user_data)
-{
-    uint32_t i = 0;
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *p_stream = NULL;
-    mm_camera_buf_def_t *frame = NULL;
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-
-    if (NULL == bufs || NULL == user_data) {
-        LOGE("bufs or user_data are not valid ");
-        return;
-    }
-
-    frame = bufs->bufs[0];
-
-    /* find channel */
-    for (i = 0; i < MM_CHANNEL_TYPE_MAX; i++) {
-        if (pme->channels[i].ch_id == bufs->ch_id) {
-            channel = &pme->channels[i];
-            break;
-        }
-    }
-    if (NULL == channel) {
-        LOGE("Channel object is NULL ");
-        return;
-    }
-    /* find preview stream */
-    for (i = 0; i < channel->num_streams; i++) {
-        if (channel->streams[i].s_config.stream_info->stream_type == CAM_STREAM_TYPE_PREVIEW) {
-            p_stream = &channel->streams[i];
-            break;
-        }
-    }
-
-    if (NULL == p_stream) {
-        LOGE("cannot find preview stream");
-        return;
-    }
-
-    /* find preview frame */
-    for (i = 0; i < bufs->num_bufs; i++) {
-        if (bufs->bufs[i]->stream_id == p_stream->s_id) {
-            frame = bufs->bufs[i];
-            break;
-        }
-    }
-
-    if ( 0 < pme->fb_fd ) {
-        mm_app_overlay_display(pme, frame->fd);
-    }
-#ifdef DUMP_PRV_IN_FILE
-    {
-        char file_name[64];
-        snprintf(file_name, sizeof(file_name), "P_C%d", pme->cam->camera_handle);
-        mm_app_dump_frame(frame, file_name, "yuv", frame->frame_idx);
-    }
-#endif
-    if (pme->user_preview_cb) {
-        LOGE("[DBG] %s, user defined own preview cb. calling it...");
-        pme->user_preview_cb(frame);
-    }
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                bufs->ch_id,
-                frame)) {
-        LOGE("Failed in Preview Qbuf\n");
-    }
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-            ION_IOC_INV_CACHES);
-
-    LOGD(" END\n");
-}
-
-
-static void mm_app_video_notify_cb(mm_camera_super_buf_t *bufs,
-                                   void *user_data)
-{
-    char file_name[64];
-    mm_camera_buf_def_t *frame = bufs->bufs[0];
-    mm_camera_test_obj_t *pme = (mm_camera_test_obj_t *)user_data;
-
-    LOGD("BEGIN - length=%zu, frame idx = %d\n",
-          frame->frame_len, frame->frame_idx);
-    snprintf(file_name, sizeof(file_name), "V_C%d", pme->cam->camera_handle);
-    mm_app_dump_frame(frame, file_name, "yuv", frame->frame_idx);
-
-    if (MM_CAMERA_OK != pme->cam->ops->qbuf(bufs->camera_handle,
-                                            bufs->ch_id,
-                                            frame)) {
-        LOGE("Failed in Preview Qbuf\n");
-    }
-    mm_app_cache_ops((mm_camera_app_meminfo_t *)frame->mem_info,
-                     ION_IOC_INV_CACHES);
-
-    LOGD("END\n");
-}
-
-mm_camera_stream_t * mm_app_add_video_preview_stream(mm_camera_test_obj_t *test_obj,
-                                               mm_camera_channel_t *channel,
-                                               mm_camera_buf_notify_t stream_cb,
-                                               void *userdata,
-                                               uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-    cam_dimension_t preview_dim = {0, 0};
-
-    if ((test_obj->preview_resolution.user_input_display_width == 0) ||
-           ( test_obj->preview_resolution.user_input_display_height == 0)) {
-        preview_dim.width = DEFAULT_PREVIEW_WIDTH;
-        preview_dim.height = DEFAULT_PREVIEW_HEIGHT;
-    } else {
-        preview_dim.width = test_obj->preview_resolution.user_input_display_width;
-        preview_dim.height = test_obj->preview_resolution.user_input_display_height;
-    }
-    LOGI("preview dimesion: %d x %d\n",  preview_dim.width, preview_dim.height);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-            mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_PREVIEW;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_PREVIEW_FORMAT;
-
-    stream->s_config.stream_info->dim.width = preview_dim.width;
-    stream->s_config.stream_info->dim.height = preview_dim.height;
-
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-
-mm_camera_stream_t * mm_app_add_video_snapshot_stream(mm_camera_test_obj_t *test_obj,
-                                                mm_camera_channel_t *channel,
-                                                mm_camera_buf_notify_t stream_cb,
-                                                void *userdata,
-                                                uint8_t num_bufs,
-                                                uint8_t num_burst)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-      mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_SNAPSHOT;
-    if (num_burst == 0) {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    } else {
-        stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_BURST;
-        stream->s_config.stream_info->num_of_burst = num_burst;
-    }
-    stream->s_config.stream_info->fmt = DEFAULT_SNAPSHOT_FORMAT;
-    if ( test_obj->buffer_width == 0 || test_obj->buffer_height == 0 ) {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    } else {
-        stream->s_config.stream_info->dim.width = DEFAULT_SNAPSHOT_WIDTH;
-        stream->s_config.stream_info->dim.height = DEFAULT_SNAPSHOT_HEIGHT;
-    }
-    stream->s_config.padding_info = cam_cap->padding_info;
-    /* Make offset as zero as CPP will not be used  */
-    stream->s_config.padding_info.offset_info.offset_x = 0;
-    stream->s_config.padding_info.offset_info.offset_y = 0;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-
-}
-
-
-mm_camera_stream_t * mm_app_add_video_stream(mm_camera_test_obj_t *test_obj,
-                                             mm_camera_channel_t *channel,
-                                             mm_camera_buf_notify_t stream_cb,
-                                             void *userdata,
-                                             uint8_t num_bufs)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_stream_t *stream = NULL;
-    cam_capability_t *cam_cap = (cam_capability_t *)(test_obj->cap_buf.buf.buffer);
-
-    cam_stream_size_info_t abc_snap ;
-    memset (&abc_snap , 0, sizeof (cam_stream_size_info_t));
-
-    abc_snap.num_streams = 3;
-    abc_snap.postprocess_mask[2] = 2178;
-    abc_snap.stream_sizes[2].width = DEFAULT_PREVIEW_WIDTH;
-    abc_snap.stream_sizes[2].height = DEFAULT_PREVIEW_HEIGHT;
-    abc_snap.type[2] = CAM_STREAM_TYPE_PREVIEW;
-
-    abc_snap.postprocess_mask[1] = 2178;
-    abc_snap.stream_sizes[1].width = DEFAULT_PREVIEW_WIDTH;
-    abc_snap.stream_sizes[1].height = DEFAULT_PREVIEW_HEIGHT;
-    abc_snap.type[1] = CAM_STREAM_TYPE_VIDEO;
-
-    abc_snap.postprocess_mask[0] = 0;
-    abc_snap.stream_sizes[0].width = DEFAULT_SNAPSHOT_WIDTH;
-    abc_snap.stream_sizes[0].height = DEFAULT_SNAPSHOT_HEIGHT;
-    abc_snap.type[0] = CAM_STREAM_TYPE_SNAPSHOT;
-
-    abc_snap.buffer_info.min_buffers = 7;
-    abc_snap.buffer_info.max_buffers = 7;
-    abc_snap.is_type[0] = IS_TYPE_NONE;
-
-    rc = setmetainfoCommand(test_obj, &abc_snap);
-    if (rc != MM_CAMERA_OK) {
-       LOGE("meta info command snapshot failed\n");
-    }
-
-    stream = mm_app_add_stream(test_obj, channel);
-    if (NULL == stream) {
-        LOGE("add stream failed\n");
-        return NULL;
-    }
-
-    stream->s_config.mem_vtbl.get_bufs = mm_app_stream_initbuf;
-    stream->s_config.mem_vtbl.put_bufs = mm_app_stream_deinitbuf;
-    stream->s_config.mem_vtbl.clean_invalidate_buf =
-            mm_app_stream_clean_invalidate_buf;
-    stream->s_config.mem_vtbl.invalidate_buf = mm_app_stream_invalidate_buf;
-    stream->s_config.mem_vtbl.user_data = (void *)stream;
-    stream->s_config.stream_cb = stream_cb;
-    stream->s_config.stream_cb_sync = NULL;
-    stream->s_config.userdata = userdata;
-    stream->num_of_bufs = num_bufs;
-
-    stream->s_config.stream_info = (cam_stream_info_t *)stream->s_info_buf.buf.buffer;
-    memset(stream->s_config.stream_info, 0, sizeof(cam_stream_info_t));
-    stream->s_config.stream_info->stream_type = CAM_STREAM_TYPE_VIDEO;
-    stream->s_config.stream_info->streaming_mode = CAM_STREAMING_MODE_CONTINUOUS;
-    stream->s_config.stream_info->fmt = DEFAULT_VIDEO_FORMAT;
-    stream->s_config.stream_info->dim.width = DEFAULT_PREVIEW_WIDTH;
-    stream->s_config.stream_info->dim.height = DEFAULT_PREVIEW_HEIGHT;
-    stream->s_config.padding_info = cam_cap->padding_info;
-
-    rc = mm_app_config_stream(test_obj, channel, stream, &stream->s_config);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("config preview stream err=%d\n",  rc);
-        return NULL;
-    }
-
-    return stream;
-}
-
-mm_camera_channel_t * mm_app_add_video_channel(mm_camera_test_obj_t *test_obj)
-{
-    mm_camera_channel_t *channel = NULL;
-    mm_camera_stream_t *stream = NULL;
-
-    channel = mm_app_add_channel(test_obj,
-                                 MM_CHANNEL_TYPE_VIDEO,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    if (NULL == channel) {
-        LOGE("add channel failed");
-        return NULL;
-    }
-
-    stream = mm_app_add_video_stream(test_obj,
-                                     channel,
-                                     mm_app_video_notify_cb,
-                                     (void *)test_obj,
-                                     1);
-    if (NULL == stream) {
-        LOGE("add video stream failed\n");
-        mm_app_del_channel(test_obj, channel);
-        return NULL;
-    }
-
-    return channel;
-}
-
-int mm_app_start_record_preview(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *p_ch = NULL;
-    mm_camera_channel_t *v_ch = NULL;
-    mm_camera_channel_t *s_ch = NULL;
-    mm_camera_stream_t *s_preview = NULL;
-    mm_camera_stream_t *s_metadata = NULL;
-    mm_camera_stream_t *s_main = NULL;
-    mm_camera_stream_t *s_video = NULL;
-
-
-    /* Create Video Channel */
-    v_ch = mm_app_add_channel(test_obj,
-                              MM_CHANNEL_TYPE_VIDEO,
-                              NULL,
-                              NULL,
-                              NULL);
-    if (NULL == v_ch) {
-        LOGE("add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-   /* Add Video Stream */
-    s_video = mm_app_add_video_stream(test_obj,
-                                      v_ch,
-                                      mm_app_video_notify_cb,
-                                      (void*)test_obj,
-                                      VIDEO_BUF_NUM);
-
-    if (NULL == s_video) {
-        LOGE("add video stream failed\n");
-        mm_app_del_channel(test_obj, v_ch);
-        return rc;
-    }
-
-    /* Create Preview Channel */
-    p_ch = mm_app_add_channel(test_obj,
-                              MM_CHANNEL_TYPE_PREVIEW,
-                              NULL,
-                              NULL,
-                              NULL);
-    /* Add Preview stream to Channel */
-    if (NULL == p_ch) {
-        LOGE("add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-
-    s_preview = mm_app_add_video_preview_stream(test_obj,
-                                             p_ch,
-                                             mm_app_preview_notify_cb,
-                                             (void *)test_obj,
-                                             PREVIEW_BUF_NUM);
-    if (NULL == s_preview) {
-        LOGE("add preview stream failed\n");
-        mm_app_del_channel(test_obj, p_ch);
-        return rc;
-    }
-    /* Create Snapshot Channel */
-    s_ch = mm_app_add_channel(test_obj,
-                              MM_CHANNEL_TYPE_SNAPSHOT,
-                              NULL,
-                              NULL,
-                              NULL);
-    if (NULL == s_ch) {
-        LOGE("add channel failed");
-        return -MM_CAMERA_E_GENERAL;
-    }
-
-    /* Add Snapshot Stream */
-    s_main = mm_app_add_video_snapshot_stream(test_obj,
-                                           s_ch,
-                                           mm_app_snapshot_notify_cb,
-                                           (void *)test_obj,
-                                           1,
-                                           1);
-    if (NULL == s_main) {
-        LOGE("add main snapshot stream failed\n");
-        mm_app_del_channel(test_obj, s_ch);
-        return rc;
-    }
-
-
-    /* Add Metadata Stream to preview channel */
-    s_metadata = mm_app_add_metadata_stream(test_obj,
-                                            p_ch,
-                                            mm_app_metadata_notify_cb,
-                                            (void *)test_obj,
-                                            PREVIEW_BUF_NUM);
-
-    if (NULL == s_metadata) {
-        LOGE("add metadata stream failed\n");
-        mm_app_del_channel(test_obj, p_ch);
-        return rc;
-    }
-
-    /* Start Preview Channel */
-    rc = mm_app_start_channel(test_obj, p_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start preview failed rc=%d\n", rc);
-        mm_app_del_channel(test_obj, p_ch);
-        mm_app_del_channel(test_obj, v_ch);
-        mm_app_del_channel(test_obj, s_ch);
-        return rc;
-    }
-
-    /* Start Video Channel */
-    rc = mm_app_start_channel(test_obj, v_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start preview failed rc=%d\n", rc);
-        mm_app_del_channel(test_obj, p_ch);
-        mm_app_del_channel(test_obj, v_ch);
-        mm_app_del_channel(test_obj, s_ch);
-        return rc;
-    }
-
-    return rc;
-}
-
-int mm_app_stop_record_preview(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *p_ch = NULL;
-    mm_camera_channel_t *v_ch = NULL;
-    mm_camera_channel_t *s_ch = NULL;
-
-    p_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_PREVIEW);
-    v_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_VIDEO);
-    s_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_SNAPSHOT);
-
-    rc = mm_app_stop_and_del_channel(test_obj, p_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n", rc);
-    }
-
-    rc = mm_app_stop_and_del_channel(test_obj, v_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n", rc);
-    }
-
-    rc = mm_app_stop_and_del_channel(test_obj, s_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("Stop Preview failed rc=%d\n", rc);
-    }
-
-    return rc;
-}
-
-int mm_app_start_record(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *v_ch = NULL;
-
-    v_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_VIDEO);
-
-    rc = mm_app_start_channel(test_obj, v_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start recording failed rc=%d\n", rc);
-    }
-
-    return rc;
-}
-
-int mm_app_stop_record(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *v_ch = NULL;
-
-    v_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_VIDEO);
-
-    rc = mm_app_stop_channel(test_obj, v_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("stop recording failed rc=%d\n", rc);
-    }
-
-    return rc;
-}
-
-int mm_app_start_live_snapshot(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *s_ch = NULL;
-
-    s_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_SNAPSHOT);
-
-    rc = mm_app_start_channel(test_obj, s_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("start recording failed rc=%d\n", rc);
-    }
-
-    return rc;
-}
-
-int mm_app_stop_live_snapshot(mm_camera_test_obj_t *test_obj)
-{
-    int rc = MM_CAMERA_OK;
-    mm_camera_channel_t *s_ch = NULL;
-
-    s_ch = mm_app_get_channel_by_type(test_obj, MM_CHANNEL_TYPE_SNAPSHOT);
-
-    rc = mm_app_stop_channel(test_obj, s_ch);
-    if (MM_CAMERA_OK != rc) {
-        LOGE("stop recording failed rc=%d\n", rc);
-    }
-
-    return rc;
-}
diff --git a/camera/QCamera2/stack/mm-jpeg-interface/test/Android.mk b/camera/QCamera2/stack/mm-jpeg-interface/test/Android.mk
deleted file mode 100644
index 26f19eb..0000000
--- a/camera/QCamera2/stack/mm-jpeg-interface/test/Android.mk
+++ /dev/null
@@ -1,89 +0,0 @@
-#encoder int test
-OLD_LOCAL_PATH := $(LOCAL_PATH)
-MM_JPEG_TEST_PATH := $(call my-dir)
-
-include $(LOCAL_PATH)/../../common.mk
-include $(CLEAR_VARS)
-LOCAL_PATH := $(MM_JPEG_TEST_PATH)
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter
-LOCAL_CFLAGS += -D_ANDROID_
-
-ifeq ($(strip $(TARGET_USES_ION)),true)
-LOCAL_CFLAGS += -DUSE_ION
-endif
-
-# System header file path prefix
-LOCAL_CFLAGS += -DSYSTEM_HEADER_PREFIX=sys
-
-OMX_HEADER_DIR := frameworks/native/include/media/openmax
-OMX_CORE_DIR := $(MM_JPEG_TEST_PATH)/../../../../mm-image-codec
-
-LOCAL_C_INCLUDES := $(MM_JPEG_TEST_PATH)
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../inc
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../../common
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../../mm-camera-interface/inc
-LOCAL_C_INCLUDES += $(OMX_HEADER_DIR)
-LOCAL_C_INCLUDES += $(OMX_CORE_DIR)/qexif
-LOCAL_C_INCLUDES += $(OMX_CORE_DIR)/qomx_core
-
-LOCAL_C_INCLUDES+= $(kernel_includes)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
-
-LOCAL_SRC_FILES := mm_jpeg_test.c
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-LOCAL_MODULE           := mm-jpeg-interface-test
-LOCAL_VENDOR_MODULE := true
-LOCAL_PRELINK_MODULE   := false
-LOCAL_SHARED_LIBRARIES := libcutils libdl libmmjpeg_interface liblog
-
-include $(BUILD_EXECUTABLE)
-
-
-
-#decoder int test
-
-include $(CLEAR_VARS)
-LOCAL_PATH := $(MM_JPEG_TEST_PATH)
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter
-
-LOCAL_CFLAGS += -D_ANDROID_
-
-ifeq ($(strip $(TARGET_USES_ION)),true)
-LOCAL_CFLAGS += -DUSE_ION
-endif
-
-# System header file path prefix
-LOCAL_CFLAGS += -DSYSTEM_HEADER_PREFIX=sys
-
-OMX_HEADER_DIR := frameworks/native/include/media/openmax
-OMX_CORE_DIR := $(MM_JPEG_TEST_PATH)/../../../../mm-image-codec
-
-LOCAL_C_INCLUDES := $(MM_JPEG_TEST_PATH)
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../inc
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../../common
-LOCAL_C_INCLUDES += $(MM_JPEG_TEST_PATH)/../../mm-camera-interface/inc
-LOCAL_C_INCLUDES += $(OMX_HEADER_DIR)
-LOCAL_C_INCLUDES += $(OMX_CORE_DIR)/qexif
-LOCAL_C_INCLUDES += $(OMX_CORE_DIR)/qomx_core
-
-LOCAL_C_INCLUDES+= $(kernel_includes)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
-
-LOCAL_SRC_FILES := mm_jpegdec_test.c
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-LOCAL_MODULE           := mm-jpegdec-interface-test
-LOCAL_VENDOR_MODULE := true
-LOCAL_PRELINK_MODULE   := false
-LOCAL_SHARED_LIBRARIES := libcutils libdl libmmjpeg_interface liblog
-
-include $(BUILD_EXECUTABLE)
-
-LOCAL_PATH := $(OLD_LOCAL_PATH)
diff --git a/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpeg_test.c b/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpeg_test.c
deleted file mode 100644
index b1ddafc..0000000
--- a/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpeg_test.c
+++ /dev/null
@@ -1,776 +0,0 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// System dependencies
-#include <pthread.h>
-#include <stdlib.h>
-#define TIME_H <SYSTEM_HEADER_PREFIX/time.h>
-#include TIME_H
-
-// JPEG dependencies
-#include "mm_jpeg_interface.h"
-#include "mm_jpeg_ionbuf.h"
-
-// Camera dependencies
-#include "mm_camera_dbg.h"
-
-#define MAX_NUM_BUFS (12)
-#define MAX_NUM_CLIENT (8)
-
-/** DUMP_TO_FILE:
- *  @filename: file name
- *  @p_addr: address of the buffer
- *  @len: buffer length
- *
- *  dump the image to the file
- **/
-#define DUMP_TO_FILE(filename, p_addr, len) ({ \
-  FILE *fp = fopen(filename, "w+"); \
-  if (fp) { \
-    fwrite(p_addr, 1, len, fp); \
-    fclose(fp); \
-  } else { \
-    LOGE("cannot dump image"); \
-  } \
-})
-
-static uint32_t g_count = 1U, g_i;
-
-typedef struct {
-  mm_jpeg_color_format fmt;
-  cam_rational_type_t mult;
-  const char *str;
-} mm_jpeg_intf_test_colfmt_t;
-
-typedef struct {
-  char *filename;
-  int width;
-  int height;
-  char *out_filename;
-  uint32_t burst_mode;
-  uint32_t min_out_bufs;
-  mm_jpeg_intf_test_colfmt_t col_fmt;
-  uint32_t encode_thumbnail;
-  int tmb_width;
-  int tmb_height;
-  int main_quality;
-  int thumb_quality;
-  char *qtable_luma_file;
-  char *qtable_chroma_file;
-  int client_cnt;
-} jpeg_test_input_t;
-
-/* Static constants */
-/*  default Luma Qtable */
-uint8_t DEFAULT_QTABLE_0[QUANT_SIZE] = {
-  16, 11, 10, 16, 24, 40, 51, 61,
-  12, 12, 14, 19, 26, 58, 60, 55,
-  14, 13, 16, 24, 40, 57, 69, 56,
-  14, 17, 22, 29, 51, 87, 80, 62,
-  18, 22, 37, 56, 68, 109, 103, 77,
-  24, 35, 55, 64, 81, 104, 113, 92,
-  49, 64, 78, 87, 103, 121, 120, 101,
-  72, 92, 95, 98, 112, 100, 103, 99
-};
-
-/*  default Chroma Qtable */
-uint8_t DEFAULT_QTABLE_1[QUANT_SIZE] = {
-  17, 18, 24, 47, 99, 99, 99, 99,
-  18, 21, 26, 66, 99, 99, 99, 99,
-  24, 26, 56, 99, 99, 99, 99, 99,
-  47, 66, 99, 99, 99, 99, 99, 99,
-  99, 99, 99, 99, 99, 99, 99, 99,
-  99, 99, 99, 99, 99, 99, 99, 99,
-  99, 99, 99, 99, 99, 99, 99, 99,
-  99, 99, 99, 99, 99, 99, 99, 99
-};
-
-typedef struct {
-  char *filename[MAX_NUM_BUFS];
-  int width;
-  int height;
-  char *out_filename[MAX_NUM_BUFS];
-  pthread_mutex_t lock;
-  pthread_cond_t cond;
-  pthread_t thread_id;
-  buffer_t input[MAX_NUM_BUFS];
-  buffer_t output[MAX_NUM_BUFS];
-  int use_ion;
-  uint32_t handle;
-  mm_jpeg_ops_t ops;
-  uint32_t job_id[MAX_NUM_BUFS];
-  mm_jpeg_encode_params_t params;
-  mm_jpeg_job_t job;
-  uint32_t session_id;
-  uint32_t num_bufs;
-  uint32_t min_out_bufs;
-  size_t buf_filled_len[MAX_NUM_BUFS];
-  mm_dimension pic_size;
-  int ret;
-  int clinet_id;
-} mm_jpeg_intf_test_t;
-
-
-
-static const mm_jpeg_intf_test_colfmt_t color_formats[] =
-{
-  { MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2, {3, 2}, "YCRCBLP_H2V2" },
-  { MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2, {3, 2}, "YCBCRLP_H2V2" },
-  { MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V1, {2, 1}, "YCRCBLP_H2V1" },
-  { MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V1, {2, 1}, "YCBCRLP_H2V1" },
-  { MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V2, {2, 1}, "YCRCBLP_H1V2" },
-  { MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V2, {2, 1}, "YCBCRLP_H1V2" },
-  { MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V1, {3, 1}, "YCRCBLP_H1V1" },
-  { MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V1, {3, 1}, "YCBCRLP_H1V1" }
-};
-
-static jpeg_test_input_t jpeg_input[] = {
-  { QCAMERA_DUMP_FRM_LOCATION"test_1.yuv", 4000, 3008, QCAMERA_DUMP_FRM_LOCATION"test_1.jpg", 0, 0,
-    { MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2, {3, 2}, "YCRCBLP_H2V2" },
-      0, 320, 240, 80, 80, NULL, NULL, 1}
-};
-
-static void mm_jpeg_encode_callback(jpeg_job_status_t status,
-  uint32_t client_hdl,
-  uint32_t jobId,
-  mm_jpeg_output_t *p_output,
-  void *userData)
-{
-  mm_jpeg_intf_test_t *p_obj = (mm_jpeg_intf_test_t *)userData;
-
-  pthread_mutex_lock(&p_obj->lock);
-
-  if (status == JPEG_JOB_STATUS_ERROR) {
-    LOGE("Encode error");
-  } else {
-    int i = 0;
-    for (i = 0; p_obj->job_id[i] && (jobId != p_obj->job_id[i]); i++)
-      ;
-    if (!p_obj->job_id[i]) {
-      LOGE("Cannot find job ID!!!");
-      goto error;
-    }
-    LOGE("Encode success addr %p len %zu idx %d",
-       p_output->buf_vaddr, p_output->buf_filled_len, i);
-
-    p_obj->buf_filled_len[i] = p_output->buf_filled_len;
-    if (p_obj->min_out_bufs) {
-      LOGE("Saving file%s addr %p len %zu",
-           p_obj->out_filename[i],
-          p_output->buf_vaddr, p_output->buf_filled_len);
-      DUMP_TO_FILE(p_obj->out_filename[i], p_output->buf_vaddr,
-        p_output->buf_filled_len);
-    }
-  }
-  g_i++;
-
-error:
-
-  if (g_i >= g_count) {
-    LOGE("Signal the thread");
-    pthread_cond_signal(&p_obj->cond);
-  }
-  pthread_mutex_unlock(&p_obj->lock);
-}
-
-int mm_jpeg_test_alloc(buffer_t *p_buffer, int use_pmem)
-{
-  int ret = 0;
-  /*Allocate buffers*/
-  if (use_pmem) {
-    p_buffer->addr = (uint8_t *)buffer_allocate(p_buffer, 0);
-    if (NULL == p_buffer->addr) {
-      LOGE("Error");
-      return -1;
-    }
-  } else {
-    /* Allocate heap memory */
-    p_buffer->addr = (uint8_t *)malloc(p_buffer->size);
-    if (NULL == p_buffer->addr) {
-      LOGE("Error");
-      return -1;
-    }
-  }
-  return ret;
-}
-
-void mm_jpeg_test_free(buffer_t *p_buffer)
-{
-  if (p_buffer->addr == NULL)
-    return;
-
-  if (p_buffer->p_pmem_fd >= 0)
-    buffer_deallocate(p_buffer);
-  else
-    free(p_buffer->addr);
-
-  memset(p_buffer, 0x0, sizeof(buffer_t));
-}
-
-int mm_jpeg_test_read(mm_jpeg_intf_test_t *p_obj, uint32_t idx)
-{
-  FILE *fp = NULL;
-  size_t file_size = 0;
-  fp = fopen(p_obj->filename[idx], "rb");
-  if (!fp) {
-    LOGE("error");
-    return -1;
-  }
-  fseek(fp, 0, SEEK_END);
-  file_size = (size_t)ftell(fp);
-  fseek(fp, 0, SEEK_SET);
-  LOGE("input file size is %zu buf_size %zu",
-     file_size, p_obj->input[idx].size);
-
-  if (p_obj->input[idx].size > file_size) {
-    LOGE("error");
-    fclose(fp);
-    return -1;
-  }
-  fread(p_obj->input[idx].addr, 1, p_obj->input[idx].size, fp);
-  fclose(fp);
-  return 0;
-}
-
-/** mm_jpeg_test_read_qtable:
- *
- *  Arguments:
- *    @filename: Qtable filename
- *    @chroma_flag: Flag indicating chroma qtable
- *
- *  Return:
- *    0 success, failure otherwise
- *
- *  Description:
- *    Reads qtable from file and sets it in appropriate qtable
- *    based on flag.
- **/
-int mm_jpeg_test_read_qtable(const char *filename, bool chroma_flag)
-{
-  FILE *fp = NULL;
-  int i;
-
-  if (filename == NULL)
-    return 0;
-
-  fp = fopen(filename, "r");
-  if (!fp) {
-    LOGE("error cannot open file");
-    return -1;
-  }
-
-  if (chroma_flag) {
-    for (i = 0; i < QUANT_SIZE; i++)
-      fscanf(fp, "%hhu,", &DEFAULT_QTABLE_1[i]);
-  } else {
-    for (i = 0; i < QUANT_SIZE; i++)
-      fscanf(fp, "%hhu,", &DEFAULT_QTABLE_0[i]);
-  }
-
-  fclose(fp);
-  return 0;
-}
-
-static int encode_init(jpeg_test_input_t *p_input, mm_jpeg_intf_test_t *p_obj,
-  int client_id)
-{
-  int rc = -1;
-  size_t size = (size_t)(p_input->width * p_input->height);
-  mm_jpeg_encode_params_t *p_params = &p_obj->params;
-  mm_jpeg_encode_job_t *p_job_params = &p_obj->job.encode_job;
-  uint32_t i = 0;
-  uint32_t burst_mode = p_input->burst_mode;
-  jpeg_test_input_t *p_in = p_input;
-
-  do {
-    p_obj->filename[i] = p_in->filename;
-    p_obj->width = p_input->width;
-    p_obj->height = p_input->height;
-    p_obj->out_filename[i] = p_in->out_filename;
-    p_obj->use_ion = 1;
-    p_obj->min_out_bufs = p_input->min_out_bufs;
-
-    /* allocate buffers */
-    p_obj->input[i].size = size * (size_t)p_input->col_fmt.mult.numerator /
-        (size_t)p_input->col_fmt.mult.denominator;
-    rc = mm_jpeg_test_alloc(&p_obj->input[i], p_obj->use_ion);
-    if (rc) {
-      LOGE("Error");
-      return -1;
-    }
-
-
-    rc = mm_jpeg_test_read(p_obj, i);
-    if (rc) {
-      LOGE("Error, unable to read input image");
-      return -1;
-    }
-
-    mm_jpeg_test_read_qtable(p_input->qtable_luma_file, false);
-    if (rc) {
-      LOGE("Error, unable to read luma qtable");
-      return -1;
-    }
-
-    mm_jpeg_test_read_qtable(p_input->qtable_chroma_file, true);
-    if (rc) {
-      LOGE("Error, unable to read chrome qtable");
-      return -1;
-    }
-
-    /* src buffer config*/
-    p_params->src_main_buf[i].buf_size = p_obj->input[i].size;
-    p_params->src_main_buf[i].buf_vaddr = p_obj->input[i].addr;
-    p_params->src_main_buf[i].fd = p_obj->input[i].p_pmem_fd;
-    p_params->src_main_buf[i].index = i;
-    p_params->src_main_buf[i].format = MM_JPEG_FMT_YUV;
-    p_params->src_main_buf[i].offset.mp[0].len = (uint32_t)size;
-    p_params->src_main_buf[i].offset.mp[0].stride = p_input->width;
-    p_params->src_main_buf[i].offset.mp[0].scanline = p_input->height;
-    p_params->src_main_buf[i].offset.mp[1].len = (uint32_t)(size >> 1);
-
-    /* src buffer config*/
-    p_params->src_thumb_buf[i].buf_size = p_obj->input[i].size;
-    p_params->src_thumb_buf[i].buf_vaddr = p_obj->input[i].addr;
-    p_params->src_thumb_buf[i].fd = p_obj->input[i].p_pmem_fd;
-    p_params->src_thumb_buf[i].index = i;
-    p_params->src_thumb_buf[i].format = MM_JPEG_FMT_YUV;
-    p_params->src_thumb_buf[i].offset.mp[0].len = (uint32_t)size;
-    p_params->src_thumb_buf[i].offset.mp[0].stride = p_input->width;
-    p_params->src_thumb_buf[i].offset.mp[0].scanline = p_input->height;
-    p_params->src_thumb_buf[i].offset.mp[1].len = (uint32_t)(size >> 1);
-
-
-    i++;
-  } while((++p_in)->filename);
-
-  p_obj->num_bufs = i;
-
-  pthread_mutex_init(&p_obj->lock, NULL);
-  pthread_cond_init(&p_obj->cond, NULL);
-
-
-  /* set encode parameters */
-  p_params->jpeg_cb = mm_jpeg_encode_callback;
-  p_params->userdata = p_obj;
-  p_params->color_format = p_input->col_fmt.fmt;
-  p_params->thumb_color_format = p_input->col_fmt.fmt;
-
-  if (p_obj->min_out_bufs) {
-    p_params->num_dst_bufs = 2;
-  } else {
-    p_params->num_dst_bufs = p_obj->num_bufs;
-  }
-
-  for (i = 0; i < (uint32_t)p_params->num_dst_bufs; i++) {
-    p_obj->output[i].size = size * 3/2;
-    rc = mm_jpeg_test_alloc(&p_obj->output[i], 0);
-    if (rc) {
-      LOGE("Error");
-      return -1;
-    }
-    /* dest buffer config */
-    p_params->dest_buf[i].buf_size = p_obj->output[i].size;
-    p_params->dest_buf[i].buf_vaddr = p_obj->output[i].addr;
-    p_params->dest_buf[i].fd = p_obj->output[i].p_pmem_fd;
-    p_params->dest_buf[i].index = i;
-  }
-
-
-  p_params->num_src_bufs = p_obj->num_bufs;
-  p_params->num_tmb_bufs = 0;
-  g_count = p_params->num_src_bufs;
-
-  p_params->encode_thumbnail = p_input->encode_thumbnail;
-  if (p_params->encode_thumbnail) {
-      p_params->num_tmb_bufs = p_obj->num_bufs;
-  }
-  p_params->quality = (uint32_t)p_input->main_quality;
-  p_params->thumb_quality = (uint32_t)p_input->thumb_quality;
-
-  p_job_params->dst_index = 0;
-  p_job_params->src_index = 0;
-  p_job_params->rotation = 0;
-
-  /* main dimension */
-  p_job_params->main_dim.src_dim.width = p_obj->width;
-  p_job_params->main_dim.src_dim.height = p_obj->height;
-  p_job_params->main_dim.dst_dim.width = p_obj->width;
-  p_job_params->main_dim.dst_dim.height = p_obj->height;
-  p_job_params->main_dim.crop.top = 0;
-  p_job_params->main_dim.crop.left = 0;
-  p_job_params->main_dim.crop.width = p_obj->width;
-  p_job_params->main_dim.crop.height = p_obj->height;
-
-  p_params->main_dim  = p_job_params->main_dim;
-
-  /* thumb dimension */
-  p_job_params->thumb_dim.src_dim.width = p_obj->width;
-  p_job_params->thumb_dim.src_dim.height = p_obj->height;
-  p_job_params->thumb_dim.dst_dim.width = p_input->tmb_width;
-  p_job_params->thumb_dim.dst_dim.height = p_input->tmb_height;
-  p_job_params->thumb_dim.crop.top = 0;
-  p_job_params->thumb_dim.crop.left = 0;
-  p_job_params->thumb_dim.crop.width = 0;
-  p_job_params->thumb_dim.crop.height = 0;
-
-  p_params->thumb_dim  = p_job_params->thumb_dim;
-
-  p_job_params->exif_info.numOfEntries = 0;
-  p_params->burst_mode = burst_mode;
-
-  /* Qtable */
-  p_job_params->qtable[0].eQuantizationTable =
-    OMX_IMAGE_QuantizationTableLuma;
-  p_job_params->qtable[1].eQuantizationTable =
-    OMX_IMAGE_QuantizationTableChroma;
-  p_job_params->qtable_set[0] = 1;
-  p_job_params->qtable_set[1] = 1;
-
-  for (i = 0; i < QUANT_SIZE; i++) {
-    p_job_params->qtable[0].nQuantizationMatrix[i] = DEFAULT_QTABLE_0[i];
-    p_job_params->qtable[1].nQuantizationMatrix[i] = DEFAULT_QTABLE_1[i];
-  }
-
-  p_obj->pic_size.w = (uint32_t)p_input->width;
-  p_obj->pic_size.h = (uint32_t)p_input->height;
-
-  p_obj->clinet_id = client_id;
-
-  return 0;
-}
-
-static void *encode_test(void *data)
-{
-  int rc = 0;
-  mm_jpeg_intf_test_t *jpeg_obj = (mm_jpeg_intf_test_t *)data;
-  char file_name[64];
-
-  uint32_t i = 0;
-  jpeg_obj->handle = jpeg_open(&jpeg_obj->ops, NULL, jpeg_obj->pic_size, NULL);
-  if (jpeg_obj->handle == 0) {
-    LOGE("Error");
-    jpeg_obj->ret = -1;
-    goto end;
-  }
-
-  rc = jpeg_obj->ops.create_session(jpeg_obj->handle, &jpeg_obj->params,
-    &jpeg_obj->job.encode_job.session_id);
-  if (jpeg_obj->job.encode_job.session_id == 0) {
-    LOGE("Error");
-    jpeg_obj->ret = -1;
-    goto end;
-  }
-
-  for (i = 0; i < jpeg_obj->num_bufs; i++) {
-    jpeg_obj->job.job_type = JPEG_JOB_TYPE_ENCODE;
-    jpeg_obj->job.encode_job.src_index = (int32_t) i;
-    jpeg_obj->job.encode_job.dst_index = (int32_t) i;
-    jpeg_obj->job.encode_job.thumb_index = (uint32_t) i;
-
-    if (jpeg_obj->params.burst_mode && jpeg_obj->min_out_bufs) {
-      jpeg_obj->job.encode_job.dst_index = -1;
-    }
-
-    rc = jpeg_obj->ops.start_job(&jpeg_obj->job, &jpeg_obj->job_id[i]);
-    if (rc) {
-      LOGE("Error");
-      jpeg_obj->ret = rc;
-      goto end;
-    }
-  }
-  jpeg_obj->job_id[i] = 0;
-
-  /*
-  usleep(5);
-  jpeg_obj->ops.abort_job(jpeg_obj->job_id[0]);
-  */
-  pthread_mutex_lock(&jpeg_obj->lock);
-  pthread_cond_wait(&jpeg_obj->cond, &jpeg_obj->lock);
-  pthread_mutex_unlock(&jpeg_obj->lock);
-
-  jpeg_obj->ops.destroy_session(jpeg_obj->job.encode_job.session_id);
-  jpeg_obj->ops.close(jpeg_obj->handle);
-
-end:
-  for (i = 0; i < jpeg_obj->num_bufs; i++) {
-    if (!jpeg_obj->min_out_bufs) {
-      // Save output files
-      LOGE("Saving file%s addr %p len %zu",
-          jpeg_obj->out_filename[i],
-          jpeg_obj->output[i].addr, jpeg_obj->buf_filled_len[i]);
-
-      snprintf(file_name, sizeof(file_name), "%s_%d.jpg",
-        jpeg_obj->out_filename[i], jpeg_obj->clinet_id);
-      fprintf(stderr, "Output file for client %d = %s\n",
-        jpeg_obj->clinet_id, file_name);
-
-      DUMP_TO_FILE(file_name, jpeg_obj->output[i].addr,
-        jpeg_obj->buf_filled_len[i]);
-    }
-    mm_jpeg_test_free(&jpeg_obj->input[i]);
-    mm_jpeg_test_free(&jpeg_obj->output[i]);
-  }
-  return NULL;
-}
-
-#define MAX_FILE_CNT (20)
-static int mm_jpeg_test_get_input(int argc, char *argv[],
-    jpeg_test_input_t *p_test)
-{
-  int c;
-  size_t in_file_cnt = 0, out_file_cnt = 0, i;
-  int idx = 0;
-  jpeg_test_input_t *p_test_base = p_test;
-
-  char *in_files[MAX_FILE_CNT];
-  char *out_files[MAX_FILE_CNT];
-
-  while ((c = getopt(argc, argv, "-I:O:W:H:F:BTx:y:Q:J:K:C:q:")) != -1) {
-    switch (c) {
-    case 'B':
-      fprintf(stderr, "%-25s\n", "Using burst mode");
-      p_test->burst_mode = 1;
-      break;
-    case 'I':
-      for (idx = optind - 1; idx < argc; idx++) {
-        if (argv[idx][0] == '-') {
-          break;
-        }
-        in_files[in_file_cnt++] = argv[idx];
-      }
-      optind = idx -1;
-
-      break;
-    case 'O':
-      for (idx = optind - 1; idx < argc; idx++) {
-        if (argv[idx][0] == '-') {
-          break;
-        }
-        out_files[out_file_cnt++] = argv[idx];
-      }
-      optind = idx -1;
-
-      break;
-    case 'W':
-      p_test->width = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Width: ", p_test->width);
-      break;
-    case 'H':
-      p_test->height = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Height: ", p_test->height);
-      break;
-    case 'F':
-      p_test->col_fmt = color_formats[atoi(optarg)];
-      fprintf(stderr, "%-25s%s\n", "Format: ", p_test->col_fmt.str);
-      break;
-    case 'M':
-      p_test->min_out_bufs = 1;
-      fprintf(stderr, "%-25s\n", "Using minimum number of output buffers");
-      break;
-    case 'T':
-      p_test->encode_thumbnail = 1;
-      fprintf(stderr, "%-25s\n", "Encode thumbnail");
-      break;
-    case 'x':
-      p_test->tmb_width = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Tmb Width: ", p_test->tmb_width);
-      break;
-    case 'y':
-      p_test->tmb_height = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Tmb Height: ", p_test->tmb_height);
-      break;
-    case 'Q':
-      p_test->main_quality = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Main quality: ", p_test->main_quality);
-      break;
-    case 'q':
-      p_test->thumb_quality = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Thumb quality: ", p_test->thumb_quality);
-      break;
-    case 'J':
-      p_test->qtable_luma_file = optarg;
-      fprintf(stderr, "%-25s%s\n", "Qtable luma path",
-        p_test->qtable_luma_file);
-      break;
-    case 'K':
-      p_test->qtable_chroma_file = optarg;
-      fprintf(stderr, "%-25s%s\n", "Qtable chroma path",
-        p_test->qtable_chroma_file);
-      break;
-    case 'C':
-      p_test->client_cnt = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Number of clients ",
-        p_test->client_cnt);
-    default:;
-    }
-  }
-  fprintf(stderr, "Infiles: %zu Outfiles: %zu\n", in_file_cnt, out_file_cnt);
-
-  if (p_test->client_cnt > MAX_NUM_CLIENT) {
-    fprintf(stderr, "Clients requested exceeds max limit %d\n",
-      MAX_NUM_CLIENT);
-    return 1;
-  }
-  if (in_file_cnt > out_file_cnt) {
-    fprintf(stderr, "%-25s\n", "Insufficient number of output files!");
-    return 1;
-  }
-
-  // Discard the extra out files
-  out_file_cnt = in_file_cnt;
-
-  p_test = realloc(p_test, (in_file_cnt + 1) * sizeof(*p_test));
-  if (!p_test) {
-    LOGE("Error");
-    return 1;
-  }
-  memset(p_test+1, 0, (in_file_cnt) * sizeof(*p_test));
-
-  for (i = 0; i < in_file_cnt; i++, p_test++) {
-    memcpy(p_test, p_test_base, sizeof(*p_test));
-    p_test->filename = in_files[i];
-    p_test->out_filename = out_files[i];
-    fprintf(stderr, "Inf: %s Outf: %s\n", in_files[i], out_files[i]);
-  }
-
-  return 0;
-}
-
-static void mm_jpeg_test_print_usage()
-{
-  fprintf(stderr, "Usage: program_name [options]\n");
-  fprintf(stderr, "Mandatory options:\n");
-  fprintf(stderr, "  -I FILE1 [FILE2] [FILEN]\tList of input files\n");
-  fprintf(stderr, "  -O FILE1 [FILE2] [FILEN]\tList of output files\n");
-  fprintf(stderr, "  -W WIDTH\t\tOutput image width\n");
-  fprintf(stderr, "  -H HEIGHT\t\tOutput image height\n");
-  fprintf(stderr, "  -F \t\tColor format: \n");
-  fprintf(stderr, "\t\t\t\t%s (0), %s (1), %s (2) %s (3)\n"
-      "\t\t\t\t%s (4), %s (5), %s (6) %s (7)\n ",
-      color_formats[0].str, color_formats[1].str,
-      color_formats[2].str, color_formats[3].str,
-      color_formats[4].str, color_formats[5].str,
-      color_formats[6].str, color_formats[7].str);
-  fprintf(stderr, "Optional:\n");
-  fprintf(stderr, "  -T \t\Encode thumbnail\n");
-  fprintf(stderr, "  -x TMB_WIDTH\t\tThumbnail width\n");
-  fprintf(stderr, "  -y TMB_HEIGHT\t\tThumbnail height\n");
-  fprintf(stderr, "  -Q MAIN_QUALITY\t\tMain image quality\n");
-  fprintf(stderr, "  -q TMB_QUALITY\t\tThumbnail image quality\n");
-  fprintf(stderr, "  -B \t\tBurst mode. Utilize both encoder engines on"
-          "supported targets\n");
-  fprintf(stderr, "  -M \t\tUse minimum number of output buffers \n");
-  fprintf(stderr, "  -J \t\tLuma QTable filename. Comma separated 8x8"
-    " matrix\n");
-  fprintf(stderr, "  -K \t\tChroma QTable filename. Comma separated"
-    " 8x8 matrix\n");
-  fprintf(stderr, "  -C \t\tNumber of clients to run in parllel\n");
-  fprintf(stderr, "\n");
-}
-
-/** main:
- *
- *  Arguments:
- *    @argc
- *    @argv
- *
- *  Return:
- *       0 or -ve values
- *
- *  Description:
- *       main function
- *
- **/
-int main(int argc, char* argv[])
-{
-  jpeg_test_input_t *p_test_input;
-  mm_jpeg_intf_test_t client[MAX_NUM_CLIENT];
-  int ret = 0;
-  int i = 0;
-  int thread_cnt = 0;
-
-  if (argc > 1) {
-    p_test_input = calloc(2, sizeof(*p_test_input));
-    if (!p_test_input) {
-      LOGE("Error");
-      goto exit;
-    }
-    memcpy(p_test_input, &jpeg_input[0], sizeof(*p_test_input));
-    ret = mm_jpeg_test_get_input(argc, argv, p_test_input);
-    if (ret) {
-      LOGE("Error");
-      goto exit;
-    }
-  } else {
-    mm_jpeg_test_print_usage();
-    return 1;
-  }
-
-  for (i = 0; i < p_test_input->client_cnt; i++) {
-    memset(&client[i], 0x0, sizeof(mm_jpeg_intf_test_t));
-    ret = encode_init(p_test_input, &client[i], i);
-    if (ret) {
-      LOGE("Error");
-      return -1;
-    }
-
-    ret = pthread_create(&client[i].thread_id, NULL, encode_test,
-      &client[i]);
-    if (ret != 0) {
-       fprintf(stderr, "Error in thread creation\n");
-       break;
-    }
-  }
-
-  thread_cnt = i;
-  for (i = 0; i < thread_cnt; i++) {
-    pthread_join(client[i].thread_id, NULL);
-  }
-
-exit:
-  for (i = 0; i < thread_cnt; i++) {
-    if (!client[i].ret) {
-      fprintf(stderr, "%-25s %d %s\n", "Client", i, "Success!");
-    } else {
-      fprintf(stderr, "%-25s %d %s\n", "Client", i, "Fail!");
-    }
-  }
-
-  if (argc > 1) {
-    if (p_test_input) {
-      free(p_test_input);
-      p_test_input = NULL;
-    }
-  }
-
-  return ret;
-}
-
-
diff --git a/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpegdec_test.c b/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpegdec_test.c
deleted file mode 100644
index beb62f5..0000000
--- a/camera/QCamera2/stack/mm-jpeg-interface/test/mm_jpegdec_test.c
+++ /dev/null
@@ -1,479 +0,0 @@
-/* Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// System dependencies
-#include <pthread.h>
-#include <stdlib.h>
-#define TIME_H <SYSTEM_HEADER_PREFIX/time.h>
-#include TIME_H
-
-// JPEG dependencies
-#include "mm_jpeg_interface.h"
-#include "mm_jpeg_ionbuf.h"
-
-// Camera dependencies
-#include "mm_camera_dbg.h"
-
-#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
-#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
-#define CLAMP(x, min, max) MIN(MAX((x), (min)), (max))
-
-#define TIME_IN_US(r) ((uint64_t)r.tv_sec * 1000000LL + (uint64_t)r.tv_usec)
-struct timeval dtime[2];
-
-
-/** DUMP_TO_FILE:
- *  @filename: file name
- *  @p_addr: address of the buffer
- *  @len: buffer length
- *
- *  dump the image to the file
- **/
-#define DUMP_TO_FILE(filename, p_addr, len) ({ \
-  size_t rc = 0; \
-  FILE *fp = fopen(filename, "w+"); \
-  if (fp) { \
-    rc = fwrite(p_addr, 1, len, fp); \
-    fclose(fp); \
-  } else { \
-    LOGE("cannot dump image"); \
-  } \
-})
-
-static int g_count = 1, g_i;
-
-typedef struct {
-  char *filename;
-  int width;
-  int height;
-  char *out_filename;
-  int format;
-} jpeg_test_input_t;
-
-typedef struct {
-  char *filename;
-  int width;
-  int height;
-  char *out_filename;
-  pthread_mutex_t lock;
-  pthread_cond_t cond;
-  buffer_t input;
-  buffer_t output;
-  int use_ion;
-  uint32_t handle;
-  mm_jpegdec_ops_t ops;
-  uint32_t job_id[5];
-  mm_jpeg_decode_params_t params;
-  mm_jpeg_job_t job;
-  uint32_t session_id;
-} mm_jpegdec_intf_test_t;
-
-typedef struct {
-  char *format_str;
-  int eColorFormat;
-} mm_jpegdec_col_fmt_t;
-
-#define ARR_SZ(a) (sizeof(a)/sizeof(a[0]))
-
-static const mm_jpegdec_col_fmt_t col_formats[] =
-{
-  { "YCRCBLP_H2V2",      (int)MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2 },
-  { "YCBCRLP_H2V2",      (int)MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2 },
-  { "YCRCBLP_H2V1",      (int)MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V1 },
-  { "YCBCRLP_H2V1",      (int)MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V1 },
-  { "YCRCBLP_H1V2",      (int)MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V2 },
-  { "YCBCRLP_H1V2",      (int)MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V2 },
-  { "YCRCBLP_H1V1",      (int)MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V1 },
-  { "YCBCRLP_H1V1",      (int)MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V1 }
-};
-
-static void mm_jpegdec_decode_callback(jpeg_job_status_t status,
-  uint32_t client_hdl,
-  uint32_t jobId,
-  mm_jpeg_output_t *p_output,
-  void *userData)
-{
-  mm_jpegdec_intf_test_t *p_obj = (mm_jpegdec_intf_test_t *)userData;
-
-  if (status == JPEG_JOB_STATUS_ERROR) {
-    LOGE("Decode error");
-  } else {
-    gettimeofday(&dtime[1], NULL);
-    LOGE("Decode time %llu ms",
-      ((TIME_IN_US(dtime[1]) - TIME_IN_US(dtime[0]))/1000));
-
-    LOGE("Decode success file%s addr %p len %zu",
-       p_obj->out_filename,
-      p_output->buf_vaddr, p_output->buf_filled_len);
-    DUMP_TO_FILE(p_obj->out_filename, p_output->buf_vaddr, p_output->buf_filled_len);
-  }
-  g_i++;
-  if (g_i >= g_count) {
-    LOGE("Signal the thread");
-    pthread_cond_signal(&p_obj->cond);
-  }
-}
-
-int mm_jpegdec_test_alloc(buffer_t *p_buffer, int use_pmem)
-{
-  int ret = 0;
-  /*Allocate buffers*/
-  if (use_pmem) {
-    p_buffer->addr = (uint8_t *)buffer_allocate(p_buffer, 0);
-    if (NULL == p_buffer->addr) {
-      LOGE("Error");
-      return -1;
-    }
-  } else {
-    /* Allocate heap memory */
-    p_buffer->addr = (uint8_t *)malloc(p_buffer->size);
-    if (NULL == p_buffer->addr) {
-      LOGE("Error");
-      return -1;
-    }
-  }
-  return ret;
-}
-
-void mm_jpegdec_test_free(buffer_t *p_buffer)
-{
-  if (p_buffer->addr == NULL)
-    return;
-
-  if (p_buffer->p_pmem_fd >= 0)
-    buffer_deallocate(p_buffer);
-  else
-    free(p_buffer->addr);
-
-  memset(p_buffer, 0x0, sizeof(buffer_t));
-}
-
-int mm_jpegdec_test_read(mm_jpegdec_intf_test_t *p_obj)
-{
-  int rc = 0;
-  FILE *fp = NULL;
-  size_t file_size = 0;
-  fp = fopen(p_obj->filename, "rb");
-  if (!fp) {
-    LOGE("error");
-    return -1;
-  }
-  fseek(fp, 0, SEEK_END);
-  file_size = (size_t)ftell(fp);
-  fseek(fp, 0, SEEK_SET);
-
-  LOGE("input file size is %zu",
-     file_size);
-
-  p_obj->input.size = file_size;
-
-  /* allocate buffers */
-  rc = mm_jpegdec_test_alloc(&p_obj->input, p_obj->use_ion);
-  if (rc) {
-    LOGE("Error");
-    return -1;
-  }
-
-  fread(p_obj->input.addr, 1, p_obj->input.size, fp);
-  fclose(fp);
-  return 0;
-}
-
-void chromaScale(mm_jpeg_color_format format, double *cScale)
-{
-  double scale;
-
-  switch(format) {
-    case MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V2:
-    case MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V2:
-      scale = 1.5;
-      break;
-    case MM_JPEG_COLOR_FORMAT_YCRCBLP_H2V1:
-    case MM_JPEG_COLOR_FORMAT_YCBCRLP_H2V1:
-    case MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V2:
-    case MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V2:
-      scale = 2.0;
-      break;
-    case MM_JPEG_COLOR_FORMAT_YCRCBLP_H1V1:
-    case MM_JPEG_COLOR_FORMAT_YCBCRLP_H1V1:
-      scale = 3.0;
-      break;
-    case MM_JPEG_COLOR_FORMAT_MONOCHROME:
-      scale = 1.0;
-      break;
-    default:
-      scale = 0;
-      LOGE("color format Error");
-    }
-
-  *cScale = scale;
-}
-
-static int decode_init(jpeg_test_input_t *p_input, mm_jpegdec_intf_test_t *p_obj)
-{
-  int rc = -1;
-  size_t size = (size_t)(CEILING16(p_input->width) * CEILING16(p_input->height));
-  double cScale;
-  mm_jpeg_decode_params_t *p_params = &p_obj->params;
-  mm_jpeg_decode_job_t *p_job_params = &p_obj->job.decode_job;
-
-  p_obj->filename = p_input->filename;
-  p_obj->width = p_input->width;
-  p_obj->height = p_input->height;
-  p_obj->out_filename = p_input->out_filename;
-  p_obj->use_ion = 1;
-
-  pthread_mutex_init(&p_obj->lock, NULL);
-  pthread_cond_init(&p_obj->cond, NULL);
-
-  chromaScale(p_input->format, &cScale);
-  p_obj->output.size = (size_t)((double)size * cScale);
-  rc = mm_jpegdec_test_alloc(&p_obj->output, p_obj->use_ion);
-  if (rc) {
-    LOGE("Error");
-    return -1;
-  }
-
-  rc = mm_jpegdec_test_read(p_obj);
-  if (rc) {
-    LOGE("Error");
-    return -1;
-  }
-
-  /* set encode parameters */
-  p_params->jpeg_cb = mm_jpegdec_decode_callback;
-  p_params->userdata = p_obj;
-  p_params->color_format = p_input->format;
-
-  /* dest buffer config */
-  p_params->dest_buf[0].buf_size = p_obj->output.size;
-  p_params->dest_buf[0].buf_vaddr = p_obj->output.addr;
-  p_params->dest_buf[0].fd = p_obj->output.p_pmem_fd;
-  p_params->dest_buf[0].format = MM_JPEG_FMT_YUV;
-  p_params->dest_buf[0].offset.mp[0].len = (uint32_t)size;
-  p_params->dest_buf[0].offset.mp[1].len =
-    (uint32_t)((double)size * (cScale - 1.0));
-  p_params->dest_buf[0].offset.mp[0].stride = CEILING16(p_input->width);
-  p_params->dest_buf[0].offset.mp[0].scanline = CEILING16(p_input->height);
-  p_params->dest_buf[0].offset.mp[1].stride = CEILING16(p_input->width);
-  p_params->dest_buf[0].offset.mp[1].scanline = CEILING16(p_input->height);
-  p_params->dest_buf[0].index = 0;
-  p_params->num_dst_bufs = 1;
-
-  /* src buffer config*/
-  p_params->src_main_buf[0].buf_size = p_obj->input.size;
-  p_params->src_main_buf[0].buf_vaddr = p_obj->input.addr;
-  p_params->src_main_buf[0].fd = p_obj->input.p_pmem_fd;
-  p_params->src_main_buf[0].index = 0;
-  p_params->src_main_buf[0].format = MM_JPEG_FMT_BITSTREAM;
-  /*
-  p_params->src_main_buf[0].offset.mp[0].len = size;
-  p_params->src_main_buf[0].offset.mp[1].len = size >> 1;
-  */
-  p_params->num_src_bufs = 1;
-
-  p_job_params->dst_index = 0;
-  p_job_params->src_index = 0;
-  p_job_params->rotation = 0;
-
-  /* main dimension */
-  p_job_params->main_dim.src_dim.width = p_obj->width;
-  p_job_params->main_dim.src_dim.height = p_obj->height;
-  p_job_params->main_dim.dst_dim.width = p_obj->width;
-  p_job_params->main_dim.dst_dim.height = p_obj->height;
-  p_job_params->main_dim.crop.top = 0;
-  p_job_params->main_dim.crop.left = 0;
-  p_job_params->main_dim.crop.width = p_obj->width;
-  p_job_params->main_dim.crop.height = p_obj->height;
-
-
-  return 0;
-}
-
-void omx_test_dec_print_usage()
-{
-  fprintf(stderr, "Usage: program_name [options]\n");
-  fprintf(stderr, "Mandatory options:\n");
-  fprintf(stderr, "  -I FILE\t\tPath to the input file.\n");
-  fprintf(stderr, "  -O FILE\t\tPath for the output file.\n");
-  fprintf(stderr, "  -W WIDTH\t\tOutput image width\n");
-  fprintf(stderr, "  -H HEIGHT\t\tOutput image height\n");
-  fprintf(stderr, "Optional:\n");
-  fprintf(stderr, "  -F FORMAT\t\tDefault image format:\n");
-  fprintf(stderr, "\t\t\t\t%s (0), %s (1), %s (2) %s (3)\n"
-    "%s (4), %s (5), %s (6) %s (7)\n",
-    col_formats[0].format_str, col_formats[1].format_str,
-    col_formats[2].format_str, col_formats[3].format_str,
-    col_formats[4].format_str, col_formats[5].format_str,
-    col_formats[6].format_str, col_formats[7].format_str
-    );
-
-  fprintf(stderr, "\n");
-}
-
-static int mm_jpegdec_test_get_input(int argc, char *argv[],
-    jpeg_test_input_t *p_test)
-{
-  int c;
-
-  while ((c = getopt(argc, argv, "I:O:W:H:F:")) != -1) {
-    switch (c) {
-    case 'O':
-      p_test->out_filename = optarg;
-      fprintf(stderr, "%-25s%s\n", "Output image path",
-        p_test->out_filename);
-      break;
-    case 'I':
-      p_test->filename = optarg;
-      fprintf(stderr, "%-25s%s\n", "Input image path", p_test->filename);
-      break;
-    case 'W':
-      p_test->width = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Default width", p_test->width);
-      break;
-    case 'H':
-      p_test->height = atoi(optarg);
-      fprintf(stderr, "%-25s%d\n", "Default height", p_test->height);
-      break;
-    case 'F': {
-      int format = 0;
-      format = atoi(optarg);
-      int num_formats = ARR_SZ(col_formats);
-      format = CLAMP(format, 0, num_formats);
-      p_test->format = col_formats[format].eColorFormat;
-      fprintf(stderr, "%-25s%s\n", "Default image format",
-        col_formats[format].format_str);
-      break;
-    }
-    default:;
-    }
-  }
-  if (!p_test->filename || !p_test->filename || !p_test->width ||
-      !p_test->height) {
-    fprintf(stderr, "Missing required arguments.\n");
-    omx_test_dec_print_usage();
-    return -1;
-  }
-  return 0;
-}
-
-static int decode_test(jpeg_test_input_t *p_input)
-{
-  int rc = 0;
-  mm_jpegdec_intf_test_t jpeg_obj;
-  int i = 0;
-
-  memset(&jpeg_obj, 0x0, sizeof(jpeg_obj));
-  rc = decode_init(p_input, &jpeg_obj);
-  if (rc) {
-    LOGE("Error");
-    return -1;
-  }
-
-  jpeg_obj.handle = jpegdec_open(&jpeg_obj.ops);
-  if (jpeg_obj.handle == 0) {
-    LOGE("Error");
-    goto end;
-  }
-
-  rc = jpeg_obj.ops.create_session(jpeg_obj.handle, &jpeg_obj.params,
-    &jpeg_obj.job.decode_job.session_id);
-  if (jpeg_obj.job.decode_job.session_id == 0) {
-    LOGE("Error");
-    goto end;
-  }
-
-  for (i = 0; i < g_count; i++) {
-    jpeg_obj.job.job_type = JPEG_JOB_TYPE_DECODE;
-
-    LOGE("Starting decode job");
-    gettimeofday(&dtime[0], NULL);
-
-    fprintf(stderr, "Starting decode of %s into %s outw %d outh %d\n\n",
-        p_input->filename, p_input->out_filename,
-        p_input->width, p_input->height);
-    rc = jpeg_obj.ops.start_job(&jpeg_obj.job, &jpeg_obj.job_id[i]);
-    if (rc) {
-      LOGE("Error");
-      goto end;
-    }
-  }
-
-  /*
-  usleep(5);
-  jpeg_obj.ops.abort_job(jpeg_obj.job_id[0]);
-  */
-  pthread_mutex_lock(&jpeg_obj.lock);
-  pthread_cond_wait(&jpeg_obj.cond, &jpeg_obj.lock);
-  pthread_mutex_unlock(&jpeg_obj.lock);
-
-  fprintf(stderr, "Decode time %llu ms\n",
-      ((TIME_IN_US(dtime[1]) - TIME_IN_US(dtime[0]))/1000));
-
-
-  jpeg_obj.ops.destroy_session(jpeg_obj.job.decode_job.session_id);
-
-  jpeg_obj.ops.close(jpeg_obj.handle);
-
-
-end:
-  mm_jpegdec_test_free(&jpeg_obj.input);
-  mm_jpegdec_test_free(&jpeg_obj.output);
-  return 0;
-}
-
-/** main:
- *
- *  Arguments:
- *    @argc
- *    @argv
- *
- *  Return:
- *       0 or -ve values
- *
- *  Description:
- *       main function
- *
- **/
-int main(int argc, char* argv[])
-{
-  jpeg_test_input_t dec_test_input;
-  int ret;
-
-  memset(&dec_test_input, 0, sizeof(dec_test_input));
-  ret = mm_jpegdec_test_get_input(argc, argv, &dec_test_input);
-
-  if (ret) {
-    return -1;
-  }
-
-  return decode_test(&dec_test_input);
-}
-
-
diff --git a/camera/QCamera2/stack/mm-lib2d-interface/test/Android.mk b/camera/QCamera2/stack/mm-lib2d-interface/test/Android.mk
deleted file mode 100644
index 679adb4..0000000
--- a/camera/QCamera2/stack/mm-lib2d-interface/test/Android.mk
+++ /dev/null
@@ -1,38 +0,0 @@
-#lib2d sample test
-OLD_LOCAL_PATH := $(LOCAL_PATH)
-MM_LIB2D_TEST_PATH := $(call my-dir)
-
-include $(LOCAL_PATH)/../../common.mk
-include $(CLEAR_VARS)
-LOCAL_PATH := $(MM_LIB2D_TEST_PATH)
-LOCAL_MODULE_TAGS := optional
-
-LOCAL_CFLAGS := -DCAMERA_ION_HEAP_ID=ION_IOMMU_HEAP_ID
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter
-LOCAL_CFLAGS += -D_ANDROID_
-
-ifeq ($(strip $(TARGET_USES_ION)),true)
-LOCAL_CFLAGS += -DUSE_ION
-endif
-
-IMGLIB_HEADER_PATH := $(TARGET_OUT_INTERMEDIATES)/include/mm-camera/imglib
-
-LOCAL_C_INCLUDES += \
-    $(IMGLIB_HEADER_PATH) \
-    $(LOCAL_PATH)/../../common \
-    $(LOCAL_PATH)/../inc
-
-LOCAL_C_INCLUDES+= $(kernel_includes)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps)
-
-LOCAL_SRC_FILES := mm_lib2d_test.c
-
-LOCAL_32_BIT_ONLY := $(BOARD_QTI_CAMERA_32BIT_ONLY)
-LOCAL_MODULE           := mm-lib2d-interface-test
-LOCAL_VENDOR_MODULE := true
-LOCAL_PRELINK_MODULE   := false
-LOCAL_SHARED_LIBRARIES := libcutils libdl libmmlib2d_interface
-
-include $(BUILD_EXECUTABLE)
-
-LOCAL_PATH := $(OLD_LOCAL_PATH)
diff --git a/camera/QCamera2/stack/mm-lib2d-interface/test/mm_lib2d_test.c b/camera/QCamera2/stack/mm-lib2d-interface/test/mm_lib2d_test.c
deleted file mode 100644
index 908a4a6..0000000
--- a/camera/QCamera2/stack/mm-lib2d-interface/test/mm_lib2d_test.c
+++ /dev/null
@@ -1,543 +0,0 @@
-/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above
- *       copyright notice, this list of conditions and the following
- *       disclaimer in the documentation and/or other materials provided
- *       with the distribution.
- *     * Neither the name of The Linux Foundation nor the names of its
- *       contributors may be used to endorse or promote products derived
- *       from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
- * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
- * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
- * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
- * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-
-// System dependencies
-#include <dlfcn.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <sys/time.h>
-
-// Camera dependencies
-#include "img_buffer.h"
-#include "mm_lib2d.h"
-
-
-#define ENABLE_OUTPUT_DUMP 1
-#define ALIGN4K 4032
-#define ALIGN(a, b) (((a) + (b)) & ~(b))
-
-
-/** DUMP_TO_FILE:
- *  @filename: file name
- *  @p_addr: address of the buffer
- *  @len: buffer length
- *
- *  dump the image to the file
- **/
-#define DUMP_TO_FILE(filename, p_addr, len) ({ \
-  size_t rc = 0; \
-  FILE *fp = fopen(filename, "w+"); \
-  if (fp) { \
-    rc = fwrite(p_addr, 1, len, fp); \
-    printf(" ] written size %zu \n",  __LINE__, len); \
-    fclose(fp); \
-  } else { \
-    printf(" ] open %s failed \n",  __LINE__, filename); \
-  } \
-})
-
-/** DUMP_TO_FILE2:
- *  @filename: file name
- *  @p_addr: address of the buffer
- *  @len: buffer length
- *
- *  dump the image to the file if the memory is non-contiguous
- **/
-#define DUMP_TO_FILE2(filename, p_addr1, len1, p_addr2, len2) ({ \
-  size_t rc = 0; \
-  FILE *fp = fopen(filename, "w+"); \
-  if (fp) { \
-    rc = fwrite(p_addr1, 1, len1, fp); \
-    rc = fwrite(p_addr2, 1, len2, fp); \
-    printf(" ] written %zu %zu \n",  __LINE__, len1, len2); \
-    fclose(fp); \
-  } else { \
-    printf(" ] open %s failed \n",  __LINE__, filename); \
-  } \
-})
-
-/** img_lib_buffert
- * @ptr: handle to the imglib library
- * @img_buffer_get: function pointer to img_buffer_get
- * @img_buffer_release: function pointer to img_buffer_release
- * @img_buffer_cacheops: function pointer to img_buffer_cacheops
-**/
-typedef struct {
-  void *ptr;
-  int (*img_buffer_get)(img_buf_type_t type, int heapid, int8_t cached, int length,
-    img_mem_handle_t *p_handle);
-  int (*img_buffer_release)(img_mem_handle_t *p_handle);
-  int (*img_buffer_cacheops)(img_mem_handle_t *p_handle, img_cache_ops_t ops,
-  img_mem_alloc_type_t mem_alloc_type);
-} img_lib_buffert;
-
-/** input_yuv_data
- * @filename: input test filename
- * @format: format of the input yuv frame
- * @wdith: wdith of the input yuv frame
- * @height: height of the input yuv frame
- * @stride: stride of the input yuv frame
- * @offset: offset to the yuv data in the input file
-**/
-typedef struct input_yuv_data_t {
-  char filename[512];
-  cam_format_t format;
-  int32_t wdith;
-  int32_t height;
-  int32_t stride;
-  int32_t offset;
-} input_yuv_data;
-
-input_yuv_data input_nv21[] = {
-  {"sample0_768x512.yuv",                             CAM_FORMAT_YUV_420_NV21, 768,  512,  768,  0},
-  {"sample1_3200x2400.yuv",                           CAM_FORMAT_YUV_420_NV21, 3200, 2400, 3200, 0},
-  {"sample2_1920x1080.yuv",                           CAM_FORMAT_YUV_420_NV21, 1920, 1080, 1920, 0},
-  {"sample3_3200x2400.yuv",                           CAM_FORMAT_YUV_420_NV21, 3200, 2400, 3200, 0},
-  {"sample4_4208x3120.yuv",                           CAM_FORMAT_YUV_420_NV21, 4208, 3120, 4208, 0},
-  {"sample5_1984x2592.yuv",                           CAM_FORMAT_YUV_420_NV21, 1984, 2592, 1984, 0},
-  {"sample6_4000_3000.yuv",                           CAM_FORMAT_YUV_420_NV21, 4000, 3000, 4000, 0},
-  {"sample7_3200_2400.yuv",                           CAM_FORMAT_YUV_420_NV21, 3200, 2400, 3200, 0},
-  {"sample8_3008_4000.yuv",                           CAM_FORMAT_YUV_420_NV21, 3008, 4000, 3008, 0},
-  {"sample9_5312x2988.yuv",                           CAM_FORMAT_YUV_420_NV21, 5312, 2988, 5312, 0},
-  {"sample10_4128x3096.yuv",                          CAM_FORMAT_YUV_420_NV21, 4128, 3096, 4128, 0},
-  {"sample11_4208x3120.yuv",                          CAM_FORMAT_YUV_420_NV21, 4208, 3120, 4208, 0},
-  {"sample12_3200x2400.yuv",                          CAM_FORMAT_YUV_420_NV21, 3200, 2400, 3200, 0},
-  {"sample13_width_1080_height_1440_stride_1088.yuv", CAM_FORMAT_YUV_420_NV21, 1080, 1440, 1088, 0},
-  {"sample14_width_1080_height_1920_stride_1088.yuv", CAM_FORMAT_YUV_420_NV21, 1080, 1920, 1088, 0},
-  {"sample15_width_1944_height_2592_stride_1984.yuv", CAM_FORMAT_YUV_420_NV21, 1944, 2592, 1984, 0},
-  {"sample16_width_3000_height_4000_stride_3008.yuv", CAM_FORMAT_YUV_420_NV21, 3000, 4000, 3008, 0},
-  {"sample17_width_3120_height_4208_stride_3136.yuv", CAM_FORMAT_YUV_420_NV21, 3120, 4208, 3136, 0},
-  {"sample18_width_3200_height_2400_stride_3200.yuv", CAM_FORMAT_YUV_420_NV21, 3200, 2400, 3200, 0},
-  {"sample19_width_1944_height_2592_stride_1984.yuv", CAM_FORMAT_YUV_420_NV21, 1944, 2592, 1984, 0},
-};
-
-// assuming buffer format is always ARGB
-void lib2d_dump_tga(void *addr, cam_format_t format, int width,
-  int height, int stride, char *fname)
-{
-  int i, j;
-  FILE *f;
-  unsigned char *pb = (unsigned char *)addr;
-  uint32_t *pd = (uint32_t *)addr;
-  int bpp = 32;
-
-  f = fopen(fname, "wb");
-  if (f) {
-    // header
-    fprintf(f, "%c%c%c%c", 0, 0, 2, 0);
-    fprintf(f, "%c%c%c%c", 0, 0, 0, 0);
-    fprintf(f, "%c%c%c%c", 0, 0, 0, 0);
-    fprintf(f, "%c%c%c%c", width & 0xff, width >> 8, height & 0xff, height >> 8);
-    fprintf(f, "%c%c", bpp, 32);
-
-    for (i = 0; i < height; i++) {
-      for (j = 0; j < width; j++) {
-        fprintf(f, "%c%c%c%c",
-          pd[(i*stride>>2)+j] & 0xff,           // b
-          (pd[(i*stride>>2)+j] >> 8) & 0xff,    // g
-          (pd[(i*stride>>2)+j] >> 16) & 0xff,   // r
-          (pd[(i*stride>>2)+j] >> 24) & 0xff);  // a
-      }
-    }
-    fclose(f);
-  }
-}
-
-/**
- * Function: lib2d_test_client_cb
- *
- * Description: Callback that is called on completion of requested job.
- *
- * Input parameters:
- *   userdata - App userdata
- *   jobid - job id that is finished execution
- *
- * Return values:
- *   MM_LIB2D_SUCCESS
- *   MM_LIB2D_ERR_GENERAL
- *
- * Notes: none
- **/
-lib2d_error lib2d_test_client_cb(void *userdata, int jobid)
-{
-  printf("%s %d, jobid=%d \n",  __LINE__, jobid);
-  return MM_LIB2D_SUCCESS;
-}
-
-/**
- * Function: lib2d_test_load_input_yuv_data
- *
- * Description: Loads yuv data from input file.
- *
- * Input parameters:
- *   fileName - input yuv filename
- *   offset - offset to the yuv data in the input file
- *   y_size - y plane size in input yuv file
- *   crcb_size - crcb plane size in input yuv file
- *   crcb_offset - crcb offset in the memory at
- *       which crcb data need to be loaded
- *   addr - y plane memory address where y plane
- *       data need to be loaded.
- *
- * Return values:
- *   MM_LIB2D_SUCCESS
- *   MM_LIB2D_ERR_GENERAL
- *
- * Notes: none
- **/
-lib2d_error lib2d_test_load_input_yuv_data(char *fileName, int offset,
-    int32_t y_size, int32_t crcb_size, int32_t crcb_offset,
-    void *addr)
-{
-  size_t i;
-  FILE  *fp       = 0;
-  void  *y_ptr    = addr;
-  void  *crcb_ptr = (uint8_t *)addr + crcb_offset;
-
-  printf("y_ptr=%p, crcb_ptr=%p \n", y_ptr, crcb_ptr);
-
-  fp = fopen(fileName, "rb");
-  if(fp) {
-    if(offset) {
-      fseek(fp, offset, SEEK_SET);
-    }
-    i = fread(y_ptr, 1, y_size, fp);
-    i = fread(crcb_ptr, 1, crcb_size, fp);
-
-    fclose( fp );
-  } else {
-    printf("failed to open file %s \n", fileName);
-    return MM_LIB2D_ERR_GENERAL;
-  }
-
-  return MM_LIB2D_SUCCESS;
-}
-
-/**
- * Function: lib2d_test_load_input_yuv_data
- *
- * Description: Loads yuv data from input file.
- *
- * Input parameters:
- *   fileName - input yuv filename
- *   offset - offset to the yuv data in the input file
- *   input_yuv_stride - y plane stride in input yuv file
- *   y_plane_stride - y plane stride in buffer memory
- *   height - height of yuv image
- *   crcb_offset - crcb offset in the memory at
- *       which crcb data need to be loaded
- *   addr - y plane memory address where y plane
- *       data need to be loaded.
- *
- * Return values:
- *   MM_LIB2D_SUCCESS
- *   MM_LIB2D_ERR_GENERAL
- *
- * Notes: none
- **/
-lib2d_error lib2d_test_load_input_yuv_data_linebyline(char *fileName,
-    int offset, int32_t input_yuv_stride, int32_t y_plane_stride,
-    int32_t height, int32_t crcb_offset, void *addr)
-{
-  size_t i;
-  FILE  *fp       = 0;
-  void  *y_ptr    = addr;
-  void  *crcb_ptr = (uint8_t *)addr + crcb_offset;
-
-  printf("y_ptr=%p, crcb_ptr=%p \n", y_ptr, crcb_ptr);
-
-  fp = fopen(fileName, "rb");
-  if(fp) {
-    if(offset) {
-      fseek(fp, offset, SEEK_SET);
-    }
-    if (input_yuv_stride == y_plane_stride) {
-      //load y plane
-      i = fread(y_ptr, 1, (input_yuv_stride * height), fp);
-      // load UV plane
-      i = fread(crcb_ptr, 1, (input_yuv_stride * height / 2), fp);
-    } else {
-      int line = 0;
-      // load Y plane
-      for (line = 0;line < height; line++) {
-        i = fread(y_ptr, 1, input_yuv_stride, fp);
-        y_ptr = (void *)((uint8_t *)y_ptr + y_plane_stride);
-      }
-      for (line = 0;line < height; line++) {
-        i = fread(crcb_ptr, 1, input_yuv_stride, fp);
-        crcb_ptr = (void *)((uint8_t *)crcb_ptr + y_plane_stride);
-      }
-    }
-
-    fclose( fp );
-  } else {
-    printf("failed to open file %s \n", fileName);
-    return MM_LIB2D_ERR_GENERAL;
-  }
-
-  return MM_LIB2D_SUCCESS;
-}
-
-/**
- * Function: main
- *
- * Description: main function for execution
- *
- * Input parameters:
- *   argc - no.of input arguments
- *   argv - list of arguments
- *
- * Return values:
- *   0 on success
- *   -1 on failure
- *
- * Notes: none
- **/
-int main(int32_t argc, const char * argv[])
-{
-  void            *lib2d_handle       = NULL;
-  lib2d_error      lib2d_err          = MM_LIB2D_SUCCESS;
-  mm_lib2d_buffer  src_buffer         = {0};
-  mm_lib2d_buffer  dst_buffer         = {0};
-  int8_t           ret                = IMG_SUCCESS;
-  int32_t          width              = 0;
-  int32_t          height             = 0;
-  int32_t          input_yuv_stride   = 0;
-  int32_t          stride             = 0;
-  int32_t          y_plane_stride     = 0;
-  int32_t          crcb_plane_stride  = 0;
-  int32_t          y_plane_size       = 0;
-  int32_t          y_plane_size_align = 0;
-  int32_t          crcb_plane_size    = 0;
-  int32_t          yuv_size           = 0;
-  int32_t          rgb_size           = 0;
-  img_mem_handle_t m_yuv_memHandle    = { 0 };
-  img_mem_handle_t m_rgb_memHandle    = { 0 };
-  char             filename_in[512]   = { 0 };
-  char             filename_out[512]  = { 0 };
-  char             filename_raw[512]  = { 0 };
-  int32_t          offset             = 0;
-  unsigned int     total_tests        = 1;
-  cam_format_t     format             = CAM_FORMAT_YUV_420_NV21;
-  unsigned int     index;
-  const char      *filename;
-
-  // Open Imglib library and get the function pointers for
-  // buffer allocation, free, cacheops
-  img_lib_buffert  img_lib;
-  img_lib.ptr = dlopen("libmmcamera_imglib.so", RTLD_NOW);
-  if (!img_lib.ptr) {
-    printf("%s ERROR: couldn't dlopen libmmcamera_imglib.so: %s",
-       dlerror());
-    return -1;
-  }
-
-  /* Get function pointer for functions to allocate ion memory */
-  *(void **)&img_lib.img_buffer_get =
-      dlsym(img_lib.ptr, "img_buffer_get");
-  *(void **)&img_lib.img_buffer_release =
-      dlsym(img_lib.ptr, "img_buffer_release");
-  *(void **)&img_lib.img_buffer_cacheops =
-      dlsym(img_lib.ptr, "img_buffer_cacheops");
-
-  /* Validate function pointers */
-  if ((img_lib.img_buffer_get == NULL) ||
-    (img_lib.img_buffer_release == NULL) ||
-    (img_lib.img_buffer_cacheops == NULL)) {
-    printf(" ERROR mapping symbols from libmmcamera_imglib.so");
-    dlclose(img_lib.ptr);
-    return -1;
-  }
-
-  lib2d_err = mm_lib2d_init(MM_LIB2D_SYNC_MODE, CAM_FORMAT_YUV_420_NV21,
-    CAM_FORMAT_8888_ARGB, &lib2d_handle);
-  if ((lib2d_err != MM_LIB2D_SUCCESS) || (lib2d_handle == NULL)) {
-    return -1;
-  }
-
-  bool run_default = FALSE;
-
-  if ( argc == 7) {
-    filename         = argv[1];
-    width            = (uint32_t)atoi(argv[2]);
-    height           = (uint32_t)atoi(argv[3]);
-    input_yuv_stride = (uint32_t)atoi(argv[4]);
-    offset           = (uint32_t)atoi(argv[5]);
-    format           = (uint32_t)atoi(argv[6]);
-    run_default      = TRUE;
-    printf("Running user provided conversion \n");
-  }
-  else {
-    total_tests = sizeof(input_nv21)/sizeof(input_yuv_data);
-    printf("usage: <binary> <filname> <width> <height> "
-      "<stride> <offset> <format> \n");
-  }
-
-  for (index = 0; index < total_tests; index++)
-  {
-    if(run_default == FALSE) {
-      filename         = input_nv21[index].filename;
-      width            = input_nv21[index].wdith;
-      height           = input_nv21[index].height;
-      input_yuv_stride = input_nv21[index].stride;
-      offset           = input_nv21[index].offset;
-      format           = input_nv21[index].format;
-    }
-
-    snprintf(filename_in, 512, "/data/lib2d/input/%s", filename);
-    snprintf(filename_out, 512, "/data/lib2d/output/%s.tga", filename);
-    snprintf(filename_raw, 512, "/data/lib2d/output/%s.rgba", filename);
-
-    printf("-----------------Running test=%d/%d------------------------- \n",
-      index+1, total_tests);
-    printf("filename=%s, full path=%s, width=%d, height=%d, stride=%d \n",
-      filename, filename_in, width, height, stride);
-
-    // Allocate NV12 buffer
-    y_plane_stride     = ALIGN(width, 32);
-    y_plane_size       = y_plane_stride * height;
-    y_plane_size_align = ALIGN(y_plane_size, ALIGN4K);
-    crcb_plane_stride  = y_plane_stride;
-    crcb_plane_size    = crcb_plane_stride * height / 2;
-    yuv_size           = y_plane_size_align + crcb_plane_size;
-    ret = img_lib.img_buffer_get(IMG_BUFFER_ION_IOMMU, -1, TRUE,
-          yuv_size, &m_yuv_memHandle);
-    if (ret != IMG_SUCCESS) {
-      printf(" ] Error, img buf get failed \n");
-      goto deinit;
-    }
-
-    printf("%s %d yuv buffer properties : w=%d, h=%d, y_stride=%d, "
-      "crcb_stride=%d, y_size=%d, crcb_size=%d, yuv_size=%d, "
-      "crcb_offset=%d \n",
-       __LINE__,
-      width, height, y_plane_stride, crcb_plane_stride, y_plane_size,
-      crcb_plane_size, yuv_size, y_plane_size_align);
-    printf("%s %d yuv buffer properties : fd=%d, ptr=%p, size=%d \n",
-       __LINE__, m_yuv_memHandle.fd, m_yuv_memHandle.vaddr,
-      m_yuv_memHandle.length);
-
-    // Allocate ARGB buffer
-    stride   = width * 4;
-    stride   = ALIGN(stride, 32);
-    rgb_size = stride * height;
-    ret = img_lib.img_buffer_get(IMG_BUFFER_ION_IOMMU, -1, TRUE,
-          rgb_size, &m_rgb_memHandle);
-    if (ret != IMG_SUCCESS) {
-      printf(" ] Error, img buf get failed");
-      img_lib.img_buffer_release(&m_yuv_memHandle);
-      goto deinit;
-    }
-
-    printf("%s %d rgb buffer properties : w=%d, h=%d, stride=%d, size=%d \n",
-       __LINE__, width, height, stride, rgb_size);
-    printf("%s %d rgb buffer properties : fd=%d, ptr=%p, size=%d \n",
-       __LINE__, m_rgb_memHandle.fd, m_rgb_memHandle.vaddr,
-      m_rgb_memHandle.length);
-
-#if 0
-    lib2d_err = lib2d_test_load_input_yuv_data(filename_in, offset,
-      (input_yuv_stride * height), (input_yuv_stride * height / 2), y_plane_size_align,
-      m_yuv_memHandle.vaddr);
-    if (lib2d_err != MM_LIB2D_SUCCESS) {
-      printf(" ] Error loading the input buffer \n");
-      goto release;
-    }
-#else
-    lib2d_err = lib2d_test_load_input_yuv_data_linebyline(filename_in, offset,
-      input_yuv_stride, y_plane_stride,height, y_plane_size_align,
-      m_yuv_memHandle.vaddr);
-    if (lib2d_err != MM_LIB2D_SUCCESS) {
-      printf(" ] Error loading the input buffer \n");
-      goto release;
-    }
-#endif
-    // Setup source buffer
-    src_buffer.buffer_type = MM_LIB2D_BUFFER_TYPE_YUV;
-    src_buffer.yuv_buffer.fd      = m_yuv_memHandle.fd;
-    src_buffer.yuv_buffer.format  = format;
-    src_buffer.yuv_buffer.width   = width;
-    src_buffer.yuv_buffer.height  = height;
-    src_buffer.yuv_buffer.plane0  = m_yuv_memHandle.vaddr;
-    src_buffer.yuv_buffer.stride0 = y_plane_stride;
-    src_buffer.yuv_buffer.plane1  = (int8_t *)m_yuv_memHandle.vaddr +
-                                    y_plane_size_align;
-    src_buffer.yuv_buffer.stride1 = crcb_plane_stride;
-
-    // Setup dst buffer
-    dst_buffer.buffer_type = MM_LIB2D_BUFFER_TYPE_RGB;
-    dst_buffer.rgb_buffer.fd     = m_rgb_memHandle.fd;
-    dst_buffer.rgb_buffer.format = CAM_FORMAT_8888_ARGB;
-    dst_buffer.rgb_buffer.width  = width;
-    dst_buffer.rgb_buffer.height = height;
-    dst_buffer.rgb_buffer.buffer = m_rgb_memHandle.vaddr;
-    dst_buffer.rgb_buffer.stride = stride;
-
-    img_lib.img_buffer_cacheops(&m_yuv_memHandle,
-      IMG_CACHE_CLEAN_INV, IMG_INTERNAL);
-
-    lib2d_err = mm_lib2d_start_job(lib2d_handle, &src_buffer, &dst_buffer,
-      index, NULL, lib2d_test_client_cb, 0);
-    if (lib2d_err != MM_LIB2D_SUCCESS) {
-      printf(" ] Error in mm_lib2d_start_job \n");
-      goto release;
-    }
-
-    img_lib.img_buffer_cacheops(&m_rgb_memHandle,
-      IMG_CACHE_CLEAN_INV, IMG_INTERNAL);
-
-#ifdef ENABLE_OUTPUT_DUMP
-    // Dump output files
-    // snprintf(filename_in, 512, "/data/lib2d/output/%s", filename);
-    // DUMP_TO_FILE2(filename_in, src_buffer.yuv_buffer.plane0, y_plane_size, src_buffer.yuv_buffer.plane1, crcb_plane_size);
-    // DUMP_TO_FILE(filename_raw, dst_buffer.rgb_buffer.buffer, rgb_size);
-    printf("Dumping output file %s \n", filename_out);
-    lib2d_dump_tga(dst_buffer.rgb_buffer.buffer, 1,
-      width, height, stride, filename_out);
-#endif
-
-    img_lib.img_buffer_release(&m_rgb_memHandle);
-    img_lib.img_buffer_release(&m_yuv_memHandle);
-  }
-
-  mm_lib2d_deinit(lib2d_handle);
-
-  return 0;
-
-release:
-  img_lib.img_buffer_release(&m_rgb_memHandle);
-  img_lib.img_buffer_release(&m_yuv_memHandle);
-deinit:
-  mm_lib2d_deinit(lib2d_handle);
-  printf("%s %d some error happened, tests completed = %d/%d \n",
-     __LINE__, index - 1, total_tests);
-  return -1;
-}
-
-
-- 
2.7.4

