From 2d135174ade2e00ba0dd4a2727ff723db1aef6e6 Mon Sep 17 00:00:00 2001
From: Santhosh Kumar Thimmanna Bhattar <sthim@codeaurora.org>
Date: Wed, 4 Apr 2018 15:37:33 +0530
Subject: [PATCH 08/12] mido: QCamera2: HAL: Changes to fix QCameraDisplay
 compilation issues

Changes to fix QCameraDisplay compilation issue.

Change-Id: Iaa28e2b0acff0556d6052945e446066aa27be5b1
---
 camera/QCamera2/Android.mk              |  16 +++-
 camera/QCamera2/util/QCameraDisplay.cpp | 153 ++++++++++++++++++++++++++++----
 camera/QCamera2/util/QCameraDisplay.h   |  67 ++++++++++++--
 3 files changed, 209 insertions(+), 27 deletions(-)

diff --git a/camera/QCamera2/Android.mk b/camera/QCamera2/Android.mk
index 1058439..45663cf 100644
--- a/camera/QCamera2/Android.mk
+++ b/camera/QCamera2/Android.mk
@@ -13,6 +13,7 @@ LOCAL_SRC_FILES := \
         util/QCameraFlash.cpp \
         util/QCameraPerf.cpp \
         util/QCameraQueue.cpp \
+        util/QCameraDisplay.cpp \
         util/QCameraCommon.cpp \
         QCamera2Hal.cpp \
         QCamera2Factory.cpp
@@ -69,7 +70,16 @@ ifeq ($(TARGET_USES_MEDIA_EXTENSIONS), true)
 LOCAL_CFLAGS += -DUSE_MEDIA_EXTENSIONS
 endif
 
+#USE_DISPLAY_SERVICE from Android O onwards
+#to receive vsync event from display
+ifeq ($(filter OMR1 O 8.1.0, $(PLATFORM_VERSION)), )
+USE_DISPLAY_SERVICE := true
+LOCAL_CFLAGS += -DUSE_DISPLAY_SERVICE
+LOCAL_CFLAGS += -std=c++11 -std=gnu++1y
+else
 LOCAL_CFLAGS += -std=c++11 -std=gnu++0x
+endif
+
 #HAL 1.0 Flags
 LOCAL_CFLAGS += -DDEFAULT_DENOISE_MODE_ON -DHAL3 -DQCAMERA_REDEFINE_LOG
 
@@ -116,7 +126,11 @@ LOCAL_C_INCLUDES += \
 LOCAL_SHARED_LIBRARIES := liblog libhardware libutils libcutils libdl libsync
 LOCAL_SHARED_LIBRARIES += libmmcamera_interface libmmjpeg_interface libui libcamera_metadata
 LOCAL_SHARED_LIBRARIES += libqdMetaData libqservice libbinder
-LOCAL_SHARED_LIBRARIES += libcutils libdl
+ifeq ($(USE_DISPLAY_SERVICE),true)
+LOCAL_SHARED_LIBRARIES += android.frameworks.displayservice@1.0 android.hidl.base@1.0 libhidlbase
+else
+LOCAL_SHARED_LIBRARIES += libgui
+endif
 ifeq ($(TARGET_TS_MAKEUP),true)
 LOCAL_SHARED_LIBRARIES += libts_face_beautify_hal libts_detected_face_hal
 endif
diff --git a/camera/QCamera2/util/QCameraDisplay.cpp b/camera/QCamera2/util/QCameraDisplay.cpp
index d77f642..074dcc9 100644
--- a/camera/QCamera2/util/QCameraDisplay.cpp
+++ b/camera/QCamera2/util/QCameraDisplay.cpp
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
@@ -29,23 +29,37 @@
 
 #define LOG_TAG "QCameraDisplay"
 
-// To remove
-#include <cutils/properties.h>
-
 // Camera dependencies
-#include "QCamera2HWI.h"
-#include "QCameraDisplay.h"
-
+#include <properties.h>
 extern "C" {
 #include "mm_camera_dbg.h"
 }
+#include "QCameraDisplay.h"
 
 #define CAMERA_VSYNC_WAIT_MS               33 // Used by vsync thread to wait for vsync timeout.
 #define DISPLAY_EVENT_RECEIVER_ARRAY_SIZE  1
 #define DISPLAY_DEFAULT_FPS                60
 
+#ifdef USE_DISPLAY_SERVICE
+using ::android::frameworks::displayservice::V1_0::IDisplayEventReceiver;
+using ::android::frameworks::displayservice::V1_0::IDisplayService;
+using ::android::frameworks::displayservice::V1_0::IEventCallback;
+using ::android::frameworks::displayservice::V1_0::Status;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::sp;
+#else //USE_DISPLAY_SERVICE
+#include <utils/Errors.h>
+#include <utils/Looper.h>
+using ::android::status_t;
+using ::android::NO_ERROR;
+using ::android::Looper;
+#define ALOOPER_EVENT_INPUT android::Looper::EVENT_INPUT
+#endif //USE_DISPLAY_SERVICE
+
 namespace qcamera {
 
+#ifndef USE_DISPLAY_SERVICE
 /*===========================================================================
  * FUNCTION   : vsyncEventReceiverCamera
  *
@@ -68,7 +82,7 @@ int QCameraDisplay::vsyncEventReceiverCamera(__unused int fd,
     while ((n = pQCameraDisplay->mDisplayEventReceiver.getEvents(buffer,
             DISPLAY_EVENT_RECEIVER_ARRAY_SIZE)) > 0) {
         for (int i = 0 ; i < n ; i++) {
-            if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
+            if (buffer[i].header.type == android::DisplayEventReceiver::DISPLAY_EVENT_VSYNC) {
                 pQCameraDisplay->computeAverageVsyncInterval(buffer[i].header.timestamp);
             }
         }
@@ -107,9 +121,10 @@ void* QCameraDisplay::vsyncThreadCamera(void * data)
     }
     return NULL;
 }
+#endif //USE_DISPLAY_SERVICE
 
 /*===========================================================================
- * FUNCTION   : ~QCameraDisplay
+ * FUNCTION   : QCameraDisplay
  *
  * DESCRIPTION: constructor of QCameraDisplay
  *
@@ -123,20 +138,30 @@ QCameraDisplay::QCameraDisplay()
       mOldTimeStamp(0),
       mVsyncHistoryIndex(0),
       mAdditionalVsyncOffsetForWiggle(0),
-      mThreadExit(0),
       mNum_vsync_from_vfe_isr_to_presentation_timestamp(0),
       mSet_timestamp_num_ns_prior_to_vsync(0),
       mVfe_and_mdp_freq_wiggle_filter_max_ns(0),
-      mVfe_and_mdp_freq_wiggle_filter_min_ns(0)
+      mVfe_and_mdp_freq_wiggle_filter_min_ns(0),
+#ifndef USE_DISPLAY_SERVICE
+      mThreadExit(0)
+#else //USE_DISPLAY_SERVICE
+      m_bInitDone(false),
+      m_bSyncing(false)
+#endif //USE_DISPLAY_SERVICE
 {
+#ifdef USE_DISPLAY_SERVICE
+    mDisplayService = nullptr;
+    mDisplayEventReceiver = nullptr;
+#else //USE_DISPLAY_SERVICE
     int rc = NO_ERROR;
 
     memset(&mVsyncIntervalHistory, 0, sizeof(mVsyncIntervalHistory));
     rc = pthread_create(&mVsyncThreadCameraHandle, NULL, vsyncThreadCamera, (void *)this);
     if (rc == NO_ERROR) {
-        char    value[PROPERTY_VALUE_MAX];
-        nsecs_t default_vsync_interval;
         pthread_setname_np(mVsyncThreadCameraHandle, "CAM_Vsync");
+#endif //USE_DISPLAY_SERVICE
+        char  value[PROPERTY_VALUE_MAX];
+        nsecs_t default_vsync_interval;
         // Read a list of properties used for tuning
         property_get("persist.camera.disp.num_vsync", value, "4");
         mNum_vsync_from_vfe_isr_to_presentation_timestamp = atoi(value);
@@ -163,9 +188,11 @@ QCameraDisplay::QCameraDisplay()
                 vfe_and_mdp_freq_wiggle_filter_min_ns %llu",
                 mVfe_and_mdp_freq_wiggle_filter_max_ns,
                 mVfe_and_mdp_freq_wiggle_filter_min_ns);
-    } else {
-        mVsyncThreadCameraHandle = 0;
-    }
+#ifndef USE_DISPLAY_SERVICE
+      } else {
+          mVsyncThreadCameraHandle = 0;
+      }
+#endif //USE_DISPLAY_SERVICE
 }
 
 /*===========================================================================
@@ -179,11 +206,98 @@ QCameraDisplay::QCameraDisplay()
  *==========================================================================*/
 QCameraDisplay::~QCameraDisplay()
 {
+#ifndef USE_DISPLAY_SERVICE
     mThreadExit = 1;
     if (mVsyncThreadCameraHandle != 0) {
         pthread_join(mVsyncThreadCameraHandle, NULL);
     }
+#endif //USE_DISPLAY_SERVICE
+}
+
+#ifdef USE_DISPLAY_SERVICE
+/*===========================================================================
+ * FUNCTION   : init
+ *
+ * DESCRIPTION: Get the display service and register for the callback. OnVsync
+ *              and onHotPlug callback will we called based on setVsyncRate
+ *              parameter. Check isInitDone to see if init is success or not.
+ *
+ * PARAMETERS : none
+ *
+ * RETURN     : none.
+ *==========================================================================*/
+void
+QCameraDisplay::init()
+{
+    //get the display service and register for Event receiver.
+    mDisplayService = android::frameworks::displayservice::V1_0::IDisplayService::getService();
+    if(mDisplayService == nullptr)
+    {
+        LOGE("Camera failed to get Displayservice for vsync.");
+        return;
+    }
+
+    Return<sp<IDisplayEventReceiver>> ret = mDisplayService->getEventReceiver();
+    mDisplayEventReceiver = ret;
+    if(!ret.isOk() || (mDisplayEventReceiver == nullptr))
+    {
+      LOGE("Failed to get display event receiver");
+      return;
+    }
+
+    m_bInitDone = true;
+
+}
+
+/*===========================================================================
+ * FUNCTION   : startVsync
+ *
+ * DESCRIPTION: Start or stop the onVsync or onHotPlug callback.
+ *
+ * PARAMETERS : true to start callback or false to stop callback
+ *
+ * RETURN     : true in success, false in error case.
+ *==========================================================================*/
+bool
+QCameraDisplay::startVsync(bool bStart)
+{
+    if(!m_bInitDone || mDisplayEventReceiver == nullptr)
+    {
+        LOGE("ERROR: Display event callbacks is not registered");
+        return false;
+    }
+
+    if(bStart)
+    {
+        Return<Status> retVal = mDisplayEventReceiver->init(this /*setting callbacks*/ );
+        if(!retVal.isOk() || (Status::SUCCESS != static_cast<Status>(retVal)) )
+        {
+            LOGE("Failed to register display vsync callback");
+            return false;
+        }
+
+        retVal = mDisplayEventReceiver->setVsyncRate(1 /*send callback after this many events*/);
+        if(!retVal.isOk() || (Status::SUCCESS != static_cast<Status>(retVal)) )
+        {
+            LOGE("Failed to start vsync events");
+            return false;
+        }
+    }
+    else
+    {
+        Return<Status> retVal = mDisplayEventReceiver->setVsyncRate(0 /*send callback after this many events*/);
+        if(!retVal.isOk() || (Status::SUCCESS != static_cast<Status>(retVal)) )
+        {
+            LOGE("Failed to stop vsync events");
+            return false;
+        }
+    }
+    LOGI("Display sync event %s", (bStart)?"started":"stopped");
+
+    m_bSyncing = (bStart)?true:false;
+    return true; //sync rate is set
 }
+#endif //USE_DISPLAY_SERVICE
 
 /*===========================================================================
  * FUNCTION   : computeAverageVsyncInterval
@@ -244,7 +358,12 @@ nsecs_t QCameraDisplay::computePresentationTimeStamp(nsecs_t frameTimeStamp)
     nsecs_t presentationTimeStamp = 0;
     int     expectedVsyncOffset   = 0;
     int     vsyncOffset;
-
+#ifdef USE_DISPLAY_SERVICE
+    if(!isSyncing())
+    {
+       return 0;
+    }
+#endif //USE_DISPLAY_SERVICE
     if ( (mAvgVsyncInterval != 0) && (mVsyncTimeStamp != 0) ) {
         // Compute presentation time stamp in future as per the following formula
         // future time stamp = vfe time stamp +  N *  average vsync interval
diff --git a/camera/QCamera2/util/QCameraDisplay.h b/camera/QCamera2/util/QCameraDisplay.h
index 97a4003..ff563b6 100644
--- a/camera/QCamera2/util/QCameraDisplay.h
+++ b/camera/QCamera2/util/QCameraDisplay.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2015-2016, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2015-2018, The Linux Foundation. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are
@@ -29,34 +29,74 @@
 
 #ifndef __QCAMERADISPLAY_H__
 #define __QCAMERADISPLAY_H__
-
-#include <gui/DisplayEventReceiver.h>
+#ifdef USE_DISPLAY_SERVICE
+#ifdef LIKELY
+#undef LIKELY
+#undef UNLIKELY
+#endif //LIKELY
+#include <android/frameworks/displayservice/1.0/IDisplayService.h>
+#include <android/frameworks/displayservice/1.0/IEventCallback.h>
+#include <android/frameworks/displayservice/1.0/IDisplayEventReceiver.h>
 #include <android/looper.h>
 #include <utils/Looper.h>
 
+using ::android::frameworks::displayservice::V1_0::IDisplayEventReceiver;
+using ::android::frameworks::displayservice::V1_0::IDisplayService;
+using ::android::frameworks::displayservice::V1_0::IEventCallback;
+using ::android::frameworks::displayservice::V1_0::Status;
+using ::android::hardware::Return;
+using ::android::hardware::Void;
+using ::android::sp;
+#else //USE_DISPLAY_SERVICE
+#include <utils/Timers.h>
+#include <gui/DisplayEventReceiver.h>
+#endif //USE_DISPLAY_SERVICE
+
 namespace qcamera {
 
 #define CAMERA_NUM_VSYNC_INTERVAL_HISTORY  8
 #define NSEC_PER_MSEC 1000000LLU
 
+#ifdef USE_DISPLAY_SERVICE
+class QCameraDisplay : public IEventCallback {
+#else //USE_DISPLAY_SERVICE
 class QCameraDisplay {
+#endif //USE_DISPLAY_SERVICE
+
 public:
     QCameraDisplay();
     ~QCameraDisplay();
+
+#ifdef USE_DISPLAY_SERVICE
+    void        init();
+    bool        isInited() { return m_bInitDone; }
+    bool        isSyncing() {return m_bSyncing; }
+
+    bool        startVsync(bool start);
+
+    Return<void> onVsync(uint64_t timestamp, uint32_t count) override {
+        ALOGV("onVsync: timestamp=%llu count=%d", timestamp, count);
+        computeAverageVsyncInterval(timestamp);
+        return Void();
+    }
+    Return<void> onHotplug(uint64_t timestamp, bool connected) override {
+        ALOGV("onHotplug: timestamp=%llu connected=%s", timestamp, connected ? "true" : "false");
+        return Void();
+    }
+
+#else //USE_DISPLAY_SERVICE
     static int   vsyncEventReceiverCamera(int fd, int events, void* data);
     static void* vsyncThreadCamera(void * data);
-    void         computeAverageVsyncInterval(nsecs_t currentVsyncTimeStamp);
-    nsecs_t      computePresentationTimeStamp(nsecs_t frameTimeStamp);
-
+#endif //USE_DISPLAY_SERVICE
+    void        computeAverageVsyncInterval(nsecs_t currentVsyncTimeStamp);
+    nsecs_t     computePresentationTimeStamp(nsecs_t frameTimeStamp);
 private:
-    pthread_t mVsyncThreadCameraHandle;
     nsecs_t   mVsyncTimeStamp;
     nsecs_t   mAvgVsyncInterval;
     nsecs_t   mOldTimeStamp;
     nsecs_t   mVsyncIntervalHistory[CAMERA_NUM_VSYNC_INTERVAL_HISTORY];
     nsecs_t   mVsyncHistoryIndex;
     nsecs_t   mAdditionalVsyncOffsetForWiggle;
-    uint32_t  mThreadExit;
     // Tunable property. Increasing this will increase the frame delay and will loose
     // the real time display.
     uint32_t  mNum_vsync_from_vfe_isr_to_presentation_timestamp;
@@ -68,8 +108,17 @@ private:
     // 30.2 fps vs display running at 60 fps.
     nsecs_t  mVfe_and_mdp_freq_wiggle_filter_max_ns;
     nsecs_t  mVfe_and_mdp_freq_wiggle_filter_min_ns;
-
+#ifdef USE_DISPLAY_SERVICE
+    bool     m_bInitDone;
+    bool     m_bSyncing;
+    sp<IDisplayEventReceiver> mDisplayEventReceiver;
+    sp<IDisplayService> mDisplayService;
+#else //USE_DISPLAY_SERVICE
+    pthread_t mVsyncThreadCameraHandle;
+    uint32_t  mThreadExit;
     android::DisplayEventReceiver  mDisplayEventReceiver;
+#endif //USE_DISPLAY_SERVICE
+
 };
 
 }; // namespace qcamera
-- 
2.7.4

